!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e=e||self).WebStreamsPolyfill={})}(this,function(e){"use strict";const r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol:e=>`Symbol(${e})`,t=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e};function o(){}const n="undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0;var a={default:o};const i=Number.isNaN||function(e){return e!=e};function s(e){return e&&e.default||e}s(a);var l=function(e,r){return e(r={exports:{}},r.exports),r.exports}(function(e,t){const o=r('is "detached" for our purposes');function n(e,r,t){if("function"!=typeof e)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,r,t)}function a(e,r,t){try{return Promise.resolve(n(e,r,t))}catch(e){return Promise.reject(e)}}t.typeIsObject=(e=>"object"==typeof e&&null!==e||"function"==typeof e),t.createDataProperty=((e,r,t)=>{Object.defineProperty(e,r,{value:t,writable:!0,enumerable:!0,configurable:!0})}),t.createArrayFromList=(e=>e.slice()),t.ArrayBufferCopy=((e,r,t,o,n)=>{new Uint8Array(e).set(new Uint8Array(t,o,n),r)}),t.IsFiniteNonNegativeNumber=(e=>!1!==t.IsNonNegativeNumber(e)&&e!==1/0),t.IsNonNegativeNumber=(e=>"number"==typeof e&&(!i(e)&&!(e<0))),t.Call=n,t.CreateAlgorithmFromUnderlyingMethod=((e,r,t,o)=>{const n=e[r];if(void 0!==n){if("function"!=typeof n)throw new TypeError(`${n} is not a method`);switch(t){case 0:return()=>a(n,e,o);case 1:return r=>{const t=[r].concat(o);return a(n,e,t)}}}return()=>Promise.resolve()}),t.InvokeOrNoop=((e,r,t)=>{const o=e[r];if(void 0!==o)return n(o,e,t)}),t.PromiseCall=a,t.TransferArrayBuffer=(e=>{const r=e.slice();return Object.defineProperty(e,"byteLength",{get:()=>0}),e[o]=!0,r}),t.IsDetachedBuffer=(e=>o in e),t.ValidateAndNormalizeHighWaterMark=(e=>{if(e=Number(e),i(e)||e<0)throw new RangeError("highWaterMark property of a queuing strategy must be non-negative and non-NaN");return e}),t.MakeSizeAlgorithmFromSizeFunction=(e=>{if(void 0===e)return()=>1;if("function"!=typeof e)throw new TypeError("size property of a queuing strategy must be a function");return r=>e(r)}),t.PerformPromiseThen=((e,r,t)=>Promise.prototype.then.call(e,r,t)),t.WaitForAll=((e,r,o)=>{let n=!1;const a=e=>{!1===n&&(n=!0,o(e))};let i=0,s=0;const l=e.length,c=new Array(l);for(const o of e){const e=i,n=t=>{c[e]=t,++s===l&&r(c)};t.PerformPromiseThen(o,n,a),++i}}),t.WaitForAllPromise=((e,r,o)=>{let n,a;const i=new Promise((e,r)=>{n=e,a=r});void 0===o&&(o=(e=>{throw e}));return t.WaitForAll(e,e=>{try{const t=r(e);n(t)}catch(e){a(e)}},e=>{try{const r=o(e);n(r)}catch(e){a(e)}}),i})}),c=l.typeIsObject,u=l.createDataProperty,d=l.createArrayFromList,f=l.ArrayBufferCopy,m=l.IsFiniteNonNegativeNumber,h=l.IsNonNegativeNumber,_=l.Call,b=l.CreateAlgorithmFromUnderlyingMethod,y=l.InvokeOrNoop,p=l.PromiseCall;l.TransferArrayBuffer,l.IsDetachedBuffer;var w={TransferArrayBuffer:function(e){return e},IsDetachedBuffer:function(e){return!1},typeIsObject:c,createDataProperty:u,createArrayFromList:d,ArrayBufferCopy:f,IsFiniteNonNegativeNumber:m,IsNonNegativeNumber:h,Call:_,CreateAlgorithmFromUnderlyingMethod:b,InvokeOrNoop:y,PromiseCall:p,ValidateAndNormalizeHighWaterMark:l.ValidateAndNormalizeHighWaterMark,MakeSizeAlgorithmFromSizeFunction:l.MakeSizeAlgorithmFromSizeFunction,PerformPromiseThen:l.PerformPromiseThen,WaitForAll:l.WaitForAll,WaitForAllPromise:l.WaitForAllPromise};function S(){}S.AssertionError=o;var g=s({default:S}),v={rethrowAssertionErrorRejection:e=>{e&&e instanceof g.AssertionError&&setTimeout(()=>{throw e},0)}},P=s(w);const{IsFiniteNonNegativeNumber:R}=P;var T={DequeueValue:e=>{const r=e._queue.shift();return e._queueTotalSize-=r.size,e._queueTotalSize<0&&(e._queueTotalSize=0),r.value},EnqueueValueWithSize:(e,r,t)=>{if(t=Number(t),!R(t))throw new RangeError("Size must be a finite, non-NaN, non-negative number.");e._queue.push({value:r,size:t}),e._queueTotalSize+=t},PeekQueueValue:e=>{return e._queue[0].value},ResetQueue:e=>{e._queue=[],e._queueTotalSize=0}},C=s({default:o});C("streams:writable-stream:verbose");const{CreateAlgorithmFromUnderlyingMethod:q,InvokeOrNoop:j,ValidateAndNormalizeHighWaterMark:A,IsNonNegativeNumber:E,MakeSizeAlgorithmFromSizeFunction:W,typeIsObject:O}=P,{rethrowAssertionErrorRejection:B}=v,{DequeueValue:z,EnqueueValueWithSize:k,PeekQueueValue:F,ResetQueue:I}=T,D=r("[[AbortSteps]]"),N=r("[[ErrorSteps]]");class WritableStream{constructor(e={},r={}){V(this);const t=r.size;let o=r.highWaterMark;if(void 0!==e.type)throw new RangeError("Invalid type is specified");const n=W(t);void 0===o&&(o=1),function(e,r,t,o){const n=Object.create(WritableStreamDefaultController.prototype);const a=q(r,"write",1,[n]),i=q(r,"close",0,[]),s=q(r,"abort",1,[]);ae(e,n,function(){return j(r,"start",[n])},a,i,s,t,o)}(this,e,o=A(o),n)}get locked(){if(!1===Y(this))throw fe("locked");return $(this)}abort(e){return!1===Y(this)?Promise.reject(fe("abort")):!0===$(this)?Promise.reject(new TypeError("Cannot abort a stream that already has a writer")):H(this,e)}getWriter(){if(!1===Y(this))throw fe("getWriter");return M(this)}}var L={AcquireWritableStreamDefaultWriter:M,CreateWritableStream:function(e,r,t,o,n=1,a=(()=>1)){const i=Object.create(WritableStream.prototype);V(i);const s=Object.create(WritableStreamDefaultController.prototype);return ae(i,s,e,r,t,o,n,a),i},IsWritableStream:Y,IsWritableStreamLocked:$,WritableStream:WritableStream,WritableStreamAbort:H,WritableStreamDefaultControllerErrorIfNeeded:ce,WritableStreamDefaultWriterCloseWithErrorPropagation:function(e){const r=e._ownerWritableStream,t=r._state;if(!0===J(r)||"closed"===t)return Promise.resolve();if("errored"===t)return Promise.reject(r._storedError);return ee(e)},WritableStreamDefaultWriterRelease:oe,WritableStreamDefaultWriterWrite:ne,WritableStreamCloseQueuedOrInFlight:J};function M(e){return new WritableStreamDefaultWriter(e)}function V(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=[],e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=!1}function Y(e){return!!O(e)&&!!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")}function $(e){return void 0!==e._writer}function H(e,r){const t=e._state;if("closed"===t||"errored"===t)return Promise.resolve(void 0);if(void 0!==e._pendingAbortRequest)return e._pendingAbortRequest._promise;let o=!1;"erroring"===t&&(o=!0,r=void 0);const n=new Promise((t,n)=>{e._pendingAbortRequest={_resolve:t,_reject:n,_reason:r,_wasAlreadyErroring:o}});return e._pendingAbortRequest._promise=n,!1===o&&U(e,r),n}function Q(e,r){"writable"!==e._state?x(e):U(e,r)}function U(e,r){const t=e._writableStreamController;e._state="erroring",e._storedError=r;const o=e._writer;void 0!==o&&te(o,r),!1===function(e){if(void 0===e._inFlightWriteRequest&&void 0===e._inFlightCloseRequest)return!1;return!0}(e)&&!0===t._started&&x(e)}function x(e){e._state="errored",e._writableStreamController[N]();const r=e._storedError;for(const t of e._writeRequests)t._reject(r);if(e._writeRequests=[],void 0===e._pendingAbortRequest)return void K(e);const t=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,!0===t._wasAlreadyErroring)return t._reject(r),void K(e);e._writableStreamController[D](t._reason).then(()=>{t._resolve(),K(e)},r=>{t._reject(r),K(e)})}function G(e){e._inFlightCloseRequest._resolve(void 0),e._inFlightCloseRequest=void 0,"erroring"===e._state&&(e._storedError=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._resolve(),e._pendingAbortRequest=void 0)),e._state="closed";const r=e._writer;void 0!==r&&function(e){e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}(r)}function J(e){return void 0!==e._closeRequest||void 0!==e._inFlightCloseRequest}function K(e){void 0!==e._closeRequest&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const r=e._writer;void 0!==r&&(be(r,e._storedError),r._closedPromise.catch(()=>{}))}function X(e,r){const t=e._writer;void 0!==t&&r!==e._backpressure&&(!0===r?function(e){e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}(t):we(t)),e._backpressure=r}class WritableStreamDefaultWriter{constructor(e){if(!1===Y(e))throw new TypeError("WritableStreamDefaultWriter can only be constructed with a WritableStream instance");if(!0===$(e))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=e,e._writer=this;const r=e._state;if("writable"===r)!1===J(e)&&!0===e._backpressure?function(e){e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}(this):pe(this),_e(this);else if("erroring"===r)ye(this,e._storedError),this._readyPromise.catch(()=>{}),_e(this);else if("closed"===r)pe(this),function(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}(this);else{const r=e._storedError;ye(this,r),this._readyPromise.catch(()=>{}),function(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}(this,r),this._closedPromise.catch(()=>{})}}get closed(){return!1===Z(this)?Promise.reject(me("closed")):this._closedPromise}get desiredSize(){if(!1===Z(this))throw me("desiredSize");if(void 0===this._ownerWritableStream)throw he("desiredSize");return function(e){const r=e._ownerWritableStream,t=r._state;if("errored"===t||"erroring"===t)return null;if("closed"===t)return 0;return se(r._writableStreamController)}(this)}get ready(){return!1===Z(this)?Promise.reject(me("ready")):this._readyPromise}abort(e){return!1===Z(this)?Promise.reject(me("abort")):void 0===this._ownerWritableStream?Promise.reject(he("abort")):function(e,r){return H(e._ownerWritableStream,r)}(this,e)}close(){if(!1===Z(this))return Promise.reject(me("close"));const e=this._ownerWritableStream;return void 0===e?Promise.reject(he("close")):!0===J(e)?Promise.reject(new TypeError("cannot close an already-closing stream")):ee(this)}releaseLock(){if(!1===Z(this))throw me("releaseLock");void 0!==this._ownerWritableStream&&oe(this)}write(e){return!1===Z(this)?Promise.reject(me("write")):void 0===this._ownerWritableStream?Promise.reject(he("write to")):ne(this,e)}}function Z(e){return!!O(e)&&!!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")}function ee(e){const r=e._ownerWritableStream,t=r._state;if("closed"===t||"errored"===t)return Promise.reject(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const o=new Promise((e,t)=>{const o={_resolve:e,_reject:t};r._closeRequest=o});return!0===r._backpressure&&"writable"===t&&we(e),function(e){k(e,"close",0),le(e)}(r._writableStreamController),o}function re(e,r){"pending"===e._closedPromiseState?be(e,r):function(e,r){e._closedPromise=Promise.reject(r),e._closedPromiseState="rejected"}(e,r),e._closedPromise.catch(()=>{})}function te(e,r){"pending"===e._readyPromiseState?function(e,r){e._readyPromise_reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}(e,r):function(e,r){e._readyPromise=Promise.reject(r),e._readyPromiseState="rejected"}(e,r),e._readyPromise.catch(()=>{})}function oe(e){const r=e._ownerWritableStream,t=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");te(e,t),re(e,t),r._writer=void 0,e._ownerWritableStream=void 0}function ne(e,r){const t=e._ownerWritableStream,o=t._writableStreamController,n=function(e,r){try{return e._strategySizeAlgorithm(r)}catch(r){return ce(e,r),1}}(o,r);if(t!==e._ownerWritableStream)return Promise.reject(he("write to"));const a=t._state;if("errored"===a)return Promise.reject(t._storedError);if(!0===J(t)||"closed"===a)return Promise.reject(new TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===a)return Promise.reject(t._storedError);const i=function(e){return new Promise((r,t)=>{const o={_resolve:r,_reject:t};e._writeRequests.push(o)})}(t);return function(e,r,t){const o={chunk:r};try{k(e,o,t)}catch(r){return void ce(e,r)}const n=e._controlledWritableStream;if(!1===J(n)&&"writable"===n._state){const r=ue(e);X(n,r)}le(e)}(o,r,n),i}class WritableStreamDefaultController{constructor(){throw new TypeError("WritableStreamDefaultController cannot be constructed explicitly")}error(e){if(!1===function(e){if(!O(e))return!1;if(!Object.prototype.hasOwnProperty.call(e,"_controlledWritableStream"))return!1;return!0}(this))throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");"writable"===this._controlledWritableStream._state&&de(this,e)}[D](e){const r=this._abortAlgorithm(e);return ie(this),r}[N](){I(this)}}function ae(e,r,t,o,n,a,i,s){r._controlledWritableStream=e,e._writableStreamController=r,r._queue=void 0,r._queueTotalSize=void 0,I(r),r._started=!1,r._strategySizeAlgorithm=s,r._strategyHWM=i,r._writeAlgorithm=o,r._closeAlgorithm=n,r._abortAlgorithm=a;const l=ue(r);X(e,l);const c=t();Promise.resolve(c).then(()=>{r._started=!0,le(r)},t=>{r._started=!0,Q(e,t)}).catch(B)}function ie(e){e._writeAlgorithm=void 0,e._closeAlgorithm=void 0,e._abortAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function se(e){return e._strategyHWM-e._queueTotalSize}function le(e){const r=e._controlledWritableStream;if(!1===e._started)return;if(void 0!==r._inFlightWriteRequest)return;const t=r._state;if("closed"===t||"errored"===t)return;if("erroring"===t)return void x(r);if(0===e._queue.length)return;const o=F(e);"close"===o?function(e){const r=e._controlledWritableStream;(function(e){e._inFlightCloseRequest=e._closeRequest,e._closeRequest=void 0})(r),z(e);const t=e._closeAlgorithm();ie(e),t.then(()=>{G(r)},e=>{!function(e,r){e._inFlightCloseRequest._reject(r),e._inFlightCloseRequest=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._reject(r),e._pendingAbortRequest=void 0),Q(e,r)}(r,e)}).catch(B)}(e):function(e,r){const t=e._controlledWritableStream;(function(e){e._inFlightWriteRequest=e._writeRequests.shift()})(t),e._writeAlgorithm(r).then(()=>{!function(e){e._inFlightWriteRequest._resolve(void 0),e._inFlightWriteRequest=void 0}(t);const r=t._state;if(z(e),!1===J(t)&&"writable"===r){const r=ue(e);X(t,r)}le(e)},r=>{"writable"===t._state&&ie(e),function(e,r){e._inFlightWriteRequest._reject(r),e._inFlightWriteRequest=void 0,Q(e,r)}(t,r)}).catch(B)}(e,o.chunk)}function ce(e,r){"writable"===e._controlledWritableStream._state&&de(e,r)}function ue(e){return se(e)<=0}function de(e,r){const t=e._controlledWritableStream;ie(e),U(t,r)}function fe(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function me(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function he(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function _e(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t,e._closedPromiseState="pending"})}function be(e,r){e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}function ye(e,r){e._readyPromise=Promise.reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}function pe(e){e._readyPromise=Promise.resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}function we(e){e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}var Se=L.WritableStream;const{ArrayBufferCopy:ge,CreateAlgorithmFromUnderlyingMethod:ve,IsFiniteNonNegativeNumber:Pe,InvokeOrNoop:Re,IsDetachedBuffer:Te,TransferArrayBuffer:Ce,ValidateAndNormalizeHighWaterMark:qe,IsNonNegativeNumber:je,MakeSizeAlgorithmFromSizeFunction:Ae,createArrayFromList:Ee,typeIsObject:We,WaitForAllPromise:Oe}=P,{rethrowAssertionErrorRejection:Be}=v,{DequeueValue:ze,EnqueueValueWithSize:ke,ResetQueue:Fe}=T,{AcquireWritableStreamDefaultWriter:Ie,IsWritableStream:De,IsWritableStreamLocked:Ne,WritableStreamAbort:Le,WritableStreamDefaultWriterCloseWithErrorPropagation:Me,WritableStreamDefaultWriterRelease:Ve,WritableStreamDefaultWriterWrite:Ye,WritableStreamCloseQueuedOrInFlight:$e}=L,He=r("[[CancelSteps]]"),Qe=r("[[PullSteps]]");class ReadableStream{constructor(e={},r={}){Je(this);const o=r.size;let n=r.highWaterMark;const a=e.type;if("bytes"===String(a)){if(void 0!==o)throw new RangeError("The strategy for a byte stream cannot have a size function");void 0===n&&(n=0),function(e,r,o){const n=Object.create(ReadableByteStreamController.prototype);const a=ve(r,"pull",0,[n]),i=ve(r,"cancel",1,[]);let s=r.autoAllocateChunkSize;if(void 0!==s&&(s=Number(s),!1===t(s)||s<=0))throw new RangeError("autoAllocateChunkSize must be a positive integer");$r(e,n,function(){return Re(r,"start",[n])},a,i,o,s)}(this,e,n=qe(n))}else{if(void 0!==a)throw new RangeError("Invalid type is specified");{const r=Ae(o);void 0===n&&(n=1),function(e,r,t,o){const n=Object.create(ReadableStreamDefaultController.prototype);const a=ve(r,"pull",0,[n]),i=ve(r,"cancel",1,[]);Cr(e,n,function(){return Re(r,"start",[n])},a,i,t,o)}(this,e,n=qe(n),r)}}}get locked(){if(!1===Ke(this))throw Qr("locked");return Xe(this)}cancel(e){return!1===Ke(this)?Promise.reject(Qr("cancel")):!0===Xe(this)?Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")):tr(this,e)}getReader({mode:e}={}){if(!1===Ke(this))throw Qr("getReader");if(void 0===e)return xe(this);if("byob"===(e=String(e)))return function(e){return new ReadableStreamBYOBReader(e)}(this);throw new RangeError("Invalid mode is specified")}pipeThrough({writable:e,readable:r},{preventClose:t,preventAbort:o,preventCancel:n,signal:a}={}){if(!1===Ke(this))throw Qr("pipeThrough");if(!1===De(e))throw new TypeError("writable argument to pipeThrough must be a WritableStream");if(!1===Ke(r))throw new TypeError("readable argument to pipeThrough must be a ReadableStream");if(t=Boolean(t),o=Boolean(o),n=Boolean(n),void 0!==a&&!Hr(a))throw new TypeError("ReadableStream.prototype.pipeThrough's signal option must be an AbortSignal");if(!0===Xe(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(!0===Ne(e))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return Ze(this,e,t,o,n,a).catch(()=>{}),r}pipeTo(e,{preventClose:r,preventAbort:t,preventCancel:o,signal:n}={}){return!1===Ke(this)?Promise.reject(Qr("pipeTo")):!1===De(e)?Promise.reject(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream")):(r=Boolean(r),t=Boolean(t),o=Boolean(o),void 0===n||Hr(n)?!0===Xe(this)?Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):!0===Ne(e)?Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):Ze(this,e,r,t,o,n):Promise.reject(new TypeError("ReadableStream.prototype.pipeTo's signal option must be an AbortSignal")))}tee(){if(!1===Ke(this))throw Qr("tee");const e=function(e,r){const t=xe(e);let o,n,a,i,s,l=!1,c=!1,u=!1;const d=new Promise(e=>{s=e});function f(){return br(t).then(e=>{const r=e.value,t=e.done;if(!0===t&&!1===l&&(!1===c&&gr(a._readableStreamController),!1===u&&gr(i._readableStreamController),l=!0),!0===l)return;const o=r,n=r;!1===c&&vr(a._readableStreamController,o),!1===u&&vr(i._readableStreamController,n)})}function m(){}return a=Ge(m,f,function(r){if(c=!0,o=r,!0===u){const r=Ee([o,n]),t=tr(e,r);s(t)}return d}),i=Ge(m,f,function(r){if(u=!0,n=r,!0===c){const r=Ee([o,n]),t=tr(e,r);s(t)}return d}),t._closedPromise.catch(e=>{!0!==l&&(Pr(a._readableStreamController,e),Pr(i._readableStreamController,e),l=!0)}),[a,i]}(this);return Ee(e)}}var Ue={CreateReadableByteStream:function(e,r,t,o=0,n){const a=Object.create(ReadableStream.prototype);Je(a);const i=Object.create(ReadableByteStreamController.prototype);return $r(a,i,e,r,t,o,n),a},CreateReadableStream:Ge,ReadableStream:ReadableStream,IsReadableStreamDisturbed:function(e){return e._disturbed},ReadableStreamDefaultControllerClose:gr,ReadableStreamDefaultControllerEnqueue:vr,ReadableStreamDefaultControllerError:Pr,ReadableStreamDefaultControllerGetDesiredSize:Rr,ReadableStreamDefaultControllerHasBackpressure:function(e){if(!0===wr(e))return!1;return!0},ReadableStreamDefaultControllerCanCloseOrEnqueue:Tr};function xe(e){return new ReadableStreamDefaultReader(e)}function Ge(e,r,t,o=1,n=(()=>1)){const a=Object.create(ReadableStream.prototype);return Je(a),Cr(a,Object.create(ReadableStreamDefaultController.prototype),e,r,t,o,n),a}function Je(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=!1}function Ke(e){return!!We(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")}function Xe(e){return void 0!==e._reader}function Ze(e,r,t,o,n,a){const i=xe(e),s=Ie(r);let l=!1,c=Promise.resolve();return new Promise((u,d)=>{let f;if(void 0!==a){if(f=(()=>{const t=new DOMException("Aborted","AbortError"),a=[];!1===o&&a.push(()=>"writable"===r._state?Le(r,t):Promise.resolve()),!1===n&&a.push(()=>"readable"===e._state?tr(e,t):Promise.resolve()),_(()=>Oe(a.map(e=>e()),e=>e),!0,t)}),!0===a.aborted)return void f();a.addEventListener("abort",f)}if(h(e,i._closedPromise,e=>{!1===o?_(()=>Le(r,e),!0,e):b(!0,e)}),h(r,s._closedPromise,r=>{!1===n?_(()=>tr(e,r),!0,r):b(!0,r)}),function(e,r,t){"closed"===e._state?t():r.then(t).catch(Be)}(e,i._closedPromise,()=>{!1===t?_(()=>Me(s)):b()}),!0===$e(r)||"closed"===r._state){const r=new TypeError("the destination writable stream closed before all data could be piped to it");!1===n?_(()=>tr(e,r),!0,r):b(!0,r)}function m(){const e=c;return c.then(()=>e!==c?m():void 0)}function h(e,r,t){"errored"===e._state?t(e._storedError):r.catch(t).catch(Be)}function _(e,t,o){function n(){e().then(()=>y(t,o),e=>y(!0,e)).catch(Be)}!0!==l&&(l=!0,"writable"===r._state&&!1===$e(r)?m().then(n):n())}function b(e,t){!0!==l&&(l=!0,"writable"===r._state&&!1===$e(r)?m().then(()=>y(e,t)).catch(Be):y(e,t))}function y(e,r){Ve(s),_r(i),void 0!==a&&a.removeEventListener("abort",f),e?d(r):u(void 0)}new Promise((e,r)=>{!function t(o){o?e():(!0===l?Promise.resolve(!0):s._readyPromise.then(()=>br(i).then(({value:e,done:r})=>!0===r||(c=Ye(s,e).catch(()=>{}),!1)))).then(t,r)}(!1)}).catch(e=>{c=Promise.resolve(),Be(e)})})}function er(e,r){return new Promise((t,o)=>{const n={_resolve:t,_reject:o,_forAuthorCode:r};e._reader._readIntoRequests.push(n)})}function rr(e,r){return new Promise((t,o)=>{const n={_resolve:t,_reject:o,_forAuthorCode:r};e._reader._readRequests.push(n)})}function tr(e,r){if(e._disturbed=!0,"closed"===e._state)return Promise.resolve(void 0);if("errored"===e._state)return Promise.reject(e._storedError);return or(e),e._readableStreamController[He](r).then(()=>void 0)}function or(e){e._state="closed";const r=e._reader;if(void 0!==r){if(!0===fr(r)){for(const{_resolve:e,_forAuthorCode:t}of r._readRequests)e(nr(void 0,!0,t));r._readRequests=[]}!function(e){e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}(r)}}function nr(e,r,t){let o=null;!0===t&&(o=Object.prototype);const n=Object.create(o);return Object.defineProperty(n,"value",{value:e,enumerable:!0,writable:!0,configurable:!0}),Object.defineProperty(n,"done",{value:r,enumerable:!0,writable:!0,configurable:!0}),n}function ar(e,r){e._state="errored",e._storedError=r;const t=e._reader;if(void 0!==t){if(!0===fr(t)){for(const e of t._readRequests)e._reject(r);t._readRequests=[]}else{for(const e of t._readIntoRequests)e._reject(r);t._readIntoRequests=[]}Gr(t,r),t._closedPromise.catch(()=>{})}}function ir(e,r,t){const o=e._reader._readRequests.shift();o._resolve(nr(r,t,o._forAuthorCode))}function sr(e){return e._reader._readIntoRequests.length}function lr(e){return e._reader._readRequests.length}function cr(e){const r=e._reader;return void 0!==r&&!1!==dr(r)}function ur(e){const r=e._reader;return void 0!==r&&!1!==fr(r)}class ReadableStreamDefaultReader{constructor(e){if(!1===Ke(e))throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");if(!0===Xe(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");mr(this,e),this._readRequests=[]}get closed(){return!1===fr(this)?Promise.reject(xr("closed")):this._closedPromise}cancel(e){return!1===fr(this)?Promise.reject(xr("cancel")):void 0===this._ownerReadableStream?Promise.reject(Ur("cancel")):hr(this,e)}read(){return!1===fr(this)?Promise.reject(xr("read")):void 0===this._ownerReadableStream?Promise.reject(Ur("read from")):br(this,!0)}releaseLock(){if(!1===fr(this))throw xr("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");_r(this)}}}class ReadableStreamBYOBReader{constructor(e){if(!Ke(e))throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");if(!1===qr(e._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");if(Xe(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");mr(this,e),this._readIntoRequests=[]}get closed(){return dr(this)?this._closedPromise:Promise.reject(Jr("closed"))}cancel(e){return dr(this)?void 0===this._ownerReadableStream?Promise.reject(Ur("cancel")):hr(this,e):Promise.reject(Jr("cancel"))}read(e){return dr(this)?void 0===this._ownerReadableStream?Promise.reject(Ur("read from")):ArrayBuffer.isView(e)?!0===Te(e.buffer)?Promise.reject(new TypeError("Cannot read into a view onto a detached ArrayBuffer")):0===e.byteLength?Promise.reject(new TypeError("view must have non-zero byteLength")):function(e,r,t=!1){const o=e._ownerReadableStream;if(o._disturbed=!0,"errored"===o._state)return Promise.reject(o._storedError);return function(e,r,t){const o=e._controlledReadableByteStream;let n=1;r.constructor!==DataView&&(n=r.constructor.BYTES_PER_ELEMENT);const a=r.constructor,i={buffer:Ce(r.buffer),byteOffset:r.byteOffset,byteLength:r.byteLength,bytesFilled:0,elementSize:n,ctor:a,readerType:"byob"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(i),er(o,t);if("closed"===o._state){const e=new r.constructor(i.buffer,i.byteOffset,0);return Promise.resolve(nr(e,!0,t))}if(e._queueTotalSize>0){if(!0===zr(e,i)){const r=Or(i);return Fr(e),Promise.resolve(nr(r,!1,t))}if(!0===e._closeRequested){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");return Vr(e,r),Promise.reject(r)}}e._pendingPullIntos.push(i);const s=er(o,t);return Ar(e),s}(o._readableStreamController,r,t)}(this,e,!0):Promise.reject(new TypeError("view must be an array buffer view")):Promise.reject(Jr("read"))}releaseLock(){if(!dr(this))throw Jr("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");_r(this)}}}function dr(e){return!!We(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")}function fr(e){return!!We(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readRequests")}function mr(e,r){e._ownerReadableStream=r,r._reader=e,"readable"===r._state?function(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t})}(e):"closed"===r._state?function(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}(e):(!function(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}(e,r._storedError),e._closedPromise.catch(()=>{}))}function hr(e,r){return tr(e._ownerReadableStream,r)}function _r(e){"readable"===e._ownerReadableStream._state?Gr(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function(e,r){e._closedPromise=Promise.reject(r)}(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._closedPromise.catch(()=>{}),e._ownerReadableStream._reader=void 0,e._ownerReadableStream=void 0}function br(e,r=!1){const t=e._ownerReadableStream;return t._disturbed=!0,"closed"===t._state?Promise.resolve(nr(void 0,!0,r)):"errored"===t._state?Promise.reject(t._storedError):t._readableStreamController[Qe](r)}class ReadableStreamDefaultController{constructor(){throw new TypeError}get desiredSize(){if(!1===yr(this))throw Kr("desiredSize");return Rr(this)}close(){if(!1===yr(this))throw Kr("close");if(!1===Tr(this))throw new TypeError("The stream is not in a state that permits close");gr(this)}enqueue(e){if(!1===yr(this))throw Kr("enqueue");if(!1===Tr(this))throw new TypeError("The stream is not in a state that permits enqueue");return vr(this,e)}error(e){if(!1===yr(this))throw Kr("error");Pr(this,e)}[He](e){Fe(this);const r=this._cancelAlgorithm(e);return Sr(this),r}[Qe](e){const r=this._controlledReadableStream;if(this._queue.length>0){const t=ze(this);return!0===this._closeRequested&&0===this._queue.length?(Sr(this),or(r)):pr(this),Promise.resolve(nr(t,!1,e))}const t=rr(r,e);return pr(this),t}}function yr(e){return!!We(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")}function pr(e){!1!==wr(e)&&(!0!==e._pulling?(e._pulling=!0,e._pullAlgorithm().then(()=>{if(e._pulling=!1,!0===e._pullAgain)return e._pullAgain=!1,pr(e)},r=>{Pr(e,r)}).catch(Be)):e._pullAgain=!0)}function wr(e){const r=e._controlledReadableStream;return!1!==Tr(e)&&(!1!==e._started&&(!0===Xe(r)&&lr(r)>0||Rr(e)>0))}function Sr(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function gr(e){const r=e._controlledReadableStream;e._closeRequested=!0,0===e._queue.length&&(Sr(e),or(r))}function vr(e,r){const t=e._controlledReadableStream;if(!0===Xe(t)&&lr(t)>0)ir(t,r,!1);else{let t;try{t=e._strategySizeAlgorithm(r)}catch(r){throw Pr(e,r),r}try{ke(e,r,t)}catch(r){throw Pr(e,r),r}}pr(e)}function Pr(e,r){const t=e._controlledReadableStream;"readable"===t._state&&(Fe(e),Sr(e),ar(t,r))}function Rr(e){const r=e._controlledReadableStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function Tr(e){const r=e._controlledReadableStream._state;return!1===e._closeRequested&&"readable"===r}function Cr(e,r,t,o,n,a,i){r._controlledReadableStream=e,r._queue=void 0,r._queueTotalSize=void 0,Fe(r),r._started=!1,r._closeRequested=!1,r._pullAgain=!1,r._pulling=!1,r._strategySizeAlgorithm=i,r._strategyHWM=a,r._pullAlgorithm=o,r._cancelAlgorithm=n,e._readableStreamController=r;const s=t();Promise.resolve(s).then(()=>{r._started=!0,pr(r)},e=>{Pr(r,e)}).catch(Be)}class ReadableStreamBYOBRequest{constructor(){throw new TypeError("ReadableStreamBYOBRequest cannot be used directly")}get view(){if(!1===jr(this))throw Xr("view");return this._view}respond(e){if(!1===jr(this))throw Xr("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!0===Te(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");!function(e,r){if(r=Number(r),!1===Pe(r))throw new RangeError("bytesWritten must be a finite");Nr(e,r)}(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!1===jr(this))throw Xr("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!ArrayBuffer.isView(e))throw new TypeError("You can only respond with array buffer views");if(!0===Te(e.buffer))throw new TypeError("The supplied view's buffer has been detached and so cannot be used as a response");!function(e,r){const t=e._pendingPullIntos[0];if(t.byteOffset+t.bytesFilled!==r.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(t.byteLength!==r.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");t.buffer=r.buffer,Nr(e,r.byteLength)}(this._associatedReadableByteStreamController,e)}}class ReadableByteStreamController{constructor(){throw new TypeError("ReadableByteStreamController constructor cannot be used directly")}get byobRequest(){if(!1===qr(this))throw Zr("byobRequest");if(void 0===this._byobRequest&&this._pendingPullIntos.length>0){const e=this._pendingPullIntos[0],r=new Uint8Array(e.buffer,e.byteOffset+e.bytesFilled,e.byteLength-e.bytesFilled),t=Object.create(ReadableStreamBYOBRequest.prototype);!function(e,r,t){e._associatedReadableByteStreamController=r,e._view=t}(t,this,r),this._byobRequest=t}return this._byobRequest}get desiredSize(){if(!1===qr(this))throw Zr("desiredSize");return Yr(this)}close(){if(!1===qr(this))throw Zr("close");if(!0===this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const e=this._controlledReadableByteStream._state;if("readable"!==e)throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);!function(e){const r=e._controlledReadableByteStream;if(e._queueTotalSize>0)return void(e._closeRequested=!0);if(e._pendingPullIntos.length>0){const r=e._pendingPullIntos[0];if(r.bytesFilled>0){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");throw Vr(e,r),r}}Mr(e),or(r)}(this)}enqueue(e){if(!1===qr(this))throw Zr("enqueue");if(!0===this._closeRequested)throw new TypeError("stream is closed or draining");const r=this._controlledReadableByteStream._state;if("readable"!==r)throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);if(!ArrayBuffer.isView(e))throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");if(!0===Te(e.buffer))throw new TypeError("Cannot enqueue a view onto a detached ArrayBuffer");!function(e,r){const t=e._controlledReadableByteStream,o=r.buffer,n=r.byteOffset,a=r.byteLength,i=Ce(o);if(!0===ur(t))if(0===lr(t))Br(e,i,n,a);else{const e=new Uint8Array(i,n,a);ir(t,e,!1)}else!0===cr(t)?(Br(e,i,n,a),Dr(e)):Br(e,i,n,a);Ar(e)}(this,e)}error(e){if(!1===qr(this))throw Zr("error");Vr(this,e)}[He](e){if(this._pendingPullIntos.length>0){this._pendingPullIntos[0].bytesFilled=0}Fe(this);const r=this._cancelAlgorithm(e);return Mr(this),r}[Qe](e){const r=this._controlledReadableByteStream;if(this._queueTotalSize>0){const r=this._queue.shift();let t;this._queueTotalSize-=r.byteLength,Fr(this);try{t=new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}catch(e){return Promise.reject(e)}return Promise.resolve(nr(t,!1,e))}const t=this._autoAllocateChunkSize;if(void 0!==t){let e;try{e=new ArrayBuffer(t)}catch(e){return Promise.reject(e)}const r={buffer:e,byteOffset:0,byteLength:t,bytesFilled:0,elementSize:1,ctor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(r)}const o=rr(r,e);return Ar(this),o}}function qr(e){return!!We(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")}function jr(e){return!!We(e)&&!!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")}function Ar(e){!1!==function(e){const r=e._controlledReadableByteStream;if("readable"!==r._state)return!1;if(!0===e._closeRequested)return!1;if(!1===e._started)return!1;if(!0===ur(r)&&lr(r)>0)return!0;if(!0===cr(r)&&sr(r)>0)return!0;if(Yr(e)>0)return!0;return!1}(e)&&(!0!==e._pulling?(e._pulling=!0,e._pullAlgorithm().then(()=>{e._pulling=!1,!0===e._pullAgain&&(e._pullAgain=!1,Ar(e))},r=>{Vr(e,r)}).catch(Be)):e._pullAgain=!0)}function Er(e){Ir(e),e._pendingPullIntos=[]}function Wr(e,r){let t=!1;"closed"===e._state&&(t=!0);const o=Or(r);"default"===r.readerType?ir(e,o,t):function(e,r,t){const o=e._reader._readIntoRequests.shift();o._resolve(nr(r,t,o._forAuthorCode))}(e,o,t)}function Or(e){const r=e.bytesFilled,t=e.elementSize;return new e.ctor(e.buffer,e.byteOffset,r/t)}function Br(e,r,t,o){e._queue.push({buffer:r,byteOffset:t,byteLength:o}),e._queueTotalSize+=o}function zr(e,r){const t=r.elementSize,o=r.bytesFilled-r.bytesFilled%t,n=Math.min(e._queueTotalSize,r.byteLength-r.bytesFilled),a=r.bytesFilled+n,i=a-a%t;let s=n,l=!1;i>o&&(s=i-r.bytesFilled,l=!0);const c=e._queue;for(;s>0;){const t=c[0],o=Math.min(s,t.byteLength),n=r.byteOffset+r.bytesFilled;ge(r.buffer,n,t.buffer,t.byteOffset,o),t.byteLength===o?c.shift():(t.byteOffset+=o,t.byteLength-=o),e._queueTotalSize-=o,kr(e,o,r),s-=o}return l}function kr(e,r,t){Ir(e),t.bytesFilled+=r}function Fr(e){0===e._queueTotalSize&&!0===e._closeRequested?(Mr(e),or(e._controlledReadableByteStream)):Ar(e)}function Ir(e){void 0!==e._byobRequest&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=void 0,e._byobRequest=void 0)}function Dr(e){for(;e._pendingPullIntos.length>0;){if(0===e._queueTotalSize)return;const r=e._pendingPullIntos[0];!0===zr(e,r)&&(Lr(e),Wr(e._controlledReadableByteStream,r))}}function Nr(e,r){const t=e._pendingPullIntos[0];if("closed"===e._controlledReadableByteStream._state){if(0!==r)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");!function(e,r){r.buffer=Ce(r.buffer);const t=e._controlledReadableByteStream;if(!0===cr(t))for(;sr(t)>0;)Wr(t,Lr(e))}(e,t)}else!function(e,r,t){if(t.bytesFilled+r>t.byteLength)throw new RangeError("bytesWritten out of range");if(kr(e,r,t),t.bytesFilled<t.elementSize)return;Lr(e);const o=t.bytesFilled%t.elementSize;if(o>0){const r=t.byteOffset+t.bytesFilled,n=t.buffer.slice(r-o,r);Br(e,n,0,n.byteLength)}t.buffer=Ce(t.buffer),t.bytesFilled-=o,Wr(e._controlledReadableByteStream,t),Dr(e)}(e,r,t);Ar(e)}function Lr(e){const r=e._pendingPullIntos.shift();return Ir(e),r}function Mr(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0}function Vr(e,r){const t=e._controlledReadableByteStream;"readable"===t._state&&(Er(e),Fe(e),Mr(e),ar(t,r))}function Yr(e){const r=e._controlledReadableByteStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function $r(e,r,t,o,n,a,i){r._controlledReadableByteStream=e,r._pullAgain=!1,r._pulling=!1,Er(r),r._queue=r._queueTotalSize=void 0,Fe(r),r._closeRequested=!1,r._started=!1,r._strategyHWM=qe(a),r._pullAlgorithm=o,r._cancelAlgorithm=n,r._autoAllocateChunkSize=i,r._pendingPullIntos=[],e._readableStreamController=r;const s=t();Promise.resolve(s).then(()=>{r._started=!0,Ar(r)},e=>{Vr(r,e)}).catch(Be)}function Hr(e){if("object"!=typeof e||null===e)return!1;const r=Object.getOwnPropertyDescriptor(AbortSignal.prototype,"aborted").get;try{return r.call(e),!0}catch(e){return!1}}function Qr(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function Ur(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function xr(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}function Gr(e,r){e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function Jr(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function Kr(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function Xr(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function Zr(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}var et=Ue.ReadableStream;const{createDataProperty:rt}=P;var tt=class ByteLengthQueuingStrategy{constructor({highWaterMark:e}){rt(this,"highWaterMark",e)}size(e){return e.byteLength}};const{createDataProperty:ot}=P;var nt=class CountQueuingStrategy{constructor({highWaterMark:e}){ot(this,"highWaterMark",e)}size(){return 1}};C("streams:transform-stream:verbose");const{InvokeOrNoop:at,CreateAlgorithmFromUnderlyingMethod:it,PromiseCall:st,typeIsObject:lt,ValidateAndNormalizeHighWaterMark:ct,IsNonNegativeNumber:ut,MakeSizeAlgorithmFromSizeFunction:dt}=P,{CreateReadableStream:ft,ReadableStreamDefaultControllerClose:mt,ReadableStreamDefaultControllerEnqueue:ht,ReadableStreamDefaultControllerError:_t,ReadableStreamDefaultControllerGetDesiredSize:bt,ReadableStreamDefaultControllerHasBackpressure:yt,ReadableStreamDefaultControllerCanCloseOrEnqueue:pt}=Ue,{CreateWritableStream:wt,WritableStreamDefaultControllerErrorIfNeeded:St}=L;class TransformStream{constructor(e={},r={},t={}){const o=r.size;let n=r.highWaterMark;const a=t.size;let i=t.highWaterMark;if(void 0!==e.writableType)throw new RangeError("Invalid writable type specified");const s=dt(o);if(void 0===n&&(n=1),n=ct(n),void 0!==e.readableType)throw new RangeError("Invalid readable type specified");const l=dt(a);let c;void 0===i&&(i=0),i=ct(i),gt(this,new Promise(e=>{c=e}),n,s,i,l),function(e,r){const t=Object.create(TransformStreamDefaultController.prototype);let o=e=>{try{return At(t,e),Promise.resolve()}catch(e){return Promise.reject(e)}};const n=r.transform;if(void 0!==n){if("function"!=typeof n)throw new TypeError("transform is not a method");o=(e=>st(n,r,[e,t]))}const a=it(r,"flush",0,[t]);qt(e,t,o,a)}(this,e);const u=at(e,"start",[this._transformStreamController]);c(u)}get readable(){if(!1===vt(this))throw Ot("readable");return this._readable}get writable(){if(!1===vt(this))throw Ot("writable");return this._writable}}function gt(e,r,t,o,n,a){function i(){return r}e._writable=wt(i,function(r){return function(e,r){const t=e._transformStreamController;if(!0===e._backpressure){const o=e._backpressureChangePromise;return o.then(()=>{const o=e._writable,n=o._state;if("erroring"===n)throw o._storedError;return Et(t,r)})}return Et(t,r)}(e,r)},function(){return function(e){const r=e._readable,t=e._transformStreamController,o=t._flushAlgorithm();return jt(t),o.then(()=>{if("errored"===r._state)throw r._storedError;const e=r._readableStreamController;!0===pt(e)&&mt(e)}).catch(t=>{throw Pt(e,t),r._storedError})}(e)},function(r){return function(e,r){return Pt(e,r),Promise.resolve()}(e,r)},t,o),e._readable=ft(i,function(){return function(e){return Tt(e,!1),e._backpressureChangePromise}(e)},function(r){return Rt(e,r),Promise.resolve()},n,a),e._backpressure=void 0,e._backpressureChangePromise=void 0,e._backpressureChangePromise_resolve=void 0,Tt(e,!0),e._transformStreamController=void 0}function vt(e){return!!lt(e)&&!!Object.prototype.hasOwnProperty.call(e,"_transformStreamController")}function Pt(e,r){_t(e._readable._readableStreamController,r),Rt(e,r)}function Rt(e,r){jt(e._transformStreamController),St(e._writable._writableStreamController,r),!0===e._backpressure&&Tt(e,!1)}function Tt(e,r){void 0!==e._backpressureChangePromise&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=new Promise(r=>{e._backpressureChangePromise_resolve=r}),e._backpressure=r}class TransformStreamDefaultController{constructor(){throw new TypeError("TransformStreamDefaultController instances cannot be created directly")}get desiredSize(){if(!1===Ct(this))throw Wt("desiredSize");const e=this._controlledTransformStream._readable._readableStreamController;return bt(e)}enqueue(e){if(!1===Ct(this))throw Wt("enqueue");At(this,e)}error(e){if(!1===Ct(this))throw Wt("error");!function(e,r){Pt(e._controlledTransformStream,r)}(this,e)}terminate(){if(!1===Ct(this))throw Wt("terminate");!function(e){const r=e._controlledTransformStream,t=r._readable._readableStreamController;!0===pt(t)&&mt(t);const o=new TypeError("TransformStream terminated");Rt(r,o)}(this)}}function Ct(e){return!!lt(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream")}function qt(e,r,t,o){r._controlledTransformStream=e,e._transformStreamController=r,r._transformAlgorithm=t,r._flushAlgorithm=o}function jt(e){e._transformAlgorithm=void 0,e._flushAlgorithm=void 0}function At(e,r){const t=e._controlledTransformStream,o=t._readable._readableStreamController;if(!1===pt(o))throw new TypeError("Readable side is not in a state that permits enqueue");try{ht(o,r)}catch(e){throw Rt(t,e),t._readable._storedError}yt(o)!==t._backpressure&&Tt(t,!0)}function Et(e,r){return e._transformAlgorithm(r).catch(r=>{throw Pt(e._controlledTransformStream,r),r})}function Wt(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function Ot(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}var Bt={CreateTransformStream:function(e,r,t,o=1,n=(()=>1),a=0,i=(()=>1)){const s=Object.create(TransformStream.prototype);let l;gt(s,new Promise(e=>{l=e}),o,n,a,i),qt(s,Object.create(TransformStreamDefaultController.prototype),r,t);const c=e();return l(c),s},TransformStream:TransformStream}.TransformStream;const zt={ReadableStream:et,WritableStream:Se,ByteLengthQueuingStrategy:tt,CountQueuingStrategy:nt,TransformStream:Bt};void 0!==n&&Object.assign(n,zt),e.ReadableStream=et,e.WritableStream=Se,e.ByteLengthQueuingStrategy=tt,e.CountQueuingStrategy=nt,e.TransformStream=Bt,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=polyfill.es6.min.js.map
