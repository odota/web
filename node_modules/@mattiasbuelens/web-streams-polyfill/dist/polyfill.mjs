function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol : function (description) {
  return "Symbol(" + description + ")";
};

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill
var NumberIsInteger = Number.isInteger || function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};

function noop() {// do nothing
}

function getGlobals() {
  /* global self, window, global */
  if (typeof self !== 'undefined') {
    return self;
  } else if (typeof window !== 'undefined') {
    return window;
  } else if (typeof global !== 'undefined') {
    return global;
  }

  return undefined;
}

var globals = getGlobals();



var betterAssert = ({
  default: noop
});

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill
var NumberIsNaN = Number.isNaN || function (x) {
  // eslint-disable-next-line no-self-compare
  return x !== x;
};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n.default || n;
}

getCjsExportFromNamespace(betterAssert);

var helpers = createCommonjsModule(function (module, exports) {

  var isFakeDetached = SymbolPolyfill('is "detached" for our purposes');

  exports.typeIsObject = function (x) {
    return typeof x === 'object' && x !== null || typeof x === 'function';
  };

  exports.createDataProperty = function (o, p, v) {
    Object.defineProperty(o, p, {
      value: v,
      writable: true,
      enumerable: true,
      configurable: true
    });
  };

  exports.createArrayFromList = function (elements) {
    // We use arrays to represent lists, so this is basically a no-op.
    // Do a slice though just in case we happen to depend on the unique-ness.
    return elements.slice();
  };

  exports.ArrayBufferCopy = function (dest, destOffset, src, srcOffset, n) {
    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
  };

  exports.IsFiniteNonNegativeNumber = function (v) {
    if (exports.IsNonNegativeNumber(v) === false) {
      return false;
    }

    if (v === Infinity) {
      return false;
    }

    return true;
  };

  exports.IsNonNegativeNumber = function (v) {
    if (typeof v !== 'number') {
      return false;
    }

    if (NumberIsNaN(v)) {
      return false;
    }

    if (v < 0) {
      return false;
    }

    return true;
  };

  function Call(F, V, args) {
    if (typeof F !== 'function') {
      throw new TypeError('Argument is not a function');
    }

    return Function.prototype.apply.call(F, V, args);
  }

  exports.Call = Call;

  exports.CreateAlgorithmFromUnderlyingMethod = function (underlyingObject, methodName, algoArgCount, extraArgs) {
    var method = underlyingObject[methodName];

    if (method !== undefined) {
      if (typeof method !== 'function') {
        throw new TypeError(method + " is not a method");
      }

      switch (algoArgCount) {
        case 0:
          {
            return function () {
              return PromiseCall(method, underlyingObject, extraArgs);
            };
          }

        case 1:
          {
            return function (arg) {
              var fullArgs = [arg].concat(extraArgs);
              return PromiseCall(method, underlyingObject, fullArgs);
            };
          }
      }
    }

    return function () {
      return Promise.resolve();
    };
  };

  exports.InvokeOrNoop = function (O, P, args) {
    var method = O[P];

    if (method === undefined) {
      return undefined;
    }

    return Call(method, O, args);
  };

  function PromiseCall(F, V, args) {
    try {
      return Promise.resolve(Call(F, V, args));
    } catch (value) {
      return Promise.reject(value);
    }
  }

  exports.PromiseCall = PromiseCall; // Not implemented correctly

  exports.TransferArrayBuffer = function (O) {
    var transferredIshVersion = O.slice(); // This is specifically to fool tests that test "is transferred" by taking a non-zero-length
    // ArrayBuffer and checking if its byteLength starts returning 0.

    Object.defineProperty(O, 'byteLength', {
      get: function get() {
        return 0;
      }
    });
    O[isFakeDetached] = true;
    return transferredIshVersion;
  }; // Not implemented correctly


  exports.IsDetachedBuffer = function (O) {
    return isFakeDetached in O;
  };

  exports.ValidateAndNormalizeHighWaterMark = function (highWaterMark) {
    highWaterMark = Number(highWaterMark);

    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
      throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');
    }

    return highWaterMark;
  };

  exports.MakeSizeAlgorithmFromSizeFunction = function (size) {
    if (size === undefined) {
      return function () {
        return 1;
      };
    }

    if (typeof size !== 'function') {
      throw new TypeError('size property of a queuing strategy must be a function');
    }

    return function (chunk) {
      return size(chunk);
    };
  };

  exports.PerformPromiseThen = function (promise, onFulfilled, onRejected) {
    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an
    // approximation.
    return Promise.prototype.then.call(promise, onFulfilled, onRejected);
  };

  exports.WaitForAll = function (promises, successSteps, failureSteps) {
    var rejected = false;

    var rejectionHandler = function rejectionHandler(arg) {
      if (rejected === false) {
        rejected = true;
        failureSteps(arg);
      }
    };

    var index = 0;
    var fulfilledCount = 0;
    var total = promises.length;
    var result = new Array(total);

    var _loop = function _loop(_i2) {
      var promise = promises[_i2];
      var promiseIndex = index;

      var fulfillmentHandler = function fulfillmentHandler(arg) {
        result[promiseIndex] = arg;
        ++fulfilledCount;

        if (fulfilledCount === total) {
          successSteps(result);
        }
      };

      exports.PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      ++index;
    };

    for (var _i2 = 0; _i2 < promises.length; _i2++) {
      _loop(_i2);
    }
  };

  exports.WaitForAllPromise = function (promises, successSteps, failureSteps) {
    if (failureSteps === void 0) {
      failureSteps = undefined;
    }

    var resolvePromise;
    var rejectPromise;
    var promise = new Promise(function (resolve, reject) {
      resolvePromise = resolve;
      rejectPromise = reject;
    });

    if (failureSteps === undefined) {
      failureSteps = function failureSteps(arg) {
        throw arg;
      };
    }

    var successStepsWrapper = function successStepsWrapper(results) {
      try {
        var stepsResult = successSteps(results);
        resolvePromise(stepsResult);
      } catch (e) {
        rejectPromise(e);
      }
    };

    var failureStepsWrapper = function failureStepsWrapper(reason) {
      try {
        var stepsResult = failureSteps(reason);
        resolvePromise(stepsResult);
      } catch (e) {
        rejectPromise(e);
      }
    };

    exports.WaitForAll(promises, successStepsWrapper, failureStepsWrapper);
    return promise;
  };
});
var helpers_1 = helpers.typeIsObject;
var helpers_2 = helpers.createDataProperty;
var helpers_3 = helpers.createArrayFromList;
var helpers_4 = helpers.ArrayBufferCopy;
var helpers_5 = helpers.IsFiniteNonNegativeNumber;
var helpers_6 = helpers.IsNonNegativeNumber;
var helpers_7 = helpers.Call;
var helpers_8 = helpers.CreateAlgorithmFromUnderlyingMethod;
var helpers_9 = helpers.InvokeOrNoop;
var helpers_10 = helpers.PromiseCall;
var helpers_11 = helpers.TransferArrayBuffer;
var helpers_12 = helpers.IsDetachedBuffer;
var helpers_13 = helpers.ValidateAndNormalizeHighWaterMark;
var helpers_14 = helpers.MakeSizeAlgorithmFromSizeFunction;
var helpers_15 = helpers.PerformPromiseThen;
var helpers_16 = helpers.WaitForAll;
var helpers_17 = helpers.WaitForAllPromise;

function TransferArrayBuffer(O) {
  return O;
} // Not implemented correctly

function IsDetachedBuffer(O) {
  // eslint-disable-line no-unused-vars
  return false;
}

var helpers$1 = ({
  TransferArrayBuffer: TransferArrayBuffer,
  IsDetachedBuffer: IsDetachedBuffer,
  typeIsObject: helpers_1,
  createDataProperty: helpers_2,
  createArrayFromList: helpers_3,
  ArrayBufferCopy: helpers_4,
  IsFiniteNonNegativeNumber: helpers_5,
  IsNonNegativeNumber: helpers_6,
  Call: helpers_7,
  CreateAlgorithmFromUnderlyingMethod: helpers_8,
  InvokeOrNoop: helpers_9,
  PromiseCall: helpers_10,
  ValidateAndNormalizeHighWaterMark: helpers_13,
  MakeSizeAlgorithmFromSizeFunction: helpers_14,
  PerformPromiseThen: helpers_15,
  WaitForAll: helpers_16,
  WaitForAllPromise: helpers_17
});

function assert() {// do nothing
}
assert.AssertionError = noop;

var assert$1 = ({
  default: assert
});

var assert$2 = getCjsExportFromNamespace(assert$1);

var rethrowAssertionErrorRejection = function rethrowAssertionErrorRejection(e) {
  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors
  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't
  // expect any errors, but assertion errors are always problematic.
  if (e && e instanceof assert$2.AssertionError) {
    setTimeout(function () {
      throw e;
    }, 0);
  }
};

var utils = {
  rethrowAssertionErrorRejection: rethrowAssertionErrorRejection
};

var require$$0 = getCjsExportFromNamespace(helpers$1);

var IsFiniteNonNegativeNumber = require$$0.IsFiniteNonNegativeNumber;

var DequeueValue = function DequeueValue(container) {
  var pair = container._queue.shift();

  container._queueTotalSize -= pair.size;

  if (container._queueTotalSize < 0) {
    container._queueTotalSize = 0;
  }

  return pair.value;
};

var EnqueueValueWithSize = function EnqueueValueWithSize(container, value, size) {
  size = Number(size);

  if (!IsFiniteNonNegativeNumber(size)) {
    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
  }

  container._queue.push({
    value: value,
    size: size
  });

  container._queueTotalSize += size;
};

var PeekQueueValue = function PeekQueueValue(container) {
  var pair = container._queue[0];
  return pair.value;
};

var ResetQueue = function ResetQueue(container) {
  container._queue = [];
  container._queueTotalSize = 0;
};

var queueWithSizes = {
  DequeueValue: DequeueValue,
  EnqueueValueWithSize: EnqueueValueWithSize,
  PeekQueueValue: PeekQueueValue,
  ResetQueue: ResetQueue
};



var debug = ({
  default: noop
});

var require$$0$1 = getCjsExportFromNamespace(debug);

// and do not appear in the standard text.


var verbose = require$$0$1('streams:writable-stream:verbose');
var CreateAlgorithmFromUnderlyingMethod = require$$0.CreateAlgorithmFromUnderlyingMethod,
    InvokeOrNoop = require$$0.InvokeOrNoop,
    ValidateAndNormalizeHighWaterMark = require$$0.ValidateAndNormalizeHighWaterMark,
    IsNonNegativeNumber = require$$0.IsNonNegativeNumber,
    MakeSizeAlgorithmFromSizeFunction = require$$0.MakeSizeAlgorithmFromSizeFunction,
    typeIsObject = require$$0.typeIsObject;
var rethrowAssertionErrorRejection$1 = utils.rethrowAssertionErrorRejection;
var DequeueValue$1 = queueWithSizes.DequeueValue,
    EnqueueValueWithSize$1 = queueWithSizes.EnqueueValueWithSize,
    PeekQueueValue$1 = queueWithSizes.PeekQueueValue,
    ResetQueue$1 = queueWithSizes.ResetQueue;
var AbortSteps = SymbolPolyfill('[[AbortSteps]]');
var ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');

var WritableStream =
/*#__PURE__*/
function () {
  function WritableStream(underlyingSink, strategy) {
    if (underlyingSink === void 0) {
      underlyingSink = {};
    }

    if (strategy === void 0) {
      strategy = {};
    }

    InitializeWritableStream(this);
    var size = strategy.size;
    var highWaterMark = strategy.highWaterMark;
    var type = underlyingSink.type;

    if (type !== undefined) {
      throw new RangeError('Invalid type is specified');
    }

    var sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);

    if (highWaterMark === undefined) {
      highWaterMark = 1;
    }

    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);
    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
  }

  var _proto = WritableStream.prototype;

  _proto.abort = function abort(reason) {
    if (IsWritableStream(this) === false) {
      return Promise.reject(streamBrandCheckException('abort'));
    }

    if (IsWritableStreamLocked(this) === true) {
      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));
    }

    return WritableStreamAbort(this, reason);
  };

  _proto.getWriter = function getWriter() {
    if (IsWritableStream(this) === false) {
      throw streamBrandCheckException('getWriter');
    }

    return AcquireWritableStreamDefaultWriter(this);
  };

  _createClass(WritableStream, [{
    key: "locked",
    get: function get() {
      if (IsWritableStream(this) === false) {
        throw streamBrandCheckException('locked');
      }

      return IsWritableStreamLocked(this);
    }
  }]);

  return WritableStream;
}();

var writableStream = {
  AcquireWritableStreamDefaultWriter: AcquireWritableStreamDefaultWriter,
  CreateWritableStream: CreateWritableStream,
  IsWritableStream: IsWritableStream,
  IsWritableStreamLocked: IsWritableStreamLocked,
  WritableStream: WritableStream,
  WritableStreamAbort: WritableStreamAbort,
  WritableStreamDefaultControllerErrorIfNeeded: WritableStreamDefaultControllerErrorIfNeeded,
  WritableStreamDefaultWriterCloseWithErrorPropagation: WritableStreamDefaultWriterCloseWithErrorPropagation,
  WritableStreamDefaultWriterRelease: WritableStreamDefaultWriterRelease,
  WritableStreamDefaultWriterWrite: WritableStreamDefaultWriterWrite,
  WritableStreamCloseQueuedOrInFlight: WritableStreamCloseQueuedOrInFlight
}; // Abstract operations for the WritableStream.

function AcquireWritableStreamDefaultWriter(stream) {
  return new WritableStreamDefaultWriter(stream);
} // Throws if and only if startAlgorithm throws.


function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
  if (highWaterMark === void 0) {
    highWaterMark = 1;
  }

  if (sizeAlgorithm === void 0) {
    sizeAlgorithm = function sizeAlgorithm() {
      return 1;
    };
  }

  var stream = Object.create(WritableStream.prototype);
  InitializeWritableStream(stream);
  var controller = Object.create(WritableStreamDefaultController.prototype);
  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
  return stream;
}

function InitializeWritableStream(stream) {
  stream._state = 'writable'; // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is
  // 'erroring' or 'errored'. May be set to an undefined value.

  stream._storedError = undefined;
  stream._writer = undefined; // Initialize to undefined first because the constructor of the controller checks this
  // variable to validate the caller.

  stream._writableStreamController = undefined; // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data
  // producer without waiting for the queued writes to finish.

  stream._writeRequests = []; // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents
  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.

  stream._inFlightWriteRequest = undefined; // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer
  // has been detached.

  stream._closeRequest = undefined; // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it
  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.

  stream._inFlightCloseRequest = undefined; // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.

  stream._pendingAbortRequest = undefined; // The backpressure signal set by the controller.

  stream._backpressure = false;
}

function IsWritableStream(x) {
  if (!typeIsObject(x)) {
    return false;
  }

  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
    return false;
  }

  return true;
}

function IsWritableStreamLocked(stream) {
  if (stream._writer === undefined) {
    return false;
  }

  return true;
}

function WritableStreamAbort(stream, reason) {
  var state = stream._state;

  if (state === 'closed' || state === 'errored') {
    return Promise.resolve(undefined);
  }

  if (stream._pendingAbortRequest !== undefined) {
    return stream._pendingAbortRequest._promise;
  }

  var wasAlreadyErroring = false;

  if (state === 'erroring') {
    wasAlreadyErroring = true; // reason will not be used, so don't keep a reference to it.

    reason = undefined;
  }

  var promise = new Promise(function (resolve, reject) {
    stream._pendingAbortRequest = {
      _resolve: resolve,
      _reject: reject,
      _reason: reason,
      _wasAlreadyErroring: wasAlreadyErroring
    };
  });
  stream._pendingAbortRequest._promise = promise;

  if (wasAlreadyErroring === false) {
    WritableStreamStartErroring(stream, reason);
  }

  return promise;
} // WritableStream API exposed for controllers.


function WritableStreamAddWriteRequest(stream) {
  var promise = new Promise(function (resolve, reject) {
    var writeRequest = {
      _resolve: resolve,
      _reject: reject
    };

    stream._writeRequests.push(writeRequest);
  });
  return promise;
}

function WritableStreamDealWithRejection(stream, error) {
  var state = stream._state;

  if (state === 'writable') {
    WritableStreamStartErroring(stream, error);
    return;
  }

  WritableStreamFinishErroring(stream);
}

function WritableStreamStartErroring(stream, reason) {
  var controller = stream._writableStreamController;
  stream._state = 'erroring';
  stream._storedError = reason;
  var writer = stream._writer;

  if (writer !== undefined) {
    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
  }

  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {
    WritableStreamFinishErroring(stream);
  }
}

function WritableStreamFinishErroring(stream) {
  stream._state = 'errored';

  stream._writableStreamController[ErrorSteps]();

  var storedError = stream._storedError;

  for (var _i2 = 0, _stream$_writeRequest2 = stream._writeRequests; _i2 < _stream$_writeRequest2.length; _i2++) {
    var writeRequest = _stream$_writeRequest2[_i2];

    writeRequest._reject(storedError);
  }

  stream._writeRequests = [];

  if (stream._pendingAbortRequest === undefined) {
    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    return;
  }

  var abortRequest = stream._pendingAbortRequest;
  stream._pendingAbortRequest = undefined;

  if (abortRequest._wasAlreadyErroring === true) {
    abortRequest._reject(storedError);

    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    return;
  }

  var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);

  promise.then(function () {
    abortRequest._resolve();

    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
  }, function (reason) {
    abortRequest._reject(reason);

    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
  });
}

function WritableStreamFinishInFlightWrite(stream) {
  stream._inFlightWriteRequest._resolve(undefined);

  stream._inFlightWriteRequest = undefined;
}

function WritableStreamFinishInFlightWriteWithError(stream, error) {
  stream._inFlightWriteRequest._reject(error);

  stream._inFlightWriteRequest = undefined;
  WritableStreamDealWithRejection(stream, error);
}

function WritableStreamFinishInFlightClose(stream) {
  stream._inFlightCloseRequest._resolve(undefined);

  stream._inFlightCloseRequest = undefined;
  var state = stream._state;

  if (state === 'erroring') {
    // The error was too late to do anything, so it is ignored.
    stream._storedError = undefined;

    if (stream._pendingAbortRequest !== undefined) {
      stream._pendingAbortRequest._resolve();

      stream._pendingAbortRequest = undefined;
    }
  }

  stream._state = 'closed';
  var writer = stream._writer;

  if (writer !== undefined) {
    defaultWriterClosedPromiseResolve(writer);
  }
}

function WritableStreamFinishInFlightCloseWithError(stream, error) {
  stream._inFlightCloseRequest._reject(error);

  stream._inFlightCloseRequest = undefined; // Never execute sink abort() after sink close().

  if (stream._pendingAbortRequest !== undefined) {
    stream._pendingAbortRequest._reject(error);

    stream._pendingAbortRequest = undefined;
  }

  WritableStreamDealWithRejection(stream, error);
} // TODO(ricea): Fix alphabetical order.


function WritableStreamCloseQueuedOrInFlight(stream) {
  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
    return false;
  }

  return true;
}

function WritableStreamHasOperationMarkedInFlight(stream) {
  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
    return false;
  }

  return true;
}

function WritableStreamMarkCloseRequestInFlight(stream) {
  stream._inFlightCloseRequest = stream._closeRequest;
  stream._closeRequest = undefined;
}

function WritableStreamMarkFirstWriteRequestInFlight(stream) {
  stream._inFlightWriteRequest = stream._writeRequests.shift();
}

function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
  if (stream._closeRequest !== undefined) {
    stream._closeRequest._reject(stream._storedError);

    stream._closeRequest = undefined;
  }

  var writer = stream._writer;

  if (writer !== undefined) {
    defaultWriterClosedPromiseReject(writer, stream._storedError);

    writer._closedPromise.catch(function () {});
  }
}

function WritableStreamUpdateBackpressure(stream, backpressure) {
  var writer = stream._writer;

  if (writer !== undefined && backpressure !== stream._backpressure) {
    if (backpressure === true) {
      defaultWriterReadyPromiseReset(writer);
    } else {
      defaultWriterReadyPromiseResolve(writer);
    }
  }

  stream._backpressure = backpressure;
}

var WritableStreamDefaultWriter =
/*#__PURE__*/
function () {
  function WritableStreamDefaultWriter(stream) {
    if (IsWritableStream(stream) === false) {
      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');
    }

    if (IsWritableStreamLocked(stream) === true) {
      throw new TypeError('This stream has already been locked for exclusive writing by another writer');
    }

    this._ownerWritableStream = stream;
    stream._writer = this;
    var state = stream._state;

    if (state === 'writable') {
      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {
        defaultWriterReadyPromiseInitialize(this);
      } else {
        defaultWriterReadyPromiseInitializeAsResolved(this);
      }

      defaultWriterClosedPromiseInitialize(this);
    } else if (state === 'erroring') {
      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);

      this._readyPromise.catch(function () {});

      defaultWriterClosedPromiseInitialize(this);
    } else if (state === 'closed') {
      defaultWriterReadyPromiseInitializeAsResolved(this);
      defaultWriterClosedPromiseInitializeAsResolved(this);
    } else {
      var storedError = stream._storedError;
      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);

      this._readyPromise.catch(function () {});

      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);

      this._closedPromise.catch(function () {});
    }
  }

  var _proto2 = WritableStreamDefaultWriter.prototype;

  _proto2.abort = function abort(reason) {
    if (IsWritableStreamDefaultWriter(this) === false) {
      return Promise.reject(defaultWriterBrandCheckException('abort'));
    }

    if (this._ownerWritableStream === undefined) {
      return Promise.reject(defaultWriterLockException('abort'));
    }

    return WritableStreamDefaultWriterAbort(this, reason);
  };

  _proto2.close = function close() {
    if (IsWritableStreamDefaultWriter(this) === false) {
      return Promise.reject(defaultWriterBrandCheckException('close'));
    }

    var stream = this._ownerWritableStream;

    if (stream === undefined) {
      return Promise.reject(defaultWriterLockException('close'));
    }

    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {
      return Promise.reject(new TypeError('cannot close an already-closing stream'));
    }

    return WritableStreamDefaultWriterClose(this);
  };

  _proto2.releaseLock = function releaseLock() {
    if (IsWritableStreamDefaultWriter(this) === false) {
      throw defaultWriterBrandCheckException('releaseLock');
    }

    var stream = this._ownerWritableStream;

    if (stream === undefined) {
      return;
    }

    WritableStreamDefaultWriterRelease(this);
  };

  _proto2.write = function write(chunk) {
    if (IsWritableStreamDefaultWriter(this) === false) {
      return Promise.reject(defaultWriterBrandCheckException('write'));
    }

    if (this._ownerWritableStream === undefined) {
      return Promise.reject(defaultWriterLockException('write to'));
    }

    return WritableStreamDefaultWriterWrite(this, chunk);
  };

  _createClass(WritableStreamDefaultWriter, [{
    key: "closed",
    get: function get() {
      if (IsWritableStreamDefaultWriter(this) === false) {
        return Promise.reject(defaultWriterBrandCheckException('closed'));
      }

      return this._closedPromise;
    }
  }, {
    key: "desiredSize",
    get: function get() {
      if (IsWritableStreamDefaultWriter(this) === false) {
        throw defaultWriterBrandCheckException('desiredSize');
      }

      if (this._ownerWritableStream === undefined) {
        throw defaultWriterLockException('desiredSize');
      }

      return WritableStreamDefaultWriterGetDesiredSize(this);
    }
  }, {
    key: "ready",
    get: function get() {
      if (IsWritableStreamDefaultWriter(this) === false) {
        return Promise.reject(defaultWriterBrandCheckException('ready'));
      }

      return this._readyPromise;
    }
  }]);

  return WritableStreamDefaultWriter;
}(); // Abstract operations for the WritableStreamDefaultWriter.


function IsWritableStreamDefaultWriter(x) {
  if (!typeIsObject(x)) {
    return false;
  }

  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
    return false;
  }

  return true;
} // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.


function WritableStreamDefaultWriterAbort(writer, reason) {
  var stream = writer._ownerWritableStream;
  return WritableStreamAbort(stream, reason);
}

function WritableStreamDefaultWriterClose(writer) {
  var stream = writer._ownerWritableStream;
  var state = stream._state;

  if (state === 'closed' || state === 'errored') {
    return Promise.reject(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
  }

  var promise = new Promise(function (resolve, reject) {
    var closeRequest = {
      _resolve: resolve,
      _reject: reject
    };
    stream._closeRequest = closeRequest;
  });

  if (stream._backpressure === true && state === 'writable') {
    defaultWriterReadyPromiseResolve(writer);
  }

  WritableStreamDefaultControllerClose(stream._writableStreamController);
  return promise;
}

function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
  var stream = writer._ownerWritableStream;
  var state = stream._state;

  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {
    return Promise.resolve();
  }

  if (state === 'errored') {
    return Promise.reject(stream._storedError);
  }

  return WritableStreamDefaultWriterClose(writer);
}

function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
  if (writer._closedPromiseState === 'pending') {
    defaultWriterClosedPromiseReject(writer, error);
  } else {
    defaultWriterClosedPromiseResetToRejected(writer, error);
  }

  writer._closedPromise.catch(function () {});
}

function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
  if (writer._readyPromiseState === 'pending') {
    defaultWriterReadyPromiseReject(writer, error);
  } else {
    defaultWriterReadyPromiseResetToRejected(writer, error);
  }

  writer._readyPromise.catch(function () {});
}

function WritableStreamDefaultWriterGetDesiredSize(writer) {
  var stream = writer._ownerWritableStream;
  var state = stream._state;

  if (state === 'errored' || state === 'erroring') {
    return null;
  }

  if (state === 'closed') {
    return 0;
  }

  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
}

function WritableStreamDefaultWriterRelease(writer) {
  var stream = writer._ownerWritableStream;
  var releasedError = new TypeError('Writer was released and can no longer be used to monitor the stream\'s closedness');
  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError); // The state transitions to "errored" before the sink abort() method runs, but the writer.closed promise is not
  // rejected until afterwards. This means that simply testing state will not work.

  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
  stream._writer = undefined;
  writer._ownerWritableStream = undefined;
}

function WritableStreamDefaultWriterWrite(writer, chunk) {
  var stream = writer._ownerWritableStream;
  var controller = stream._writableStreamController;
  var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);

  if (stream !== writer._ownerWritableStream) {
    return Promise.reject(defaultWriterLockException('write to'));
  }

  var state = stream._state;

  if (state === 'errored') {
    return Promise.reject(stream._storedError);
  }

  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {
    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));
  }

  if (state === 'erroring') {
    return Promise.reject(stream._storedError);
  }

  var promise = WritableStreamAddWriteRequest(stream);
  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
  return promise;
}

var WritableStreamDefaultController =
/*#__PURE__*/
function () {
  function WritableStreamDefaultController() {
    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');
  }

  var _proto3 = WritableStreamDefaultController.prototype;

  _proto3.error = function error(e) {
    if (IsWritableStreamDefaultController(this) === false) {
      throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');
    }

    var state = this._controlledWritableStream._state;

    if (state !== 'writable') {
      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so
      // just treat it as a no-op.
      return;
    }

    WritableStreamDefaultControllerError(this, e);
  };

  _proto3[AbortSteps] = function (reason) {
    var result = this._abortAlgorithm(reason);

    WritableStreamDefaultControllerClearAlgorithms(this);
    return result;
  };

  _proto3[ErrorSteps] = function () {
    ResetQueue$1(this);
  };

  return WritableStreamDefaultController;
}(); // Abstract operations implementing interface required by the WritableStream.


function IsWritableStreamDefaultController(x) {
  if (!typeIsObject(x)) {
    return false;
  }

  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {
    return false;
  }

  return true;
}

function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
  controller._controlledWritableStream = stream;
  stream._writableStreamController = controller; // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.

  controller._queue = undefined;
  controller._queueTotalSize = undefined;
  ResetQueue$1(controller);
  controller._started = false;
  controller._strategySizeAlgorithm = sizeAlgorithm;
  controller._strategyHWM = highWaterMark;
  controller._writeAlgorithm = writeAlgorithm;
  controller._closeAlgorithm = closeAlgorithm;
  controller._abortAlgorithm = abortAlgorithm;
  var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
  WritableStreamUpdateBackpressure(stream, backpressure);
  var startResult = startAlgorithm();
  var startPromise = Promise.resolve(startResult);
  startPromise.then(function () {
    controller._started = true;
    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }, function (r) {
    controller._started = true;
    WritableStreamDealWithRejection(stream, r);
  }).catch(rethrowAssertionErrorRejection$1);
}

function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
  var controller = Object.create(WritableStreamDefaultController.prototype);

  function startAlgorithm() {
    return InvokeOrNoop(underlyingSink, 'start', [controller]);
  }

  var writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);
  var closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);
  var abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);
  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
} // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.


function WritableStreamDefaultControllerClearAlgorithms(controller) {
  controller._writeAlgorithm = undefined;
  controller._closeAlgorithm = undefined;
  controller._abortAlgorithm = undefined;
  controller._strategySizeAlgorithm = undefined;
}

function WritableStreamDefaultControllerClose(controller) {
  EnqueueValueWithSize$1(controller, 'close', 0);
  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
}

function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
  try {
    return controller._strategySizeAlgorithm(chunk);
  } catch (chunkSizeE) {
    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
    return 1;
  }
}

function WritableStreamDefaultControllerGetDesiredSize(controller) {
  return controller._strategyHWM - controller._queueTotalSize;
}

function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
  var writeRecord = {
    chunk: chunk
  };

  try {
    EnqueueValueWithSize$1(controller, writeRecord, chunkSize);
  } catch (enqueueE) {
    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
    return;
  }

  var stream = controller._controlledWritableStream;

  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {
    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
    WritableStreamUpdateBackpressure(stream, backpressure);
  }

  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
} // Abstract operations for the WritableStreamDefaultController.


function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
  var stream = controller._controlledWritableStream;

  if (controller._started === false) {
    return;
  }

  if (stream._inFlightWriteRequest !== undefined) {
    return;
  }

  var state = stream._state;

  if (state === 'closed' || state === 'errored') {
    return;
  }

  if (state === 'erroring') {
    WritableStreamFinishErroring(stream);
    return;
  }

  if (controller._queue.length === 0) {
    return;
  }

  var writeRecord = PeekQueueValue$1(controller);

  if (writeRecord === 'close') {
    WritableStreamDefaultControllerProcessClose(controller);
  } else {
    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);
  }
}

function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
  if (controller._controlledWritableStream._state === 'writable') {
    WritableStreamDefaultControllerError(controller, error);
  }
}

function WritableStreamDefaultControllerProcessClose(controller) {
  var stream = controller._controlledWritableStream;
  WritableStreamMarkCloseRequestInFlight(stream);
  DequeueValue$1(controller);

  var sinkClosePromise = controller._closeAlgorithm();

  WritableStreamDefaultControllerClearAlgorithms(controller);
  sinkClosePromise.then(function () {
    WritableStreamFinishInFlightClose(stream);
  }, function (reason) {
    WritableStreamFinishInFlightCloseWithError(stream, reason);
  }).catch(rethrowAssertionErrorRejection$1);
}

function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
  var stream = controller._controlledWritableStream;
  WritableStreamMarkFirstWriteRequestInFlight(stream);

  var sinkWritePromise = controller._writeAlgorithm(chunk);

  sinkWritePromise.then(function () {
    WritableStreamFinishInFlightWrite(stream);
    var state = stream._state;
    DequeueValue$1(controller);

    if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {
      var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
      WritableStreamUpdateBackpressure(stream, backpressure);
    }

    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }, function (reason) {
    if (stream._state === 'writable') {
      WritableStreamDefaultControllerClearAlgorithms(controller);
    }

    WritableStreamFinishInFlightWriteWithError(stream, reason);
  }).catch(rethrowAssertionErrorRejection$1);
}

function WritableStreamDefaultControllerGetBackpressure(controller) {
  var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
  return desiredSize <= 0;
} // A client of WritableStreamDefaultController may use these functions directly to bypass state check.


function WritableStreamDefaultControllerError(controller, error) {
  var stream = controller._controlledWritableStream;
  WritableStreamDefaultControllerClearAlgorithms(controller);
  WritableStreamStartErroring(stream, error);
} // Helper functions for the WritableStream.


function streamBrandCheckException(name) {
  return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
} // Helper functions for the WritableStreamDefaultWriter.


function defaultWriterBrandCheckException(name) {
  return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
}

function defaultWriterLockException(name) {
  return new TypeError('Cannot ' + name + ' a stream using a released writer');
}

function defaultWriterClosedPromiseInitialize(writer) {
  writer._closedPromise = new Promise(function (resolve, reject) {
    writer._closedPromise_resolve = resolve;
    writer._closedPromise_reject = reject;
    writer._closedPromiseState = 'pending';
  });
}

function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
  writer._closedPromise = Promise.reject(reason);
  writer._closedPromise_resolve = undefined;
  writer._closedPromise_reject = undefined;
  writer._closedPromiseState = 'rejected';
}

function defaultWriterClosedPromiseInitializeAsResolved(writer) {
  writer._closedPromise = Promise.resolve(undefined);
  writer._closedPromise_resolve = undefined;
  writer._closedPromise_reject = undefined;
  writer._closedPromiseState = 'resolved';
}

function defaultWriterClosedPromiseReject(writer, reason) {
  writer._closedPromise_reject(reason);

  writer._closedPromise_resolve = undefined;
  writer._closedPromise_reject = undefined;
  writer._closedPromiseState = 'rejected';
}

function defaultWriterClosedPromiseResetToRejected(writer, reason) {
  writer._closedPromise = Promise.reject(reason);
  writer._closedPromiseState = 'rejected';
}

function defaultWriterClosedPromiseResolve(writer) {
  writer._closedPromise_resolve(undefined);

  writer._closedPromise_resolve = undefined;
  writer._closedPromise_reject = undefined;
  writer._closedPromiseState = 'resolved';
}

function defaultWriterReadyPromiseInitialize(writer) {
  writer._readyPromise = new Promise(function (resolve, reject) {
    writer._readyPromise_resolve = resolve;
    writer._readyPromise_reject = reject;
  });
  writer._readyPromiseState = 'pending';
}

function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
  writer._readyPromise = Promise.reject(reason);
  writer._readyPromise_resolve = undefined;
  writer._readyPromise_reject = undefined;
  writer._readyPromiseState = 'rejected';
}

function defaultWriterReadyPromiseInitializeAsResolved(writer) {
  writer._readyPromise = Promise.resolve(undefined);
  writer._readyPromise_resolve = undefined;
  writer._readyPromise_reject = undefined;
  writer._readyPromiseState = 'fulfilled';
}

function defaultWriterReadyPromiseReject(writer, reason) {
  writer._readyPromise_reject(reason);

  writer._readyPromise_resolve = undefined;
  writer._readyPromise_reject = undefined;
  writer._readyPromiseState = 'rejected';
}

function defaultWriterReadyPromiseReset(writer) {
  writer._readyPromise = new Promise(function (resolve, reject) {
    writer._readyPromise_resolve = resolve;
    writer._readyPromise_reject = reject;
  });
  writer._readyPromiseState = 'pending';
}

function defaultWriterReadyPromiseResetToRejected(writer, reason) {
  writer._readyPromise = Promise.reject(reason);
  writer._readyPromiseState = 'rejected';
}

function defaultWriterReadyPromiseResolve(writer) {
  writer._readyPromise_resolve(undefined);

  writer._readyPromise_resolve = undefined;
  writer._readyPromise_reject = undefined;
  writer._readyPromiseState = 'fulfilled';
}
var writableStream_5 = writableStream.WritableStream;

/* global AbortSignal:false */


var ArrayBufferCopy = require$$0.ArrayBufferCopy,
    CreateAlgorithmFromUnderlyingMethod$1 = require$$0.CreateAlgorithmFromUnderlyingMethod,
    IsFiniteNonNegativeNumber$1 = require$$0.IsFiniteNonNegativeNumber,
    InvokeOrNoop$1 = require$$0.InvokeOrNoop,
    IsDetachedBuffer$1 = require$$0.IsDetachedBuffer,
    TransferArrayBuffer$1 = require$$0.TransferArrayBuffer,
    ValidateAndNormalizeHighWaterMark$1 = require$$0.ValidateAndNormalizeHighWaterMark,
    IsNonNegativeNumber$1 = require$$0.IsNonNegativeNumber,
    MakeSizeAlgorithmFromSizeFunction$1 = require$$0.MakeSizeAlgorithmFromSizeFunction,
    createArrayFromList = require$$0.createArrayFromList,
    typeIsObject$1 = require$$0.typeIsObject,
    WaitForAllPromise = require$$0.WaitForAllPromise;
var rethrowAssertionErrorRejection$2 = utils.rethrowAssertionErrorRejection;
var DequeueValue$2 = queueWithSizes.DequeueValue,
    EnqueueValueWithSize$2 = queueWithSizes.EnqueueValueWithSize,
    ResetQueue$2 = queueWithSizes.ResetQueue;
var AcquireWritableStreamDefaultWriter$1 = writableStream.AcquireWritableStreamDefaultWriter,
    IsWritableStream$1 = writableStream.IsWritableStream,
    IsWritableStreamLocked$1 = writableStream.IsWritableStreamLocked,
    WritableStreamAbort$1 = writableStream.WritableStreamAbort,
    WritableStreamDefaultWriterCloseWithErrorPropagation$1 = writableStream.WritableStreamDefaultWriterCloseWithErrorPropagation,
    WritableStreamDefaultWriterRelease$1 = writableStream.WritableStreamDefaultWriterRelease,
    WritableStreamDefaultWriterWrite$1 = writableStream.WritableStreamDefaultWriterWrite,
    WritableStreamCloseQueuedOrInFlight$1 = writableStream.WritableStreamCloseQueuedOrInFlight;
var CancelSteps = SymbolPolyfill('[[CancelSteps]]');
var PullSteps = SymbolPolyfill('[[PullSteps]]');

var ReadableStream =
/*#__PURE__*/
function () {
  function ReadableStream(underlyingSource, strategy) {
    if (underlyingSource === void 0) {
      underlyingSource = {};
    }

    if (strategy === void 0) {
      strategy = {};
    }

    InitializeReadableStream(this);
    var size = strategy.size;
    var highWaterMark = strategy.highWaterMark;
    var type = underlyingSource.type;
    var typeString = String(type);

    if (typeString === 'bytes') {
      if (size !== undefined) {
        throw new RangeError('The strategy for a byte stream cannot have a size function');
      }

      if (highWaterMark === undefined) {
        highWaterMark = 0;
      }

      highWaterMark = ValidateAndNormalizeHighWaterMark$1(highWaterMark);
      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
    } else if (type === undefined) {
      var sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction$1(size);

      if (highWaterMark === undefined) {
        highWaterMark = 1;
      }

      highWaterMark = ValidateAndNormalizeHighWaterMark$1(highWaterMark);
      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
    } else {
      throw new RangeError('Invalid type is specified');
    }
  }

  var _proto = ReadableStream.prototype;

  _proto.cancel = function cancel(reason) {
    if (IsReadableStream(this) === false) {
      return Promise.reject(streamBrandCheckException$1('cancel'));
    }

    if (IsReadableStreamLocked(this) === true) {
      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));
    }

    return ReadableStreamCancel(this, reason);
  };

  _proto.getReader = function getReader(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        mode = _ref.mode;

    if (IsReadableStream(this) === false) {
      throw streamBrandCheckException$1('getReader');
    }

    if (mode === undefined) {
      return AcquireReadableStreamDefaultReader(this);
    }

    mode = String(mode);

    if (mode === 'byob') {
      return AcquireReadableStreamBYOBReader(this);
    }

    throw new RangeError('Invalid mode is specified');
  };

  _proto.pipeThrough = function pipeThrough(_ref2, _temp2) {
    var writable = _ref2.writable,
        readable = _ref2.readable;

    var _ref3 = _temp2 === void 0 ? {} : _temp2,
        preventClose = _ref3.preventClose,
        preventAbort = _ref3.preventAbort,
        preventCancel = _ref3.preventCancel,
        signal = _ref3.signal;

    if (IsReadableStream(this) === false) {
      throw streamBrandCheckException$1('pipeThrough');
    }

    if (IsWritableStream$1(writable) === false) {
      throw new TypeError('writable argument to pipeThrough must be a WritableStream');
    }

    if (IsReadableStream(readable) === false) {
      throw new TypeError('readable argument to pipeThrough must be a ReadableStream');
    }

    preventClose = Boolean(preventClose);
    preventAbort = Boolean(preventAbort);
    preventCancel = Boolean(preventCancel);

    if (signal !== undefined && !isAbortSignal(signal)) {
      throw new TypeError('ReadableStream.prototype.pipeThrough\'s signal option must be an AbortSignal');
    }

    if (IsReadableStreamLocked(this) === true) {
      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');
    }

    if (IsWritableStreamLocked$1(writable) === true) {
      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');
    }

    var promise = ReadableStreamPipeTo(this, writable, preventClose, preventAbort, preventCancel, signal);
    promise.catch(function () {});
    return readable;
  };

  _proto.pipeTo = function pipeTo(dest, _temp3) {
    var _ref4 = _temp3 === void 0 ? {} : _temp3,
        preventClose = _ref4.preventClose,
        preventAbort = _ref4.preventAbort,
        preventCancel = _ref4.preventCancel,
        signal = _ref4.signal;

    if (IsReadableStream(this) === false) {
      return Promise.reject(streamBrandCheckException$1('pipeTo'));
    }

    if (IsWritableStream$1(dest) === false) {
      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo\'s first argument must be a WritableStream'));
    }

    preventClose = Boolean(preventClose);
    preventAbort = Boolean(preventAbort);
    preventCancel = Boolean(preventCancel);

    if (signal !== undefined && !isAbortSignal(signal)) {
      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo\'s signal option must be an AbortSignal'));
    }

    if (IsReadableStreamLocked(this) === true) {
      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
    }

    if (IsWritableStreamLocked$1(dest) === true) {
      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
    }

    return ReadableStreamPipeTo(this, dest, preventClose, preventAbort, preventCancel, signal);
  };

  _proto.tee = function tee() {
    if (IsReadableStream(this) === false) {
      throw streamBrandCheckException$1('tee');
    }

    var branches = ReadableStreamTee(this, false);
    return createArrayFromList(branches);
  };

  _createClass(ReadableStream, [{
    key: "locked",
    get: function get() {
      if (IsReadableStream(this) === false) {
        throw streamBrandCheckException$1('locked');
      }

      return IsReadableStreamLocked(this);
    }
  }]);

  return ReadableStream;
}();

var readableStream = {
  CreateReadableByteStream: CreateReadableByteStream,
  CreateReadableStream: CreateReadableStream,
  ReadableStream: ReadableStream,
  IsReadableStreamDisturbed: IsReadableStreamDisturbed,
  ReadableStreamDefaultControllerClose: ReadableStreamDefaultControllerClose,
  ReadableStreamDefaultControllerEnqueue: ReadableStreamDefaultControllerEnqueue,
  ReadableStreamDefaultControllerError: ReadableStreamDefaultControllerError,
  ReadableStreamDefaultControllerGetDesiredSize: ReadableStreamDefaultControllerGetDesiredSize,
  ReadableStreamDefaultControllerHasBackpressure: ReadableStreamDefaultControllerHasBackpressure,
  ReadableStreamDefaultControllerCanCloseOrEnqueue: ReadableStreamDefaultControllerCanCloseOrEnqueue
}; // Abstract operations for the ReadableStream.

function AcquireReadableStreamBYOBReader(stream) {
  return new ReadableStreamBYOBReader(stream);
}

function AcquireReadableStreamDefaultReader(stream) {
  return new ReadableStreamDefaultReader(stream);
} // Throws if and only if startAlgorithm throws.


function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
  if (highWaterMark === void 0) {
    highWaterMark = 1;
  }

  if (sizeAlgorithm === void 0) {
    sizeAlgorithm = function sizeAlgorithm() {
      return 1;
    };
  }

  var stream = Object.create(ReadableStream.prototype);
  InitializeReadableStream(stream);
  var controller = Object.create(ReadableStreamDefaultController.prototype);
  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
  return stream;
} // Throws if and only if startAlgorithm throws.


function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
  if (highWaterMark === void 0) {
    highWaterMark = 0;
  }

  if (autoAllocateChunkSize === void 0) {
    autoAllocateChunkSize = undefined;
  }

  var stream = Object.create(ReadableStream.prototype);
  InitializeReadableStream(stream);
  var controller = Object.create(ReadableByteStreamController.prototype);
  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
  return stream;
}

function InitializeReadableStream(stream) {
  stream._state = 'readable';
  stream._reader = undefined;
  stream._storedError = undefined;
  stream._disturbed = false;
}

function IsReadableStream(x) {
  if (!typeIsObject$1(x)) {
    return false;
  }

  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
    return false;
  }

  return true;
}

function IsReadableStreamDisturbed(stream) {
  return stream._disturbed;
}

function IsReadableStreamLocked(stream) {
  if (stream._reader === undefined) {
    return false;
  }

  return true;
}

function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
  var reader = AcquireReadableStreamDefaultReader(source);
  var writer = AcquireWritableStreamDefaultWriter$1(dest);
  var shuttingDown = false; // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.

  var currentWrite = Promise.resolve();
  return new Promise(function (resolve, reject) {
    var abortAlgorithm;

    if (signal !== undefined) {
      abortAlgorithm = function abortAlgorithm() {
        var error = new DOMException('Aborted', 'AbortError');
        var actions = [];

        if (preventAbort === false) {
          actions.push(function () {
            if (dest._state === 'writable') {
              return WritableStreamAbort$1(dest, error);
            }

            return Promise.resolve();
          });
        }

        if (preventCancel === false) {
          actions.push(function () {
            if (source._state === 'readable') {
              return ReadableStreamCancel(source, error);
            }

            return Promise.resolve();
          });
        }

        shutdownWithAction(function () {
          return WaitForAllPromise(actions.map(function (action) {
            return action();
          }), function (results) {
            return results;
          });
        }, true, error);
      };

      if (signal.aborted === true) {
        abortAlgorithm();
        return;
      }

      signal.addEventListener('abort', abortAlgorithm);
    } // Using reader and writer, read all chunks from this and write them to dest
    // - Backpressure must be enforced
    // - Shutdown must stop all activity


    function pipeLoop() {
      return new Promise(function (resolveLoop, rejectLoop) {
        function next(done) {
          if (done) {
            resolveLoop();
          } else {
            pipeStep().then(next, rejectLoop);
          }
        }

        next(false);
      });
    }

    function pipeStep() {
      if (shuttingDown === true) {
        return Promise.resolve(true);
      }

      return writer._readyPromise.then(function () {
        return ReadableStreamDefaultReaderRead(reader).then(function (_ref5) {
          var value = _ref5.value,
              done = _ref5.done;

          if (done === true) {
            return true;
          }

          currentWrite = WritableStreamDefaultWriterWrite$1(writer, value).catch(function () {});
          return false;
        });
      });
    } // Errors must be propagated forward


    isOrBecomesErrored(source, reader._closedPromise, function (storedError) {
      if (preventAbort === false) {
        shutdownWithAction(function () {
          return WritableStreamAbort$1(dest, storedError);
        }, true, storedError);
      } else {
        shutdown(true, storedError);
      }
    }); // Errors must be propagated backward

    isOrBecomesErrored(dest, writer._closedPromise, function (storedError) {
      if (preventCancel === false) {
        shutdownWithAction(function () {
          return ReadableStreamCancel(source, storedError);
        }, true, storedError);
      } else {
        shutdown(true, storedError);
      }
    }); // Closing must be propagated forward

    isOrBecomesClosed(source, reader._closedPromise, function () {
      if (preventClose === false) {
        shutdownWithAction(function () {
          return WritableStreamDefaultWriterCloseWithErrorPropagation$1(writer);
        });
      } else {
        shutdown();
      }
    }); // Closing must be propagated backward

    if (WritableStreamCloseQueuedOrInFlight$1(dest) === true || dest._state === 'closed') {
      var destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');

      if (preventCancel === false) {
        shutdownWithAction(function () {
          return ReadableStreamCancel(source, destClosed);
        }, true, destClosed);
      } else {
        shutdown(true, destClosed);
      }
    }

    pipeLoop().catch(function (err) {
      currentWrite = Promise.resolve();
      rethrowAssertionErrorRejection$2(err);
    });

    function waitForWritesToFinish() {
      // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait
      // for that too.
      var oldCurrentWrite = currentWrite;
      return currentWrite.then(function () {
        return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined;
      });
    }

    function isOrBecomesErrored(stream, promise, action) {
      if (stream._state === 'errored') {
        action(stream._storedError);
      } else {
        promise.catch(action).catch(rethrowAssertionErrorRejection$2);
      }
    }

    function isOrBecomesClosed(stream, promise, action) {
      if (stream._state === 'closed') {
        action();
      } else {
        promise.then(action).catch(rethrowAssertionErrorRejection$2);
      }
    }

    function shutdownWithAction(action, originalIsError, originalError) {
      if (shuttingDown === true) {
        return;
      }

      shuttingDown = true;

      if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight$1(dest) === false) {
        waitForWritesToFinish().then(doTheRest);
      } else {
        doTheRest();
      }

      function doTheRest() {
        action().then(function () {
          return finalize(originalIsError, originalError);
        }, function (newError) {
          return finalize(true, newError);
        }).catch(rethrowAssertionErrorRejection$2);
      }
    }

    function shutdown(isError, error) {
      if (shuttingDown === true) {
        return;
      }

      shuttingDown = true;

      if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight$1(dest) === false) {
        waitForWritesToFinish().then(function () {
          return finalize(isError, error);
        }).catch(rethrowAssertionErrorRejection$2);
      } else {
        finalize(isError, error);
      }
    }

    function finalize(isError, error) {
      WritableStreamDefaultWriterRelease$1(writer);
      ReadableStreamReaderGenericRelease(reader);

      if (signal !== undefined) {
        signal.removeEventListener('abort', abortAlgorithm);
      }

      if (isError) {
        reject(error);
      } else {
        resolve(undefined);
      }
    }
  });
}

function ReadableStreamTee(stream, cloneForBranch2) {
  var reader = AcquireReadableStreamDefaultReader(stream);
  var closedOrErrored = false;
  var canceled1 = false;
  var canceled2 = false;
  var reason1;
  var reason2;
  var branch1;
  var branch2;
  var resolveCancelPromise;
  var cancelPromise = new Promise(function (resolve) {
    resolveCancelPromise = resolve;
  });

  function pullAlgorithm() {
    return ReadableStreamDefaultReaderRead(reader).then(function (result) {
      var value = result.value;
      var done = result.done;

      if (done === true && closedOrErrored === false) {
        if (canceled1 === false) {
          ReadableStreamDefaultControllerClose(branch1._readableStreamController);
        }

        if (canceled2 === false) {
          ReadableStreamDefaultControllerClose(branch2._readableStreamController);
        }

        closedOrErrored = true;
      }

      if (closedOrErrored === true) {
        return;
      }

      var value1 = value;
      var value2 = value; // There is no way to access the cloning code right now in the reference implementation.
      // If we add one then we'll need an implementation for serializable objects.
      // if (canceled2 === false && cloneForBranch2 === true) {
      //   value2 = StructuredDeserialize(StructuredSerialize(value2));
      // }

      if (canceled1 === false) {
        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);
      }

      if (canceled2 === false) {
        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);
      }
    });
  }

  function cancel1Algorithm(reason) {
    canceled1 = true;
    reason1 = reason;

    if (canceled2 === true) {
      var compositeReason = createArrayFromList([reason1, reason2]);
      var cancelResult = ReadableStreamCancel(stream, compositeReason);
      resolveCancelPromise(cancelResult);
    }

    return cancelPromise;
  }

  function cancel2Algorithm(reason) {
    canceled2 = true;
    reason2 = reason;

    if (canceled1 === true) {
      var compositeReason = createArrayFromList([reason1, reason2]);
      var cancelResult = ReadableStreamCancel(stream, compositeReason);
      resolveCancelPromise(cancelResult);
    }

    return cancelPromise;
  }

  function startAlgorithm() {}

  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);

  reader._closedPromise.catch(function (r) {
    if (closedOrErrored === true) {
      return;
    }

    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
    closedOrErrored = true;
  });

  return [branch1, branch2];
} // ReadableStream API exposed for controllers.


function ReadableStreamAddReadIntoRequest(stream, forAuthorCode) {
  var promise = new Promise(function (resolve, reject) {
    var readIntoRequest = {
      _resolve: resolve,
      _reject: reject,
      _forAuthorCode: forAuthorCode
    };

    stream._reader._readIntoRequests.push(readIntoRequest);
  });
  return promise;
}

function ReadableStreamAddReadRequest(stream, forAuthorCode) {
  var promise = new Promise(function (resolve, reject) {
    var readRequest = {
      _resolve: resolve,
      _reject: reject,
      _forAuthorCode: forAuthorCode
    };

    stream._reader._readRequests.push(readRequest);
  });
  return promise;
}

function ReadableStreamCancel(stream, reason) {
  stream._disturbed = true;

  if (stream._state === 'closed') {
    return Promise.resolve(undefined);
  }

  if (stream._state === 'errored') {
    return Promise.reject(stream._storedError);
  }

  ReadableStreamClose(stream);

  var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);

  return sourceCancelPromise.then(function () {
    return undefined;
  });
}

function ReadableStreamClose(stream) {
  stream._state = 'closed';
  var reader = stream._reader;

  if (reader === undefined) {
    return undefined;
  }

  if (IsReadableStreamDefaultReader(reader) === true) {
    for (var _i2 = 0, _reader$_readRequests2 = reader._readRequests; _i2 < _reader$_readRequests2.length; _i2++) {
      var _reader$_readRequests3 = _reader$_readRequests2[_i2],
          _resolve = _reader$_readRequests3._resolve,
          _forAuthorCode = _reader$_readRequests3._forAuthorCode;

      _resolve(ReadableStreamCreateReadResult(undefined, true, _forAuthorCode));
    }

    reader._readRequests = [];
  }

  defaultReaderClosedPromiseResolve(reader);
  return undefined;
}

function ReadableStreamCreateReadResult(value, done, forAuthorCode) {
  var prototype = null;

  if (forAuthorCode === true) {
    prototype = Object.prototype;
  }

  var obj = Object.create(prototype);
  Object.defineProperty(obj, 'value', {
    value: value,
    enumerable: true,
    writable: true,
    configurable: true
  });
  Object.defineProperty(obj, 'done', {
    value: done,
    enumerable: true,
    writable: true,
    configurable: true
  });
  return obj;
}

function ReadableStreamError(stream, e) {
  stream._state = 'errored';
  stream._storedError = e;
  var reader = stream._reader;

  if (reader === undefined) {
    return undefined;
  }

  if (IsReadableStreamDefaultReader(reader) === true) {
    for (var _i4 = 0, _reader$_readRequests5 = reader._readRequests; _i4 < _reader$_readRequests5.length; _i4++) {
      var readRequest = _reader$_readRequests5[_i4];

      readRequest._reject(e);
    }

    reader._readRequests = [];
  } else {
    for (var _i6 = 0, _reader$_readIntoRequ2 = reader._readIntoRequests; _i6 < _reader$_readIntoRequ2.length; _i6++) {
      var readIntoRequest = _reader$_readIntoRequ2[_i6];

      readIntoRequest._reject(e);
    }

    reader._readIntoRequests = [];
  }

  defaultReaderClosedPromiseReject(reader, e);

  reader._closedPromise.catch(function () {});
}

function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
  var reader = stream._reader;

  var readIntoRequest = reader._readIntoRequests.shift();

  readIntoRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readIntoRequest._forAuthorCode));
}

function ReadableStreamFulfillReadRequest(stream, chunk, done) {
  var reader = stream._reader;

  var readRequest = reader._readRequests.shift();

  readRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readRequest._forAuthorCode));
}

function ReadableStreamGetNumReadIntoRequests(stream) {
  return stream._reader._readIntoRequests.length;
}

function ReadableStreamGetNumReadRequests(stream) {
  return stream._reader._readRequests.length;
}

function ReadableStreamHasBYOBReader(stream) {
  var reader = stream._reader;

  if (reader === undefined) {
    return false;
  }

  if (IsReadableStreamBYOBReader(reader) === false) {
    return false;
  }

  return true;
}

function ReadableStreamHasDefaultReader(stream) {
  var reader = stream._reader;

  if (reader === undefined) {
    return false;
  }

  if (IsReadableStreamDefaultReader(reader) === false) {
    return false;
  }

  return true;
} // Readers


var ReadableStreamDefaultReader =
/*#__PURE__*/
function () {
  function ReadableStreamDefaultReader(stream) {
    if (IsReadableStream(stream) === false) {
      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');
    }

    if (IsReadableStreamLocked(stream) === true) {
      throw new TypeError('This stream has already been locked for exclusive reading by another reader');
    }

    ReadableStreamReaderGenericInitialize(this, stream);
    this._readRequests = [];
  }

  var _proto2 = ReadableStreamDefaultReader.prototype;

  _proto2.cancel = function cancel(reason) {
    if (IsReadableStreamDefaultReader(this) === false) {
      return Promise.reject(defaultReaderBrandCheckException('cancel'));
    }

    if (this._ownerReadableStream === undefined) {
      return Promise.reject(readerLockException('cancel'));
    }

    return ReadableStreamReaderGenericCancel(this, reason);
  };

  _proto2.read = function read() {
    if (IsReadableStreamDefaultReader(this) === false) {
      return Promise.reject(defaultReaderBrandCheckException('read'));
    }

    if (this._ownerReadableStream === undefined) {
      return Promise.reject(readerLockException('read from'));
    }

    return ReadableStreamDefaultReaderRead(this, true);
  };

  _proto2.releaseLock = function releaseLock() {
    if (IsReadableStreamDefaultReader(this) === false) {
      throw defaultReaderBrandCheckException('releaseLock');
    }

    if (this._ownerReadableStream === undefined) {
      return;
    }

    if (this._readRequests.length > 0) {
      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
    }

    ReadableStreamReaderGenericRelease(this);
  };

  _createClass(ReadableStreamDefaultReader, [{
    key: "closed",
    get: function get() {
      if (IsReadableStreamDefaultReader(this) === false) {
        return Promise.reject(defaultReaderBrandCheckException('closed'));
      }

      return this._closedPromise;
    }
  }]);

  return ReadableStreamDefaultReader;
}();

var ReadableStreamBYOBReader =
/*#__PURE__*/
function () {
  function ReadableStreamBYOBReader(stream) {
    if (!IsReadableStream(stream)) {
      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' + 'byte source');
    }

    if (IsReadableByteStreamController(stream._readableStreamController) === false) {
      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');
    }

    if (IsReadableStreamLocked(stream)) {
      throw new TypeError('This stream has already been locked for exclusive reading by another reader');
    }

    ReadableStreamReaderGenericInitialize(this, stream);
    this._readIntoRequests = [];
  }

  var _proto3 = ReadableStreamBYOBReader.prototype;

  _proto3.cancel = function cancel(reason) {
    if (!IsReadableStreamBYOBReader(this)) {
      return Promise.reject(byobReaderBrandCheckException('cancel'));
    }

    if (this._ownerReadableStream === undefined) {
      return Promise.reject(readerLockException('cancel'));
    }

    return ReadableStreamReaderGenericCancel(this, reason);
  };

  _proto3.read = function read(view) {
    if (!IsReadableStreamBYOBReader(this)) {
      return Promise.reject(byobReaderBrandCheckException('read'));
    }

    if (this._ownerReadableStream === undefined) {
      return Promise.reject(readerLockException('read from'));
    }

    if (!ArrayBuffer.isView(view)) {
      return Promise.reject(new TypeError('view must be an array buffer view'));
    }

    if (IsDetachedBuffer$1(view.buffer) === true) {
      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));
    }

    if (view.byteLength === 0) {
      return Promise.reject(new TypeError('view must have non-zero byteLength'));
    }

    return ReadableStreamBYOBReaderRead(this, view, true);
  };

  _proto3.releaseLock = function releaseLock() {
    if (!IsReadableStreamBYOBReader(this)) {
      throw byobReaderBrandCheckException('releaseLock');
    }

    if (this._ownerReadableStream === undefined) {
      return;
    }

    if (this._readIntoRequests.length > 0) {
      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
    }

    ReadableStreamReaderGenericRelease(this);
  };

  _createClass(ReadableStreamBYOBReader, [{
    key: "closed",
    get: function get() {
      if (!IsReadableStreamBYOBReader(this)) {
        return Promise.reject(byobReaderBrandCheckException('closed'));
      }

      return this._closedPromise;
    }
  }]);

  return ReadableStreamBYOBReader;
}(); // Abstract operations for the readers.


function IsReadableStreamBYOBReader(x) {
  if (!typeIsObject$1(x)) {
    return false;
  }

  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
    return false;
  }

  return true;
}

function IsReadableStreamDefaultReader(x) {
  if (!typeIsObject$1(x)) {
    return false;
  }

  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
    return false;
  }

  return true;
}

function ReadableStreamReaderGenericInitialize(reader, stream) {
  reader._ownerReadableStream = stream;
  stream._reader = reader;

  if (stream._state === 'readable') {
    defaultReaderClosedPromiseInitialize(reader);
  } else if (stream._state === 'closed') {
    defaultReaderClosedPromiseInitializeAsResolved(reader);
  } else {
    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);

    reader._closedPromise.catch(function () {});
  }
} // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state
// check.


function ReadableStreamReaderGenericCancel(reader, reason) {
  var stream = reader._ownerReadableStream;
  return ReadableStreamCancel(stream, reason);
}

function ReadableStreamReaderGenericRelease(reader) {
  if (reader._ownerReadableStream._state === 'readable') {
    defaultReaderClosedPromiseReject(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\'s closedness'));
  } else {
    defaultReaderClosedPromiseResetToRejected(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\'s closedness'));
  }

  reader._closedPromise.catch(function () {});

  reader._ownerReadableStream._reader = undefined;
  reader._ownerReadableStream = undefined;
}

function ReadableStreamBYOBReaderRead(reader, view, forAuthorCode) {
  if (forAuthorCode === void 0) {
    forAuthorCode = false;
  }

  var stream = reader._ownerReadableStream;
  stream._disturbed = true;

  if (stream._state === 'errored') {
    return Promise.reject(stream._storedError);
  } // Controllers must implement this.


  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view, forAuthorCode);
}

function ReadableStreamDefaultReaderRead(reader, forAuthorCode) {
  if (forAuthorCode === void 0) {
    forAuthorCode = false;
  }

  var stream = reader._ownerReadableStream;
  stream._disturbed = true;

  if (stream._state === 'closed') {
    return Promise.resolve(ReadableStreamCreateReadResult(undefined, true, forAuthorCode));
  }

  if (stream._state === 'errored') {
    return Promise.reject(stream._storedError);
  }

  return stream._readableStreamController[PullSteps](forAuthorCode);
} // Controllers


var ReadableStreamDefaultController =
/*#__PURE__*/
function () {
  function ReadableStreamDefaultController() {
    throw new TypeError();
  }

  var _proto4 = ReadableStreamDefaultController.prototype;

  _proto4.close = function close() {
    if (IsReadableStreamDefaultController(this) === false) {
      throw defaultControllerBrandCheckException('close');
    }

    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {
      throw new TypeError('The stream is not in a state that permits close');
    }

    ReadableStreamDefaultControllerClose(this);
  };

  _proto4.enqueue = function enqueue(chunk) {
    if (IsReadableStreamDefaultController(this) === false) {
      throw defaultControllerBrandCheckException('enqueue');
    }

    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {
      throw new TypeError('The stream is not in a state that permits enqueue');
    }

    return ReadableStreamDefaultControllerEnqueue(this, chunk);
  };

  _proto4.error = function error(e) {
    if (IsReadableStreamDefaultController(this) === false) {
      throw defaultControllerBrandCheckException('error');
    }

    ReadableStreamDefaultControllerError(this, e);
  };

  _proto4[CancelSteps] = function (reason) {
    ResetQueue$2(this);

    var result = this._cancelAlgorithm(reason);

    ReadableStreamDefaultControllerClearAlgorithms(this);
    return result;
  };

  _proto4[PullSteps] = function (forAuthorCode) {
    var stream = this._controlledReadableStream;

    if (this._queue.length > 0) {
      var chunk = DequeueValue$2(this);

      if (this._closeRequested === true && this._queue.length === 0) {
        ReadableStreamDefaultControllerClearAlgorithms(this);
        ReadableStreamClose(stream);
      } else {
        ReadableStreamDefaultControllerCallPullIfNeeded(this);
      }

      return Promise.resolve(ReadableStreamCreateReadResult(chunk, false, forAuthorCode));
    }

    var pendingPromise = ReadableStreamAddReadRequest(stream, forAuthorCode);
    ReadableStreamDefaultControllerCallPullIfNeeded(this);
    return pendingPromise;
  };

  _createClass(ReadableStreamDefaultController, [{
    key: "desiredSize",
    get: function get() {
      if (IsReadableStreamDefaultController(this) === false) {
        throw defaultControllerBrandCheckException('desiredSize');
      }

      return ReadableStreamDefaultControllerGetDesiredSize(this);
    }
  }]);

  return ReadableStreamDefaultController;
}(); // Abstract operations for the ReadableStreamDefaultController.


function IsReadableStreamDefaultController(x) {
  if (!typeIsObject$1(x)) {
    return false;
  }

  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {
    return false;
  }

  return true;
}

function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
  var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);

  if (shouldPull === false) {
    return undefined;
  }

  if (controller._pulling === true) {
    controller._pullAgain = true;
    return undefined;
  }

  controller._pulling = true;

  var pullPromise = controller._pullAlgorithm();

  pullPromise.then(function () {
    controller._pulling = false;

    if (controller._pullAgain === true) {
      controller._pullAgain = false;
      return ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }

    return undefined;
  }, function (e) {
    ReadableStreamDefaultControllerError(controller, e);
  }).catch(rethrowAssertionErrorRejection$2);
  return undefined;
}

function ReadableStreamDefaultControllerShouldCallPull(controller) {
  var stream = controller._controlledReadableStream;

  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {
    return false;
  }

  if (controller._started === false) {
    return false;
  }

  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
    return true;
  }

  var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);

  if (desiredSize > 0) {
    return true;
  }

  return false;
}

function ReadableStreamDefaultControllerClearAlgorithms(controller) {
  controller._pullAlgorithm = undefined;
  controller._cancelAlgorithm = undefined;
  controller._strategySizeAlgorithm = undefined;
} // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.


function ReadableStreamDefaultControllerClose(controller) {
  var stream = controller._controlledReadableStream;
  controller._closeRequested = true;

  if (controller._queue.length === 0) {
    ReadableStreamDefaultControllerClearAlgorithms(controller);
    ReadableStreamClose(stream);
  }
}

function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
  var stream = controller._controlledReadableStream;

  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
    ReadableStreamFulfillReadRequest(stream, chunk, false);
  } else {
    var chunkSize;

    try {
      chunkSize = controller._strategySizeAlgorithm(chunk);
    } catch (chunkSizeE) {
      ReadableStreamDefaultControllerError(controller, chunkSizeE);
      throw chunkSizeE;
    }

    try {
      EnqueueValueWithSize$2(controller, chunk, chunkSize);
    } catch (enqueueE) {
      ReadableStreamDefaultControllerError(controller, enqueueE);
      throw enqueueE;
    }
  }

  ReadableStreamDefaultControllerCallPullIfNeeded(controller);
  return undefined;
}

function ReadableStreamDefaultControllerError(controller, e) {
  var stream = controller._controlledReadableStream;

  if (stream._state !== 'readable') {
    return;
  }

  ResetQueue$2(controller);
  ReadableStreamDefaultControllerClearAlgorithms(controller);
  ReadableStreamError(stream, e);
}

function ReadableStreamDefaultControllerGetDesiredSize(controller) {
  var stream = controller._controlledReadableStream;
  var state = stream._state;

  if (state === 'errored') {
    return null;
  }

  if (state === 'closed') {
    return 0;
  }

  return controller._strategyHWM - controller._queueTotalSize;
} // This is used in the implementation of TransformStream.


function ReadableStreamDefaultControllerHasBackpressure(controller) {
  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {
    return false;
  }

  return true;
}

function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
  var state = controller._controlledReadableStream._state;

  if (controller._closeRequested === false && state === 'readable') {
    return true;
  }

  return false;
}

function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
  controller._controlledReadableStream = stream;
  controller._queue = undefined;
  controller._queueTotalSize = undefined;
  ResetQueue$2(controller);
  controller._started = false;
  controller._closeRequested = false;
  controller._pullAgain = false;
  controller._pulling = false;
  controller._strategySizeAlgorithm = sizeAlgorithm;
  controller._strategyHWM = highWaterMark;
  controller._pullAlgorithm = pullAlgorithm;
  controller._cancelAlgorithm = cancelAlgorithm;
  stream._readableStreamController = controller;
  var startResult = startAlgorithm();
  Promise.resolve(startResult).then(function () {
    controller._started = true;
    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
  }, function (r) {
    ReadableStreamDefaultControllerError(controller, r);
  }).catch(rethrowAssertionErrorRejection$2);
}

function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
  var controller = Object.create(ReadableStreamDefaultController.prototype);

  function startAlgorithm() {
    return InvokeOrNoop$1(underlyingSource, 'start', [controller]);
  }

  var pullAlgorithm = CreateAlgorithmFromUnderlyingMethod$1(underlyingSource, 'pull', 0, [controller]);
  var cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod$1(underlyingSource, 'cancel', 1, []);
  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
}

var ReadableStreamBYOBRequest =
/*#__PURE__*/
function () {
  function ReadableStreamBYOBRequest() {
    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');
  }

  var _proto5 = ReadableStreamBYOBRequest.prototype;

  _proto5.respond = function respond(bytesWritten) {
    if (IsReadableStreamBYOBRequest(this) === false) {
      throw byobRequestBrandCheckException('respond');
    }

    if (this._associatedReadableByteStreamController === undefined) {
      throw new TypeError('This BYOB request has been invalidated');
    }

    if (IsDetachedBuffer$1(this._view.buffer) === true) {
      throw new TypeError('The BYOB request\'s buffer has been detached and so cannot be used as a response');
    }

    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
  };

  _proto5.respondWithNewView = function respondWithNewView(view) {
    if (IsReadableStreamBYOBRequest(this) === false) {
      throw byobRequestBrandCheckException('respond');
    }

    if (this._associatedReadableByteStreamController === undefined) {
      throw new TypeError('This BYOB request has been invalidated');
    }

    if (!ArrayBuffer.isView(view)) {
      throw new TypeError('You can only respond with array buffer views');
    }

    if (IsDetachedBuffer$1(view.buffer) === true) {
      throw new TypeError('The supplied view\'s buffer has been detached and so cannot be used as a response');
    }

    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
  };

  _createClass(ReadableStreamBYOBRequest, [{
    key: "view",
    get: function get() {
      if (IsReadableStreamBYOBRequest(this) === false) {
        throw byobRequestBrandCheckException('view');
      }

      return this._view;
    }
  }]);

  return ReadableStreamBYOBRequest;
}();

var ReadableByteStreamController =
/*#__PURE__*/
function () {
  function ReadableByteStreamController() {
    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');
  }

  var _proto6 = ReadableByteStreamController.prototype;

  _proto6.close = function close() {
    if (IsReadableByteStreamController(this) === false) {
      throw byteStreamControllerBrandCheckException('close');
    }

    if (this._closeRequested === true) {
      throw new TypeError('The stream has already been closed; do not close it again!');
    }

    var state = this._controlledReadableByteStream._state;

    if (state !== 'readable') {
      throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
    }

    ReadableByteStreamControllerClose(this);
  };

  _proto6.enqueue = function enqueue(chunk) {
    if (IsReadableByteStreamController(this) === false) {
      throw byteStreamControllerBrandCheckException('enqueue');
    }

    if (this._closeRequested === true) {
      throw new TypeError('stream is closed or draining');
    }

    var state = this._controlledReadableByteStream._state;

    if (state !== 'readable') {
      throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
    }

    if (!ArrayBuffer.isView(chunk)) {
      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');
    }

    if (IsDetachedBuffer$1(chunk.buffer) === true) {
      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');
    }

    ReadableByteStreamControllerEnqueue(this, chunk);
  };

  _proto6.error = function error(e) {
    if (IsReadableByteStreamController(this) === false) {
      throw byteStreamControllerBrandCheckException('error');
    }

    ReadableByteStreamControllerError(this, e);
  };

  _proto6[CancelSteps] = function (reason) {
    if (this._pendingPullIntos.length > 0) {
      var firstDescriptor = this._pendingPullIntos[0];
      firstDescriptor.bytesFilled = 0;
    }

    ResetQueue$2(this);

    var result = this._cancelAlgorithm(reason);

    ReadableByteStreamControllerClearAlgorithms(this);
    return result;
  };

  _proto6[PullSteps] = function (forAuthorCode) {
    var stream = this._controlledReadableByteStream;

    if (this._queueTotalSize > 0) {
      var entry = this._queue.shift();

      this._queueTotalSize -= entry.byteLength;
      ReadableByteStreamControllerHandleQueueDrain(this);
      var view;

      try {
        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
      } catch (viewE) {
        return Promise.reject(viewE);
      }

      return Promise.resolve(ReadableStreamCreateReadResult(view, false, forAuthorCode));
    }

    var autoAllocateChunkSize = this._autoAllocateChunkSize;

    if (autoAllocateChunkSize !== undefined) {
      var buffer;

      try {
        buffer = new ArrayBuffer(autoAllocateChunkSize);
      } catch (bufferE) {
        return Promise.reject(bufferE);
      }

      var pullIntoDescriptor = {
        buffer: buffer,
        byteOffset: 0,
        byteLength: autoAllocateChunkSize,
        bytesFilled: 0,
        elementSize: 1,
        ctor: Uint8Array,
        readerType: 'default'
      };

      this._pendingPullIntos.push(pullIntoDescriptor);
    }

    var promise = ReadableStreamAddReadRequest(stream, forAuthorCode);
    ReadableByteStreamControllerCallPullIfNeeded(this);
    return promise;
  };

  _createClass(ReadableByteStreamController, [{
    key: "byobRequest",
    get: function get() {
      if (IsReadableByteStreamController(this) === false) {
        throw byteStreamControllerBrandCheckException('byobRequest');
      }

      if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {
        var firstDescriptor = this._pendingPullIntos[0];
        var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
        var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
        SetUpReadableStreamBYOBRequest(byobRequest, this, view);
        this._byobRequest = byobRequest;
      }

      return this._byobRequest;
    }
  }, {
    key: "desiredSize",
    get: function get() {
      if (IsReadableByteStreamController(this) === false) {
        throw byteStreamControllerBrandCheckException('desiredSize');
      }

      return ReadableByteStreamControllerGetDesiredSize(this);
    }
  }]);

  return ReadableByteStreamController;
}(); // Abstract operations for the ReadableByteStreamController.


function IsReadableByteStreamController(x) {
  if (!typeIsObject$1(x)) {
    return false;
  }

  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {
    return false;
  }

  return true;
}

function IsReadableStreamBYOBRequest(x) {
  if (!typeIsObject$1(x)) {
    return false;
  }

  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
    return false;
  }

  return true;
}

function ReadableByteStreamControllerCallPullIfNeeded(controller) {
  var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);

  if (shouldPull === false) {
    return undefined;
  }

  if (controller._pulling === true) {
    controller._pullAgain = true;
    return undefined;
  }

  controller._pulling = true; // TODO: Test controller argument

  var pullPromise = controller._pullAlgorithm();

  pullPromise.then(function () {
    controller._pulling = false;

    if (controller._pullAgain === true) {
      controller._pullAgain = false;
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
  }, function (e) {
    ReadableByteStreamControllerError(controller, e);
  }).catch(rethrowAssertionErrorRejection$2);
  return undefined;
}

function ReadableByteStreamControllerClearPendingPullIntos(controller) {
  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  controller._pendingPullIntos = [];
}

function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
  var done = false;

  if (stream._state === 'closed') {
    done = true;
  }

  var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);

  if (pullIntoDescriptor.readerType === 'default') {
    ReadableStreamFulfillReadRequest(stream, filledView, done);
  } else {
    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
  }
}

function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
  var bytesFilled = pullIntoDescriptor.bytesFilled;
  var elementSize = pullIntoDescriptor.elementSize;
  return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
}

function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
  controller._queue.push({
    buffer: buffer,
    byteOffset: byteOffset,
    byteLength: byteLength
  });

  controller._queueTotalSize += byteLength;
}

function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
  var elementSize = pullIntoDescriptor.elementSize;
  var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
  var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
  var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
  var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
  var totalBytesToCopyRemaining = maxBytesToCopy;
  var ready = false;

  if (maxAlignedBytes > currentAlignedBytes) {
    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
    ready = true;
  }

  var queue = controller._queue;

  while (totalBytesToCopyRemaining > 0) {
    var headOfQueue = queue[0];
    var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
    var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);

    if (headOfQueue.byteLength === bytesToCopy) {
      queue.shift();
    } else {
      headOfQueue.byteOffset += bytesToCopy;
      headOfQueue.byteLength -= bytesToCopy;
    }

    controller._queueTotalSize -= bytesToCopy;
    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
    totalBytesToCopyRemaining -= bytesToCopy;
  }

  return ready;
}

function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  pullIntoDescriptor.bytesFilled += size;
}

function ReadableByteStreamControllerHandleQueueDrain(controller) {
  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {
    ReadableByteStreamControllerClearAlgorithms(controller);
    ReadableStreamClose(controller._controlledReadableByteStream);
  } else {
    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }
}

function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
  if (controller._byobRequest === undefined) {
    return;
  }

  controller._byobRequest._associatedReadableByteStreamController = undefined;
  controller._byobRequest._view = undefined;
  controller._byobRequest = undefined;
}

function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
  while (controller._pendingPullIntos.length > 0) {
    if (controller._queueTotalSize === 0) {
      return;
    }

    var pullIntoDescriptor = controller._pendingPullIntos[0];

    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
      ReadableByteStreamControllerShiftPendingPullInto(controller);
      ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
    }
  }
}

function ReadableByteStreamControllerPullInto(controller, view, forAuthorCode) {
  var stream = controller._controlledReadableByteStream;
  var elementSize = 1;

  if (view.constructor !== DataView) {
    elementSize = view.constructor.BYTES_PER_ELEMENT;
  }

  var ctor = view.constructor;
  var buffer = TransferArrayBuffer$1(view.buffer);
  var pullIntoDescriptor = {
    buffer: buffer,
    byteOffset: view.byteOffset,
    byteLength: view.byteLength,
    bytesFilled: 0,
    elementSize: elementSize,
    ctor: ctor,
    readerType: 'byob'
  };

  if (controller._pendingPullIntos.length > 0) {
    controller._pendingPullIntos.push(pullIntoDescriptor); // No ReadableByteStreamControllerCallPullIfNeeded() call since:
    // - No change happens on desiredSize
    // - The source has already been notified of that there's at least 1 pending read(view)


    return ReadableStreamAddReadIntoRequest(stream, forAuthorCode);
  }

  if (stream._state === 'closed') {
    var emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
    return Promise.resolve(ReadableStreamCreateReadResult(emptyView, true, forAuthorCode));
  }

  if (controller._queueTotalSize > 0) {
    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
      var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
      ReadableByteStreamControllerHandleQueueDrain(controller);
      return Promise.resolve(ReadableStreamCreateReadResult(filledView, false, forAuthorCode));
    }

    if (controller._closeRequested === true) {
      var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
      ReadableByteStreamControllerError(controller, e);
      return Promise.reject(e);
    }
  }

  controller._pendingPullIntos.push(pullIntoDescriptor);

  var promise = ReadableStreamAddReadIntoRequest(stream, forAuthorCode);
  ReadableByteStreamControllerCallPullIfNeeded(controller);
  return promise;
}

function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
  firstDescriptor.buffer = TransferArrayBuffer$1(firstDescriptor.buffer);
  var stream = controller._controlledReadableByteStream;

  if (ReadableStreamHasBYOBReader(stream) === true) {
    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
      var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
    }
  }
}

function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {
    throw new RangeError('bytesWritten out of range');
  }

  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);

  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
    // TODO: Figure out whether we should detach the buffer or not here.
    return;
  }

  ReadableByteStreamControllerShiftPendingPullInto(controller);
  var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;

  if (remainderSize > 0) {
    var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
    var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);
    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
  }

  pullIntoDescriptor.buffer = TransferArrayBuffer$1(pullIntoDescriptor.buffer);
  pullIntoDescriptor.bytesFilled -= remainderSize;
  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
}

function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
  var firstDescriptor = controller._pendingPullIntos[0];
  var stream = controller._controlledReadableByteStream;

  if (stream._state === 'closed') {
    if (bytesWritten !== 0) {
      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
    }

    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
  } else {
    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
  }

  ReadableByteStreamControllerCallPullIfNeeded(controller);
}

function ReadableByteStreamControllerShiftPendingPullInto(controller) {
  var descriptor = controller._pendingPullIntos.shift();

  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  return descriptor;
}

function ReadableByteStreamControllerShouldCallPull(controller) {
  var stream = controller._controlledReadableByteStream;

  if (stream._state !== 'readable') {
    return false;
  }

  if (controller._closeRequested === true) {
    return false;
  }

  if (controller._started === false) {
    return false;
  }

  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
    return true;
  }

  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
    return true;
  }

  var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);

  if (desiredSize > 0) {
    return true;
  }

  return false;
}

function ReadableByteStreamControllerClearAlgorithms(controller) {
  controller._pullAlgorithm = undefined;
  controller._cancelAlgorithm = undefined;
} // A client of ReadableByteStreamController may use these functions directly to bypass state check.


function ReadableByteStreamControllerClose(controller) {
  var stream = controller._controlledReadableByteStream;

  if (controller._queueTotalSize > 0) {
    controller._closeRequested = true;
    return;
  }

  if (controller._pendingPullIntos.length > 0) {
    var firstPendingPullInto = controller._pendingPullIntos[0];

    if (firstPendingPullInto.bytesFilled > 0) {
      var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
      ReadableByteStreamControllerError(controller, e);
      throw e;
    }
  }

  ReadableByteStreamControllerClearAlgorithms(controller);
  ReadableStreamClose(stream);
}

function ReadableByteStreamControllerEnqueue(controller, chunk) {
  var stream = controller._controlledReadableByteStream;
  var buffer = chunk.buffer;
  var byteOffset = chunk.byteOffset;
  var byteLength = chunk.byteLength;
  var transferredBuffer = TransferArrayBuffer$1(buffer);

  if (ReadableStreamHasDefaultReader(stream) === true) {
    if (ReadableStreamGetNumReadRequests(stream) === 0) {
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
    } else {
      var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
      ReadableStreamFulfillReadRequest(stream, transferredView, false);
    }
  } else if (ReadableStreamHasBYOBReader(stream) === true) {
    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.
    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
  } else {
    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
  }

  ReadableByteStreamControllerCallPullIfNeeded(controller);
}

function ReadableByteStreamControllerError(controller, e) {
  var stream = controller._controlledReadableByteStream;

  if (stream._state !== 'readable') {
    return;
  }

  ReadableByteStreamControllerClearPendingPullIntos(controller);
  ResetQueue$2(controller);
  ReadableByteStreamControllerClearAlgorithms(controller);
  ReadableStreamError(stream, e);
}

function ReadableByteStreamControllerGetDesiredSize(controller) {
  var stream = controller._controlledReadableByteStream;
  var state = stream._state;

  if (state === 'errored') {
    return null;
  }

  if (state === 'closed') {
    return 0;
  }

  return controller._strategyHWM - controller._queueTotalSize;
}

function ReadableByteStreamControllerRespond(controller, bytesWritten) {
  bytesWritten = Number(bytesWritten);

  if (IsFiniteNonNegativeNumber$1(bytesWritten) === false) {
    throw new RangeError('bytesWritten must be a finite');
  }

  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
}

function ReadableByteStreamControllerRespondWithNewView(controller, view) {
  var firstDescriptor = controller._pendingPullIntos[0];

  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
    throw new RangeError('The region specified by view does not match byobRequest');
  }

  if (firstDescriptor.byteLength !== view.byteLength) {
    throw new RangeError('The buffer of view has different capacity than byobRequest');
  }

  firstDescriptor.buffer = view.buffer;
  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
}

function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {

  controller._controlledReadableByteStream = stream;
  controller._pullAgain = false;
  controller._pulling = false;
  ReadableByteStreamControllerClearPendingPullIntos(controller); // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.

  controller._queue = controller._queueTotalSize = undefined;
  ResetQueue$2(controller);
  controller._closeRequested = false;
  controller._started = false;
  controller._strategyHWM = ValidateAndNormalizeHighWaterMark$1(highWaterMark);
  controller._pullAlgorithm = pullAlgorithm;
  controller._cancelAlgorithm = cancelAlgorithm;
  controller._autoAllocateChunkSize = autoAllocateChunkSize;
  controller._pendingPullIntos = [];
  stream._readableStreamController = controller;
  var startResult = startAlgorithm();
  Promise.resolve(startResult).then(function () {
    controller._started = true;
    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }, function (r) {
    ReadableByteStreamControllerError(controller, r);
  }).catch(rethrowAssertionErrorRejection$2);
}

function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
  var controller = Object.create(ReadableByteStreamController.prototype);

  function startAlgorithm() {
    return InvokeOrNoop$1(underlyingByteSource, 'start', [controller]);
  }

  var pullAlgorithm = CreateAlgorithmFromUnderlyingMethod$1(underlyingByteSource, 'pull', 0, [controller]);
  var cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod$1(underlyingByteSource, 'cancel', 1, []);
  var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;

  if (autoAllocateChunkSize !== undefined) {
    autoAllocateChunkSize = Number(autoAllocateChunkSize);

    if (NumberIsInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {
      throw new RangeError('autoAllocateChunkSize must be a positive integer');
    }
  }

  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
}

function SetUpReadableStreamBYOBRequest(request, controller, view) {
  request._associatedReadableByteStreamController = controller;
  request._view = view;
} // Helper functions for the ReadableStream.


function isAbortSignal(value) {
  if (typeof value !== 'object' || value === null) {
    return false;
  } // Use the brand check to distinguish a real AbortSignal from a fake one.


  var aborted = Object.getOwnPropertyDescriptor(AbortSignal.prototype, 'aborted').get;

  try {
    aborted.call(value);
    return true;
  } catch (e) {
    return false;
  }
}

function streamBrandCheckException$1(name) {
  return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
} // Helper functions for the readers.


function readerLockException(name) {
  return new TypeError('Cannot ' + name + ' a stream using a released reader');
} // Helper functions for the ReadableStreamDefaultReader.


function defaultReaderBrandCheckException(name) {
  return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
}

function defaultReaderClosedPromiseInitialize(reader) {
  reader._closedPromise = new Promise(function (resolve, reject) {
    reader._closedPromise_resolve = resolve;
    reader._closedPromise_reject = reject;
  });
}

function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
  reader._closedPromise = Promise.reject(reason);
  reader._closedPromise_resolve = undefined;
  reader._closedPromise_reject = undefined;
}

function defaultReaderClosedPromiseInitializeAsResolved(reader) {
  reader._closedPromise = Promise.resolve(undefined);
  reader._closedPromise_resolve = undefined;
  reader._closedPromise_reject = undefined;
}

function defaultReaderClosedPromiseReject(reader, reason) {
  reader._closedPromise_reject(reason);

  reader._closedPromise_resolve = undefined;
  reader._closedPromise_reject = undefined;
}

function defaultReaderClosedPromiseResetToRejected(reader, reason) {
  reader._closedPromise = Promise.reject(reason);
}

function defaultReaderClosedPromiseResolve(reader) {
  reader._closedPromise_resolve(undefined);

  reader._closedPromise_resolve = undefined;
  reader._closedPromise_reject = undefined;
} // Helper functions for the ReadableStreamDefaultReader.


function byobReaderBrandCheckException(name) {
  return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
} // Helper functions for the ReadableStreamDefaultController.


function defaultControllerBrandCheckException(name) {
  return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
} // Helper functions for the ReadableStreamBYOBRequest.


function byobRequestBrandCheckException(name) {
  return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
} // Helper functions for the ReadableByteStreamController.


function byteStreamControllerBrandCheckException(name) {
  return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
}
var readableStream_3 = readableStream.ReadableStream;

var createDataProperty = require$$0.createDataProperty;

var byteLengthQueuingStrategy =
/*#__PURE__*/
function () {
  function ByteLengthQueuingStrategy(_ref) {
    var highWaterMark = _ref.highWaterMark;
    createDataProperty(this, 'highWaterMark', highWaterMark);
  }

  var _proto = ByteLengthQueuingStrategy.prototype;

  _proto.size = function size(chunk) {
    return chunk.byteLength;
  };

  return ByteLengthQueuingStrategy;
}();

var createDataProperty$1 = require$$0.createDataProperty;

var countQueuingStrategy =
/*#__PURE__*/
function () {
  function CountQueuingStrategy(_ref) {
    var highWaterMark = _ref.highWaterMark;
    createDataProperty$1(this, 'highWaterMark', highWaterMark);
  }

  var _proto = CountQueuingStrategy.prototype;

  _proto.size = function size() {
    return 1;
  };

  return CountQueuingStrategy;
}();

// and do not appear in the standard text.


var verbose$1 = require$$0$1('streams:transform-stream:verbose');
var InvokeOrNoop$2 = require$$0.InvokeOrNoop,
    CreateAlgorithmFromUnderlyingMethod$2 = require$$0.CreateAlgorithmFromUnderlyingMethod,
    PromiseCall = require$$0.PromiseCall,
    typeIsObject$2 = require$$0.typeIsObject,
    ValidateAndNormalizeHighWaterMark$2 = require$$0.ValidateAndNormalizeHighWaterMark,
    IsNonNegativeNumber$2 = require$$0.IsNonNegativeNumber,
    MakeSizeAlgorithmFromSizeFunction$2 = require$$0.MakeSizeAlgorithmFromSizeFunction;
var CreateReadableStream$1 = readableStream.CreateReadableStream,
    ReadableStreamDefaultControllerClose$1 = readableStream.ReadableStreamDefaultControllerClose,
    ReadableStreamDefaultControllerEnqueue$1 = readableStream.ReadableStreamDefaultControllerEnqueue,
    ReadableStreamDefaultControllerError$1 = readableStream.ReadableStreamDefaultControllerError,
    ReadableStreamDefaultControllerGetDesiredSize$1 = readableStream.ReadableStreamDefaultControllerGetDesiredSize,
    ReadableStreamDefaultControllerHasBackpressure$1 = readableStream.ReadableStreamDefaultControllerHasBackpressure,
    ReadableStreamDefaultControllerCanCloseOrEnqueue$1 = readableStream.ReadableStreamDefaultControllerCanCloseOrEnqueue;
var CreateWritableStream$1 = writableStream.CreateWritableStream,
    WritableStreamDefaultControllerErrorIfNeeded$1 = writableStream.WritableStreamDefaultControllerErrorIfNeeded; // Class TransformStream

var TransformStream =
/*#__PURE__*/
function () {
  function TransformStream(transformer, writableStrategy, readableStrategy) {
    if (transformer === void 0) {
      transformer = {};
    }

    if (writableStrategy === void 0) {
      writableStrategy = {};
    }

    if (readableStrategy === void 0) {
      readableStrategy = {};
    }

    var writableSizeFunction = writableStrategy.size;
    var writableHighWaterMark = writableStrategy.highWaterMark;
    var readableSizeFunction = readableStrategy.size;
    var readableHighWaterMark = readableStrategy.highWaterMark;
    var writableType = transformer.writableType;

    if (writableType !== undefined) {
      throw new RangeError('Invalid writable type specified');
    }

    var writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction$2(writableSizeFunction);

    if (writableHighWaterMark === undefined) {
      writableHighWaterMark = 1;
    }

    writableHighWaterMark = ValidateAndNormalizeHighWaterMark$2(writableHighWaterMark);
    var readableType = transformer.readableType;

    if (readableType !== undefined) {
      throw new RangeError('Invalid readable type specified');
    }

    var readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction$2(readableSizeFunction);

    if (readableHighWaterMark === undefined) {
      readableHighWaterMark = 0;
    }

    readableHighWaterMark = ValidateAndNormalizeHighWaterMark$2(readableHighWaterMark);
    var startPromise_resolve;
    var startPromise = new Promise(function (resolve) {
      startPromise_resolve = resolve;
    });
    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
    var startResult = InvokeOrNoop$2(transformer, 'start', [this._transformStreamController]);
    startPromise_resolve(startResult);
  }

  _createClass(TransformStream, [{
    key: "readable",
    get: function get() {
      if (IsTransformStream(this) === false) {
        throw streamBrandCheckException$2('readable');
      }

      return this._readable;
    }
  }, {
    key: "writable",
    get: function get() {
      if (IsTransformStream(this) === false) {
        throw streamBrandCheckException$2('writable');
      }

      return this._writable;
    }
  }]);

  return TransformStream;
}(); // Transform Stream Abstract Operations


function CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
  if (writableHighWaterMark === void 0) {
    writableHighWaterMark = 1;
  }

  if (writableSizeAlgorithm === void 0) {
    writableSizeAlgorithm = function writableSizeAlgorithm() {
      return 1;
    };
  }

  if (readableHighWaterMark === void 0) {
    readableHighWaterMark = 0;
  }

  if (readableSizeAlgorithm === void 0) {
    readableSizeAlgorithm = function readableSizeAlgorithm() {
      return 1;
    };
  }

  var stream = Object.create(TransformStream.prototype);
  var startPromise_resolve;
  var startPromise = new Promise(function (resolve) {
    startPromise_resolve = resolve;
  });
  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
  var controller = Object.create(TransformStreamDefaultController.prototype);
  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
  var startResult = startAlgorithm();
  startPromise_resolve(startResult);
  return stream;
}

function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
  function startAlgorithm() {
    return startPromise;
  }

  function writeAlgorithm(chunk) {
    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
  }

  function abortAlgorithm(reason) {
    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
  }

  function closeAlgorithm() {
    return TransformStreamDefaultSinkCloseAlgorithm(stream);
  }

  stream._writable = CreateWritableStream$1(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);

  function pullAlgorithm() {
    return TransformStreamDefaultSourcePullAlgorithm(stream);
  }

  function cancelAlgorithm(reason) {
    TransformStreamErrorWritableAndUnblockWrite(stream, reason);
    return Promise.resolve();
  }

  stream._readable = CreateReadableStream$1(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm); // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.

  stream._backpressure = undefined;
  stream._backpressureChangePromise = undefined;
  stream._backpressureChangePromise_resolve = undefined;
  TransformStreamSetBackpressure(stream, true); // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().

  stream._transformStreamController = undefined;
}

function IsTransformStream(x) {
  if (!typeIsObject$2(x)) {
    return false;
  }

  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
    return false;
  }

  return true;
} // This is a no-op if both sides are already errored.


function TransformStreamError(stream, e) {
  ReadableStreamDefaultControllerError$1(stream._readable._readableStreamController, e);
  TransformStreamErrorWritableAndUnblockWrite(stream, e);
}

function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
  WritableStreamDefaultControllerErrorIfNeeded$1(stream._writable._writableStreamController, e);

  if (stream._backpressure === true) {
    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()
    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time
    // _backpressure is set.
    TransformStreamSetBackpressure(stream, false);
  }
}

function TransformStreamSetBackpressure(stream, backpressure) {
  // Passes also when called during construction.
  if (stream._backpressureChangePromise !== undefined) {
    stream._backpressureChangePromise_resolve();
  }

  stream._backpressureChangePromise = new Promise(function (resolve) {
    stream._backpressureChangePromise_resolve = resolve;
  });
  stream._backpressure = backpressure;
} // Class TransformStreamDefaultController


var TransformStreamDefaultController =
/*#__PURE__*/
function () {
  function TransformStreamDefaultController() {
    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');
  }

  var _proto = TransformStreamDefaultController.prototype;

  _proto.enqueue = function enqueue(chunk) {
    if (IsTransformStreamDefaultController(this) === false) {
      throw defaultControllerBrandCheckException$1('enqueue');
    }

    TransformStreamDefaultControllerEnqueue(this, chunk);
  };

  _proto.error = function error(reason) {
    if (IsTransformStreamDefaultController(this) === false) {
      throw defaultControllerBrandCheckException$1('error');
    }

    TransformStreamDefaultControllerError(this, reason);
  };

  _proto.terminate = function terminate() {
    if (IsTransformStreamDefaultController(this) === false) {
      throw defaultControllerBrandCheckException$1('terminate');
    }

    TransformStreamDefaultControllerTerminate(this);
  };

  _createClass(TransformStreamDefaultController, [{
    key: "desiredSize",
    get: function get() {
      if (IsTransformStreamDefaultController(this) === false) {
        throw defaultControllerBrandCheckException$1('desiredSize');
      }

      var readableController = this._controlledTransformStream._readable._readableStreamController;
      return ReadableStreamDefaultControllerGetDesiredSize$1(readableController);
    }
  }]);

  return TransformStreamDefaultController;
}(); // Transform Stream Default Controller Abstract Operations


function IsTransformStreamDefaultController(x) {
  if (!typeIsObject$2(x)) {
    return false;
  }

  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
    return false;
  }

  return true;
}

function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
  controller._controlledTransformStream = stream;
  stream._transformStreamController = controller;
  controller._transformAlgorithm = transformAlgorithm;
  controller._flushAlgorithm = flushAlgorithm;
}

function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
  var controller = Object.create(TransformStreamDefaultController.prototype);

  var transformAlgorithm = function transformAlgorithm(chunk) {
    try {
      TransformStreamDefaultControllerEnqueue(controller, chunk);
      return Promise.resolve();
    } catch (transformResultE) {
      return Promise.reject(transformResultE);
    }
  };

  var transformMethod = transformer.transform;

  if (transformMethod !== undefined) {
    if (typeof transformMethod !== 'function') {
      throw new TypeError('transform is not a method');
    }

    transformAlgorithm = function transformAlgorithm(chunk) {
      return PromiseCall(transformMethod, transformer, [chunk, controller]);
    };
  }

  var flushAlgorithm = CreateAlgorithmFromUnderlyingMethod$2(transformer, 'flush', 0, [controller]);
  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
}

function TransformStreamDefaultControllerClearAlgorithms(controller) {
  controller._transformAlgorithm = undefined;
  controller._flushAlgorithm = undefined;
}

function TransformStreamDefaultControllerEnqueue(controller, chunk) {
  var stream = controller._controlledTransformStream;
  var readableController = stream._readable._readableStreamController;

  if (ReadableStreamDefaultControllerCanCloseOrEnqueue$1(readableController) === false) {
    throw new TypeError('Readable side is not in a state that permits enqueue');
  } // We throttle transform invocations based on the backpressure of the ReadableStream, but we still
  // accept TransformStreamDefaultControllerEnqueue() calls.


  try {
    ReadableStreamDefaultControllerEnqueue$1(readableController, chunk);
  } catch (e) {
    // This happens when readableStrategy.size() throws.
    TransformStreamErrorWritableAndUnblockWrite(stream, e);
    throw stream._readable._storedError;
  }

  var backpressure = ReadableStreamDefaultControllerHasBackpressure$1(readableController);

  if (backpressure !== stream._backpressure) {
    TransformStreamSetBackpressure(stream, true);
  }
}

function TransformStreamDefaultControllerError(controller, e) {
  TransformStreamError(controller._controlledTransformStream, e);
}

function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
  var transformPromise = controller._transformAlgorithm(chunk);

  return transformPromise.catch(function (r) {
    TransformStreamError(controller._controlledTransformStream, r);
    throw r;
  });
}

function TransformStreamDefaultControllerTerminate(controller) {
  var stream = controller._controlledTransformStream;
  var readableController = stream._readable._readableStreamController;

  if (ReadableStreamDefaultControllerCanCloseOrEnqueue$1(readableController) === true) {
    ReadableStreamDefaultControllerClose$1(readableController);
  }

  var error = new TypeError('TransformStream terminated');
  TransformStreamErrorWritableAndUnblockWrite(stream, error);
} // TransformStreamDefaultSink Algorithms


function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
  var controller = stream._transformStreamController;

  if (stream._backpressure === true) {
    var backpressureChangePromise = stream._backpressureChangePromise;
    return backpressureChangePromise.then(function () {
      var writable = stream._writable;
      var state = writable._state;

      if (state === 'erroring') {
        throw writable._storedError;
      }

      return TransformStreamDefaultControllerPerformTransform(controller, chunk);
    });
  }

  return TransformStreamDefaultControllerPerformTransform(controller, chunk);
}

function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already
  // errored.
  TransformStreamError(stream, reason);
  return Promise.resolve();
}

function TransformStreamDefaultSinkCloseAlgorithm(stream) {
  // stream._readable cannot change after construction, so caching it across a call to user code is safe.
  var readable = stream._readable;
  var controller = stream._transformStreamController;

  var flushPromise = controller._flushAlgorithm();

  TransformStreamDefaultControllerClearAlgorithms(controller); // Return a promise that is fulfilled with undefined on success.

  return flushPromise.then(function () {
    if (readable._state === 'errored') {
      throw readable._storedError;
    }

    var readableController = readable._readableStreamController;

    if (ReadableStreamDefaultControllerCanCloseOrEnqueue$1(readableController) === true) {
      ReadableStreamDefaultControllerClose$1(readableController);
    }
  }).catch(function (r) {
    TransformStreamError(stream, r);
    throw readable._storedError;
  });
} // TransformStreamDefaultSource Algorithms


function TransformStreamDefaultSourcePullAlgorithm(stream) {
  // Invariant. Enforced by the promises returned by start() and pull().
  TransformStreamSetBackpressure(stream, false); // Prevent the next pull() call until there is backpressure.

  return stream._backpressureChangePromise;
}

var transformStream = {
  CreateTransformStream: CreateTransformStream,
  TransformStream: TransformStream
}; // Helper functions for the TransformStreamDefaultController.

function defaultControllerBrandCheckException$1(name) {
  return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
} // Helper functions for the TransformStream.


function streamBrandCheckException$2(name) {
  return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
}
var transformStream_2 = transformStream.TransformStream;

var exports$1 = {
  ReadableStream: readableStream_3,
  WritableStream: writableStream_5,
  ByteLengthQueuingStrategy: byteLengthQueuingStrategy,
  CountQueuingStrategy: countQueuingStrategy,
  TransformStream: transformStream_2
}; // Add classes to global scope

if (typeof globals !== 'undefined') {
  _extends(globals, exports$1);
}

export { readableStream_3 as ReadableStream, writableStream_5 as WritableStream, byteLengthQueuingStrategy as ByteLengthQueuingStrategy, countQueuingStrategy as CountQueuingStrategy, transformStream_2 as TransformStream };
//# sourceMappingURL=polyfill.mjs.map
