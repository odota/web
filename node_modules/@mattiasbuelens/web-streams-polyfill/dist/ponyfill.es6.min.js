!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e=e||self).WebStreamsPolyfill={})}(this,function(e){"use strict";const r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol:e=>`Symbol(${e})`,t=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e};function o(){}var n={default:o};const a=Number.isNaN||function(e){return e!=e};function i(e){return e&&e.default||e}i(n);var s=function(e,r){return e(r={exports:{}},r.exports),r.exports}(function(e,t){const o=r('is "detached" for our purposes');function n(e,r,t){if("function"!=typeof e)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,r,t)}function i(e,r,t){try{return Promise.resolve(n(e,r,t))}catch(e){return Promise.reject(e)}}t.typeIsObject=(e=>"object"==typeof e&&null!==e||"function"==typeof e),t.createDataProperty=((e,r,t)=>{Object.defineProperty(e,r,{value:t,writable:!0,enumerable:!0,configurable:!0})}),t.createArrayFromList=(e=>e.slice()),t.ArrayBufferCopy=((e,r,t,o,n)=>{new Uint8Array(e).set(new Uint8Array(t,o,n),r)}),t.IsFiniteNonNegativeNumber=(e=>!1!==t.IsNonNegativeNumber(e)&&e!==1/0),t.IsNonNegativeNumber=(e=>"number"==typeof e&&(!a(e)&&!(e<0))),t.Call=n,t.CreateAlgorithmFromUnderlyingMethod=((e,r,t,o)=>{const n=e[r];if(void 0!==n){if("function"!=typeof n)throw new TypeError(`${n} is not a method`);switch(t){case 0:return()=>i(n,e,o);case 1:return r=>{const t=[r].concat(o);return i(n,e,t)}}}return()=>Promise.resolve()}),t.InvokeOrNoop=((e,r,t)=>{const o=e[r];if(void 0!==o)return n(o,e,t)}),t.PromiseCall=i,t.TransferArrayBuffer=(e=>{const r=e.slice();return Object.defineProperty(e,"byteLength",{get:()=>0}),e[o]=!0,r}),t.IsDetachedBuffer=(e=>o in e),t.ValidateAndNormalizeHighWaterMark=(e=>{if(e=Number(e),a(e)||e<0)throw new RangeError("highWaterMark property of a queuing strategy must be non-negative and non-NaN");return e}),t.MakeSizeAlgorithmFromSizeFunction=(e=>{if(void 0===e)return()=>1;if("function"!=typeof e)throw new TypeError("size property of a queuing strategy must be a function");return r=>e(r)}),t.PerformPromiseThen=((e,r,t)=>Promise.prototype.then.call(e,r,t)),t.WaitForAll=((e,r,o)=>{let n=!1;const a=e=>{!1===n&&(n=!0,o(e))};let i=0,s=0;const l=e.length,c=new Array(l);for(const o of e){const e=i,n=t=>{c[e]=t,++s===l&&r(c)};t.PerformPromiseThen(o,n,a),++i}}),t.WaitForAllPromise=((e,r,o)=>{let n,a;const i=new Promise((e,r)=>{n=e,a=r});void 0===o&&(o=(e=>{throw e}));return t.WaitForAll(e,e=>{try{const t=r(e);n(t)}catch(e){a(e)}},e=>{try{const r=o(e);n(r)}catch(e){a(e)}}),i})}),l=s.typeIsObject,c=s.createDataProperty,u=s.createArrayFromList,d=s.ArrayBufferCopy,f=s.IsFiniteNonNegativeNumber,m=s.IsNonNegativeNumber,h=s.Call,_=s.CreateAlgorithmFromUnderlyingMethod,b=s.InvokeOrNoop,y=s.PromiseCall;s.TransferArrayBuffer,s.IsDetachedBuffer;var p={TransferArrayBuffer:function(e){return e},IsDetachedBuffer:function(e){return!1},typeIsObject:l,createDataProperty:c,createArrayFromList:u,ArrayBufferCopy:d,IsFiniteNonNegativeNumber:f,IsNonNegativeNumber:m,Call:h,CreateAlgorithmFromUnderlyingMethod:_,InvokeOrNoop:b,PromiseCall:y,ValidateAndNormalizeHighWaterMark:s.ValidateAndNormalizeHighWaterMark,MakeSizeAlgorithmFromSizeFunction:s.MakeSizeAlgorithmFromSizeFunction,PerformPromiseThen:s.PerformPromiseThen,WaitForAll:s.WaitForAll,WaitForAllPromise:s.WaitForAllPromise};function w(){}w.AssertionError=o;var S=i({default:w}),g={rethrowAssertionErrorRejection:e=>{e&&e instanceof S.AssertionError&&setTimeout(()=>{throw e},0)}},v=i(p);const{IsFiniteNonNegativeNumber:P}=v;var R={DequeueValue:e=>{const r=e._queue.shift();return e._queueTotalSize-=r.size,e._queueTotalSize<0&&(e._queueTotalSize=0),r.value},EnqueueValueWithSize:(e,r,t)=>{if(t=Number(t),!P(t))throw new RangeError("Size must be a finite, non-NaN, non-negative number.");e._queue.push({value:r,size:t}),e._queueTotalSize+=t},PeekQueueValue:e=>{return e._queue[0].value},ResetQueue:e=>{e._queue=[],e._queueTotalSize=0}},T=i({default:o});T("streams:writable-stream:verbose");const{CreateAlgorithmFromUnderlyingMethod:C,InvokeOrNoop:q,ValidateAndNormalizeHighWaterMark:A,IsNonNegativeNumber:E,MakeSizeAlgorithmFromSizeFunction:j,typeIsObject:W}=v,{rethrowAssertionErrorRejection:O}=g,{DequeueValue:B,EnqueueValueWithSize:z,PeekQueueValue:k,ResetQueue:F}=R,I=r("[[AbortSteps]]"),D=r("[[ErrorSteps]]");class WritableStream{constructor(e={},r={}){L(this);const t=r.size;let o=r.highWaterMark;if(void 0!==e.type)throw new RangeError("Invalid type is specified");const n=j(t);void 0===o&&(o=1),function(e,r,t,o){const n=Object.create(WritableStreamDefaultController.prototype);const a=C(r,"write",1,[n]),i=C(r,"close",0,[]),s=C(r,"abort",1,[]);ne(e,n,function(){return q(r,"start",[n])},a,i,s,t,o)}(this,e,o=A(o),n)}get locked(){if(!1===V(this))throw de("locked");return Y(this)}abort(e){return!1===V(this)?Promise.reject(de("abort")):!0===Y(this)?Promise.reject(new TypeError("Cannot abort a stream that already has a writer")):$(this,e)}getWriter(){if(!1===V(this))throw de("getWriter");return M(this)}}var N={AcquireWritableStreamDefaultWriter:M,CreateWritableStream:function(e,r,t,o,n=1,a=(()=>1)){const i=Object.create(WritableStream.prototype);L(i);const s=Object.create(WritableStreamDefaultController.prototype);return ne(i,s,e,r,t,o,n,a),i},IsWritableStream:V,IsWritableStreamLocked:Y,WritableStream:WritableStream,WritableStreamAbort:$,WritableStreamDefaultControllerErrorIfNeeded:le,WritableStreamDefaultWriterCloseWithErrorPropagation:function(e){const r=e._ownerWritableStream,t=r._state;if(!0===G(r)||"closed"===t)return Promise.resolve();if("errored"===t)return Promise.reject(r._storedError);return Z(e)},WritableStreamDefaultWriterRelease:te,WritableStreamDefaultWriterWrite:oe,WritableStreamCloseQueuedOrInFlight:G};function M(e){return new WritableStreamDefaultWriter(e)}function L(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=[],e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=!1}function V(e){return!!W(e)&&!!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")}function Y(e){return void 0!==e._writer}function $(e,r){const t=e._state;if("closed"===t||"errored"===t)return Promise.resolve(void 0);if(void 0!==e._pendingAbortRequest)return e._pendingAbortRequest._promise;let o=!1;"erroring"===t&&(o=!0,r=void 0);const n=new Promise((t,n)=>{e._pendingAbortRequest={_resolve:t,_reject:n,_reason:r,_wasAlreadyErroring:o}});return e._pendingAbortRequest._promise=n,!1===o&&U(e,r),n}function H(e,r){"writable"!==e._state?x(e):U(e,r)}function U(e,r){const t=e._writableStreamController;e._state="erroring",e._storedError=r;const o=e._writer;void 0!==o&&re(o,r),!1===function(e){if(void 0===e._inFlightWriteRequest&&void 0===e._inFlightCloseRequest)return!1;return!0}(e)&&!0===t._started&&x(e)}function x(e){e._state="errored",e._writableStreamController[D]();const r=e._storedError;for(const t of e._writeRequests)t._reject(r);if(e._writeRequests=[],void 0===e._pendingAbortRequest)return void J(e);const t=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,!0===t._wasAlreadyErroring)return t._reject(r),void J(e);e._writableStreamController[I](t._reason).then(()=>{t._resolve(),J(e)},r=>{t._reject(r),J(e)})}function Q(e){e._inFlightCloseRequest._resolve(void 0),e._inFlightCloseRequest=void 0,"erroring"===e._state&&(e._storedError=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._resolve(),e._pendingAbortRequest=void 0)),e._state="closed";const r=e._writer;void 0!==r&&function(e){e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}(r)}function G(e){return void 0!==e._closeRequest||void 0!==e._inFlightCloseRequest}function J(e){void 0!==e._closeRequest&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const r=e._writer;void 0!==r&&(_e(r,e._storedError),r._closedPromise.catch(()=>{}))}function K(e,r){const t=e._writer;void 0!==t&&r!==e._backpressure&&(!0===r?function(e){e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}(t):pe(t)),e._backpressure=r}class WritableStreamDefaultWriter{constructor(e){if(!1===V(e))throw new TypeError("WritableStreamDefaultWriter can only be constructed with a WritableStream instance");if(!0===Y(e))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=e,e._writer=this;const r=e._state;if("writable"===r)!1===G(e)&&!0===e._backpressure?function(e){e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}(this):ye(this),he(this);else if("erroring"===r)be(this,e._storedError),this._readyPromise.catch(()=>{}),he(this);else if("closed"===r)ye(this),function(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}(this);else{const r=e._storedError;be(this,r),this._readyPromise.catch(()=>{}),function(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}(this,r),this._closedPromise.catch(()=>{})}}get closed(){return!1===X(this)?Promise.reject(fe("closed")):this._closedPromise}get desiredSize(){if(!1===X(this))throw fe("desiredSize");if(void 0===this._ownerWritableStream)throw me("desiredSize");return function(e){const r=e._ownerWritableStream,t=r._state;if("errored"===t||"erroring"===t)return null;if("closed"===t)return 0;return ie(r._writableStreamController)}(this)}get ready(){return!1===X(this)?Promise.reject(fe("ready")):this._readyPromise}abort(e){return!1===X(this)?Promise.reject(fe("abort")):void 0===this._ownerWritableStream?Promise.reject(me("abort")):function(e,r){return $(e._ownerWritableStream,r)}(this,e)}close(){if(!1===X(this))return Promise.reject(fe("close"));const e=this._ownerWritableStream;return void 0===e?Promise.reject(me("close")):!0===G(e)?Promise.reject(new TypeError("cannot close an already-closing stream")):Z(this)}releaseLock(){if(!1===X(this))throw fe("releaseLock");void 0!==this._ownerWritableStream&&te(this)}write(e){return!1===X(this)?Promise.reject(fe("write")):void 0===this._ownerWritableStream?Promise.reject(me("write to")):oe(this,e)}}function X(e){return!!W(e)&&!!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")}function Z(e){const r=e._ownerWritableStream,t=r._state;if("closed"===t||"errored"===t)return Promise.reject(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const o=new Promise((e,t)=>{const o={_resolve:e,_reject:t};r._closeRequest=o});return!0===r._backpressure&&"writable"===t&&pe(e),function(e){z(e,"close",0),se(e)}(r._writableStreamController),o}function ee(e,r){"pending"===e._closedPromiseState?_e(e,r):function(e,r){e._closedPromise=Promise.reject(r),e._closedPromiseState="rejected"}(e,r),e._closedPromise.catch(()=>{})}function re(e,r){"pending"===e._readyPromiseState?function(e,r){e._readyPromise_reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}(e,r):function(e,r){e._readyPromise=Promise.reject(r),e._readyPromiseState="rejected"}(e,r),e._readyPromise.catch(()=>{})}function te(e){const r=e._ownerWritableStream,t=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");re(e,t),ee(e,t),r._writer=void 0,e._ownerWritableStream=void 0}function oe(e,r){const t=e._ownerWritableStream,o=t._writableStreamController,n=function(e,r){try{return e._strategySizeAlgorithm(r)}catch(r){return le(e,r),1}}(o,r);if(t!==e._ownerWritableStream)return Promise.reject(me("write to"));const a=t._state;if("errored"===a)return Promise.reject(t._storedError);if(!0===G(t)||"closed"===a)return Promise.reject(new TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===a)return Promise.reject(t._storedError);const i=function(e){return new Promise((r,t)=>{const o={_resolve:r,_reject:t};e._writeRequests.push(o)})}(t);return function(e,r,t){const o={chunk:r};try{z(e,o,t)}catch(r){return void le(e,r)}const n=e._controlledWritableStream;if(!1===G(n)&&"writable"===n._state){const r=ce(e);K(n,r)}se(e)}(o,r,n),i}class WritableStreamDefaultController{constructor(){throw new TypeError("WritableStreamDefaultController cannot be constructed explicitly")}error(e){if(!1===function(e){if(!W(e))return!1;if(!Object.prototype.hasOwnProperty.call(e,"_controlledWritableStream"))return!1;return!0}(this))throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");"writable"===this._controlledWritableStream._state&&ue(this,e)}[I](e){const r=this._abortAlgorithm(e);return ae(this),r}[D](){F(this)}}function ne(e,r,t,o,n,a,i,s){r._controlledWritableStream=e,e._writableStreamController=r,r._queue=void 0,r._queueTotalSize=void 0,F(r),r._started=!1,r._strategySizeAlgorithm=s,r._strategyHWM=i,r._writeAlgorithm=o,r._closeAlgorithm=n,r._abortAlgorithm=a;const l=ce(r);K(e,l);const c=t();Promise.resolve(c).then(()=>{r._started=!0,se(r)},t=>{r._started=!0,H(e,t)}).catch(O)}function ae(e){e._writeAlgorithm=void 0,e._closeAlgorithm=void 0,e._abortAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function ie(e){return e._strategyHWM-e._queueTotalSize}function se(e){const r=e._controlledWritableStream;if(!1===e._started)return;if(void 0!==r._inFlightWriteRequest)return;const t=r._state;if("closed"===t||"errored"===t)return;if("erroring"===t)return void x(r);if(0===e._queue.length)return;const o=k(e);"close"===o?function(e){const r=e._controlledWritableStream;(function(e){e._inFlightCloseRequest=e._closeRequest,e._closeRequest=void 0})(r),B(e);const t=e._closeAlgorithm();ae(e),t.then(()=>{Q(r)},e=>{!function(e,r){e._inFlightCloseRequest._reject(r),e._inFlightCloseRequest=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._reject(r),e._pendingAbortRequest=void 0),H(e,r)}(r,e)}).catch(O)}(e):function(e,r){const t=e._controlledWritableStream;(function(e){e._inFlightWriteRequest=e._writeRequests.shift()})(t),e._writeAlgorithm(r).then(()=>{!function(e){e._inFlightWriteRequest._resolve(void 0),e._inFlightWriteRequest=void 0}(t);const r=t._state;if(B(e),!1===G(t)&&"writable"===r){const r=ce(e);K(t,r)}se(e)},r=>{"writable"===t._state&&ae(e),function(e,r){e._inFlightWriteRequest._reject(r),e._inFlightWriteRequest=void 0,H(e,r)}(t,r)}).catch(O)}(e,o.chunk)}function le(e,r){"writable"===e._controlledWritableStream._state&&ue(e,r)}function ce(e){return ie(e)<=0}function ue(e,r){const t=e._controlledWritableStream;ae(e),U(t,r)}function de(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function fe(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function me(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function he(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t,e._closedPromiseState="pending"})}function _e(e,r){e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}function be(e,r){e._readyPromise=Promise.reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}function ye(e){e._readyPromise=Promise.resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}function pe(e){e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}var we=N.WritableStream;const{ArrayBufferCopy:Se,CreateAlgorithmFromUnderlyingMethod:ge,IsFiniteNonNegativeNumber:ve,InvokeOrNoop:Pe,IsDetachedBuffer:Re,TransferArrayBuffer:Te,ValidateAndNormalizeHighWaterMark:Ce,IsNonNegativeNumber:qe,MakeSizeAlgorithmFromSizeFunction:Ae,createArrayFromList:Ee,typeIsObject:je,WaitForAllPromise:We}=v,{rethrowAssertionErrorRejection:Oe}=g,{DequeueValue:Be,EnqueueValueWithSize:ze,ResetQueue:ke}=R,{AcquireWritableStreamDefaultWriter:Fe,IsWritableStream:Ie,IsWritableStreamLocked:De,WritableStreamAbort:Ne,WritableStreamDefaultWriterCloseWithErrorPropagation:Me,WritableStreamDefaultWriterRelease:Le,WritableStreamDefaultWriterWrite:Ve,WritableStreamCloseQueuedOrInFlight:Ye}=N,$e=r("[[CancelSteps]]"),He=r("[[PullSteps]]");class ReadableStream{constructor(e={},r={}){Ge(this);const o=r.size;let n=r.highWaterMark;const a=e.type;if("bytes"===String(a)){if(void 0!==o)throw new RangeError("The strategy for a byte stream cannot have a size function");void 0===n&&(n=0),function(e,r,o){const n=Object.create(ReadableByteStreamController.prototype);const a=ge(r,"pull",0,[n]),i=ge(r,"cancel",1,[]);let s=r.autoAllocateChunkSize;if(void 0!==s&&(s=Number(s),!1===t(s)||s<=0))throw new RangeError("autoAllocateChunkSize must be a positive integer");Yr(e,n,function(){return Pe(r,"start",[n])},a,i,o,s)}(this,e,n=Ce(n))}else{if(void 0!==a)throw new RangeError("Invalid type is specified");{const r=Ae(o);void 0===n&&(n=1),function(e,r,t,o){const n=Object.create(ReadableStreamDefaultController.prototype);const a=ge(r,"pull",0,[n]),i=ge(r,"cancel",1,[]);Tr(e,n,function(){return Pe(r,"start",[n])},a,i,t,o)}(this,e,n=Ce(n),r)}}}get locked(){if(!1===Je(this))throw Hr("locked");return Ke(this)}cancel(e){return!1===Je(this)?Promise.reject(Hr("cancel")):!0===Ke(this)?Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")):rr(this,e)}getReader({mode:e}={}){if(!1===Je(this))throw Hr("getReader");if(void 0===e)return xe(this);if("byob"===(e=String(e)))return function(e){return new ReadableStreamBYOBReader(e)}(this);throw new RangeError("Invalid mode is specified")}pipeThrough({writable:e,readable:r},{preventClose:t,preventAbort:o,preventCancel:n,signal:a}={}){if(!1===Je(this))throw Hr("pipeThrough");if(!1===Ie(e))throw new TypeError("writable argument to pipeThrough must be a WritableStream");if(!1===Je(r))throw new TypeError("readable argument to pipeThrough must be a ReadableStream");if(t=Boolean(t),o=Boolean(o),n=Boolean(n),void 0!==a&&!$r(a))throw new TypeError("ReadableStream.prototype.pipeThrough's signal option must be an AbortSignal");if(!0===Ke(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(!0===De(e))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return Xe(this,e,t,o,n,a).catch(()=>{}),r}pipeTo(e,{preventClose:r,preventAbort:t,preventCancel:o,signal:n}={}){return!1===Je(this)?Promise.reject(Hr("pipeTo")):!1===Ie(e)?Promise.reject(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream")):(r=Boolean(r),t=Boolean(t),o=Boolean(o),void 0===n||$r(n)?!0===Ke(this)?Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):!0===De(e)?Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):Xe(this,e,r,t,o,n):Promise.reject(new TypeError("ReadableStream.prototype.pipeTo's signal option must be an AbortSignal")))}tee(){if(!1===Je(this))throw Hr("tee");const e=function(e,r){const t=xe(e);let o,n,a,i,s,l=!1,c=!1,u=!1;const d=new Promise(e=>{s=e});function f(){return _r(t).then(e=>{const r=e.value,t=e.done;if(!0===t&&!1===l&&(!1===c&&Sr(a._readableStreamController),!1===u&&Sr(i._readableStreamController),l=!0),!0===l)return;const o=r,n=r;!1===c&&gr(a._readableStreamController,o),!1===u&&gr(i._readableStreamController,n)})}function m(){}return a=Qe(m,f,function(r){if(c=!0,o=r,!0===u){const r=Ee([o,n]),t=rr(e,r);s(t)}return d}),i=Qe(m,f,function(r){if(u=!0,n=r,!0===c){const r=Ee([o,n]),t=rr(e,r);s(t)}return d}),t._closedPromise.catch(e=>{!0!==l&&(vr(a._readableStreamController,e),vr(i._readableStreamController,e),l=!0)}),[a,i]}(this);return Ee(e)}}var Ue={CreateReadableByteStream:function(e,r,t,o=0,n){const a=Object.create(ReadableStream.prototype);Ge(a);const i=Object.create(ReadableByteStreamController.prototype);return Yr(a,i,e,r,t,o,n),a},CreateReadableStream:Qe,ReadableStream:ReadableStream,IsReadableStreamDisturbed:function(e){return e._disturbed},ReadableStreamDefaultControllerClose:Sr,ReadableStreamDefaultControllerEnqueue:gr,ReadableStreamDefaultControllerError:vr,ReadableStreamDefaultControllerGetDesiredSize:Pr,ReadableStreamDefaultControllerHasBackpressure:function(e){if(!0===pr(e))return!1;return!0},ReadableStreamDefaultControllerCanCloseOrEnqueue:Rr};function xe(e){return new ReadableStreamDefaultReader(e)}function Qe(e,r,t,o=1,n=(()=>1)){const a=Object.create(ReadableStream.prototype);return Ge(a),Tr(a,Object.create(ReadableStreamDefaultController.prototype),e,r,t,o,n),a}function Ge(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=!1}function Je(e){return!!je(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")}function Ke(e){return void 0!==e._reader}function Xe(e,r,t,o,n,a){const i=xe(e),s=Fe(r);let l=!1,c=Promise.resolve();return new Promise((u,d)=>{let f;if(void 0!==a){if(f=(()=>{const t=new DOMException("Aborted","AbortError"),a=[];!1===o&&a.push(()=>"writable"===r._state?Ne(r,t):Promise.resolve()),!1===n&&a.push(()=>"readable"===e._state?rr(e,t):Promise.resolve()),_(()=>We(a.map(e=>e()),e=>e),!0,t)}),!0===a.aborted)return void f();a.addEventListener("abort",f)}if(h(e,i._closedPromise,e=>{!1===o?_(()=>Ne(r,e),!0,e):b(!0,e)}),h(r,s._closedPromise,r=>{!1===n?_(()=>rr(e,r),!0,r):b(!0,r)}),function(e,r,t){"closed"===e._state?t():r.then(t).catch(Oe)}(e,i._closedPromise,()=>{!1===t?_(()=>Me(s)):b()}),!0===Ye(r)||"closed"===r._state){const r=new TypeError("the destination writable stream closed before all data could be piped to it");!1===n?_(()=>rr(e,r),!0,r):b(!0,r)}function m(){const e=c;return c.then(()=>e!==c?m():void 0)}function h(e,r,t){"errored"===e._state?t(e._storedError):r.catch(t).catch(Oe)}function _(e,t,o){function n(){e().then(()=>y(t,o),e=>y(!0,e)).catch(Oe)}!0!==l&&(l=!0,"writable"===r._state&&!1===Ye(r)?m().then(n):n())}function b(e,t){!0!==l&&(l=!0,"writable"===r._state&&!1===Ye(r)?m().then(()=>y(e,t)).catch(Oe):y(e,t))}function y(e,r){Le(s),hr(i),void 0!==a&&a.removeEventListener("abort",f),e?d(r):u(void 0)}new Promise((e,r)=>{!function t(o){o?e():(!0===l?Promise.resolve(!0):s._readyPromise.then(()=>_r(i).then(({value:e,done:r})=>!0===r||(c=Ve(s,e).catch(()=>{}),!1)))).then(t,r)}(!1)}).catch(e=>{c=Promise.resolve(),Oe(e)})})}function Ze(e,r){return new Promise((t,o)=>{const n={_resolve:t,_reject:o,_forAuthorCode:r};e._reader._readIntoRequests.push(n)})}function er(e,r){return new Promise((t,o)=>{const n={_resolve:t,_reject:o,_forAuthorCode:r};e._reader._readRequests.push(n)})}function rr(e,r){if(e._disturbed=!0,"closed"===e._state)return Promise.resolve(void 0);if("errored"===e._state)return Promise.reject(e._storedError);return tr(e),e._readableStreamController[$e](r).then(()=>void 0)}function tr(e){e._state="closed";const r=e._reader;if(void 0!==r){if(!0===dr(r)){for(const{_resolve:e,_forAuthorCode:t}of r._readRequests)e(or(void 0,!0,t));r._readRequests=[]}!function(e){e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}(r)}}function or(e,r,t){let o=null;!0===t&&(o=Object.prototype);const n=Object.create(o);return Object.defineProperty(n,"value",{value:e,enumerable:!0,writable:!0,configurable:!0}),Object.defineProperty(n,"done",{value:r,enumerable:!0,writable:!0,configurable:!0}),n}function nr(e,r){e._state="errored",e._storedError=r;const t=e._reader;if(void 0!==t){if(!0===dr(t)){for(const e of t._readRequests)e._reject(r);t._readRequests=[]}else{for(const e of t._readIntoRequests)e._reject(r);t._readIntoRequests=[]}Qr(t,r),t._closedPromise.catch(()=>{})}}function ar(e,r,t){const o=e._reader._readRequests.shift();o._resolve(or(r,t,o._forAuthorCode))}function ir(e){return e._reader._readIntoRequests.length}function sr(e){return e._reader._readRequests.length}function lr(e){const r=e._reader;return void 0!==r&&!1!==ur(r)}function cr(e){const r=e._reader;return void 0!==r&&!1!==dr(r)}class ReadableStreamDefaultReader{constructor(e){if(!1===Je(e))throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");if(!0===Ke(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");fr(this,e),this._readRequests=[]}get closed(){return!1===dr(this)?Promise.reject(xr("closed")):this._closedPromise}cancel(e){return!1===dr(this)?Promise.reject(xr("cancel")):void 0===this._ownerReadableStream?Promise.reject(Ur("cancel")):mr(this,e)}read(){return!1===dr(this)?Promise.reject(xr("read")):void 0===this._ownerReadableStream?Promise.reject(Ur("read from")):_r(this,!0)}releaseLock(){if(!1===dr(this))throw xr("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");hr(this)}}}class ReadableStreamBYOBReader{constructor(e){if(!Je(e))throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");if(!1===Cr(e._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");if(Ke(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");fr(this,e),this._readIntoRequests=[]}get closed(){return ur(this)?this._closedPromise:Promise.reject(Gr("closed"))}cancel(e){return ur(this)?void 0===this._ownerReadableStream?Promise.reject(Ur("cancel")):mr(this,e):Promise.reject(Gr("cancel"))}read(e){return ur(this)?void 0===this._ownerReadableStream?Promise.reject(Ur("read from")):ArrayBuffer.isView(e)?!0===Re(e.buffer)?Promise.reject(new TypeError("Cannot read into a view onto a detached ArrayBuffer")):0===e.byteLength?Promise.reject(new TypeError("view must have non-zero byteLength")):function(e,r,t=!1){const o=e._ownerReadableStream;if(o._disturbed=!0,"errored"===o._state)return Promise.reject(o._storedError);return function(e,r,t){const o=e._controlledReadableByteStream;let n=1;r.constructor!==DataView&&(n=r.constructor.BYTES_PER_ELEMENT);const a=r.constructor,i={buffer:Te(r.buffer),byteOffset:r.byteOffset,byteLength:r.byteLength,bytesFilled:0,elementSize:n,ctor:a,readerType:"byob"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(i),Ze(o,t);if("closed"===o._state){const e=new r.constructor(i.buffer,i.byteOffset,0);return Promise.resolve(or(e,!0,t))}if(e._queueTotalSize>0){if(!0===Br(e,i)){const r=Wr(i);return kr(e),Promise.resolve(or(r,!1,t))}if(!0===e._closeRequested){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");return Lr(e,r),Promise.reject(r)}}e._pendingPullIntos.push(i);const s=Ze(o,t);return Ar(e),s}(o._readableStreamController,r,t)}(this,e,!0):Promise.reject(new TypeError("view must be an array buffer view")):Promise.reject(Gr("read"))}releaseLock(){if(!ur(this))throw Gr("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");hr(this)}}}function ur(e){return!!je(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")}function dr(e){return!!je(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readRequests")}function fr(e,r){e._ownerReadableStream=r,r._reader=e,"readable"===r._state?function(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t})}(e):"closed"===r._state?function(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}(e):(!function(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}(e,r._storedError),e._closedPromise.catch(()=>{}))}function mr(e,r){return rr(e._ownerReadableStream,r)}function hr(e){"readable"===e._ownerReadableStream._state?Qr(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function(e,r){e._closedPromise=Promise.reject(r)}(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._closedPromise.catch(()=>{}),e._ownerReadableStream._reader=void 0,e._ownerReadableStream=void 0}function _r(e,r=!1){const t=e._ownerReadableStream;return t._disturbed=!0,"closed"===t._state?Promise.resolve(or(void 0,!0,r)):"errored"===t._state?Promise.reject(t._storedError):t._readableStreamController[He](r)}class ReadableStreamDefaultController{constructor(){throw new TypeError}get desiredSize(){if(!1===br(this))throw Jr("desiredSize");return Pr(this)}close(){if(!1===br(this))throw Jr("close");if(!1===Rr(this))throw new TypeError("The stream is not in a state that permits close");Sr(this)}enqueue(e){if(!1===br(this))throw Jr("enqueue");if(!1===Rr(this))throw new TypeError("The stream is not in a state that permits enqueue");return gr(this,e)}error(e){if(!1===br(this))throw Jr("error");vr(this,e)}[$e](e){ke(this);const r=this._cancelAlgorithm(e);return wr(this),r}[He](e){const r=this._controlledReadableStream;if(this._queue.length>0){const t=Be(this);return!0===this._closeRequested&&0===this._queue.length?(wr(this),tr(r)):yr(this),Promise.resolve(or(t,!1,e))}const t=er(r,e);return yr(this),t}}function br(e){return!!je(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")}function yr(e){!1!==pr(e)&&(!0!==e._pulling?(e._pulling=!0,e._pullAlgorithm().then(()=>{if(e._pulling=!1,!0===e._pullAgain)return e._pullAgain=!1,yr(e)},r=>{vr(e,r)}).catch(Oe)):e._pullAgain=!0)}function pr(e){const r=e._controlledReadableStream;return!1!==Rr(e)&&(!1!==e._started&&(!0===Ke(r)&&sr(r)>0||Pr(e)>0))}function wr(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function Sr(e){const r=e._controlledReadableStream;e._closeRequested=!0,0===e._queue.length&&(wr(e),tr(r))}function gr(e,r){const t=e._controlledReadableStream;if(!0===Ke(t)&&sr(t)>0)ar(t,r,!1);else{let t;try{t=e._strategySizeAlgorithm(r)}catch(r){throw vr(e,r),r}try{ze(e,r,t)}catch(r){throw vr(e,r),r}}yr(e)}function vr(e,r){const t=e._controlledReadableStream;"readable"===t._state&&(ke(e),wr(e),nr(t,r))}function Pr(e){const r=e._controlledReadableStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function Rr(e){const r=e._controlledReadableStream._state;return!1===e._closeRequested&&"readable"===r}function Tr(e,r,t,o,n,a,i){r._controlledReadableStream=e,r._queue=void 0,r._queueTotalSize=void 0,ke(r),r._started=!1,r._closeRequested=!1,r._pullAgain=!1,r._pulling=!1,r._strategySizeAlgorithm=i,r._strategyHWM=a,r._pullAlgorithm=o,r._cancelAlgorithm=n,e._readableStreamController=r;const s=t();Promise.resolve(s).then(()=>{r._started=!0,yr(r)},e=>{vr(r,e)}).catch(Oe)}class ReadableStreamBYOBRequest{constructor(){throw new TypeError("ReadableStreamBYOBRequest cannot be used directly")}get view(){if(!1===qr(this))throw Kr("view");return this._view}respond(e){if(!1===qr(this))throw Kr("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!0===Re(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");!function(e,r){if(r=Number(r),!1===ve(r))throw new RangeError("bytesWritten must be a finite");Dr(e,r)}(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!1===qr(this))throw Kr("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!ArrayBuffer.isView(e))throw new TypeError("You can only respond with array buffer views");if(!0===Re(e.buffer))throw new TypeError("The supplied view's buffer has been detached and so cannot be used as a response");!function(e,r){const t=e._pendingPullIntos[0];if(t.byteOffset+t.bytesFilled!==r.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(t.byteLength!==r.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");t.buffer=r.buffer,Dr(e,r.byteLength)}(this._associatedReadableByteStreamController,e)}}class ReadableByteStreamController{constructor(){throw new TypeError("ReadableByteStreamController constructor cannot be used directly")}get byobRequest(){if(!1===Cr(this))throw Xr("byobRequest");if(void 0===this._byobRequest&&this._pendingPullIntos.length>0){const e=this._pendingPullIntos[0],r=new Uint8Array(e.buffer,e.byteOffset+e.bytesFilled,e.byteLength-e.bytesFilled),t=Object.create(ReadableStreamBYOBRequest.prototype);!function(e,r,t){e._associatedReadableByteStreamController=r,e._view=t}(t,this,r),this._byobRequest=t}return this._byobRequest}get desiredSize(){if(!1===Cr(this))throw Xr("desiredSize");return Vr(this)}close(){if(!1===Cr(this))throw Xr("close");if(!0===this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const e=this._controlledReadableByteStream._state;if("readable"!==e)throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);!function(e){const r=e._controlledReadableByteStream;if(e._queueTotalSize>0)return void(e._closeRequested=!0);if(e._pendingPullIntos.length>0){const r=e._pendingPullIntos[0];if(r.bytesFilled>0){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");throw Lr(e,r),r}}Mr(e),tr(r)}(this)}enqueue(e){if(!1===Cr(this))throw Xr("enqueue");if(!0===this._closeRequested)throw new TypeError("stream is closed or draining");const r=this._controlledReadableByteStream._state;if("readable"!==r)throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);if(!ArrayBuffer.isView(e))throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");if(!0===Re(e.buffer))throw new TypeError("Cannot enqueue a view onto a detached ArrayBuffer");!function(e,r){const t=e._controlledReadableByteStream,o=r.buffer,n=r.byteOffset,a=r.byteLength,i=Te(o);if(!0===cr(t))if(0===sr(t))Or(e,i,n,a);else{const e=new Uint8Array(i,n,a);ar(t,e,!1)}else!0===lr(t)?(Or(e,i,n,a),Ir(e)):Or(e,i,n,a);Ar(e)}(this,e)}error(e){if(!1===Cr(this))throw Xr("error");Lr(this,e)}[$e](e){if(this._pendingPullIntos.length>0){this._pendingPullIntos[0].bytesFilled=0}ke(this);const r=this._cancelAlgorithm(e);return Mr(this),r}[He](e){const r=this._controlledReadableByteStream;if(this._queueTotalSize>0){const r=this._queue.shift();let t;this._queueTotalSize-=r.byteLength,kr(this);try{t=new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}catch(e){return Promise.reject(e)}return Promise.resolve(or(t,!1,e))}const t=this._autoAllocateChunkSize;if(void 0!==t){let e;try{e=new ArrayBuffer(t)}catch(e){return Promise.reject(e)}const r={buffer:e,byteOffset:0,byteLength:t,bytesFilled:0,elementSize:1,ctor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(r)}const o=er(r,e);return Ar(this),o}}function Cr(e){return!!je(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")}function qr(e){return!!je(e)&&!!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")}function Ar(e){!1!==function(e){const r=e._controlledReadableByteStream;if("readable"!==r._state)return!1;if(!0===e._closeRequested)return!1;if(!1===e._started)return!1;if(!0===cr(r)&&sr(r)>0)return!0;if(!0===lr(r)&&ir(r)>0)return!0;if(Vr(e)>0)return!0;return!1}(e)&&(!0!==e._pulling?(e._pulling=!0,e._pullAlgorithm().then(()=>{e._pulling=!1,!0===e._pullAgain&&(e._pullAgain=!1,Ar(e))},r=>{Lr(e,r)}).catch(Oe)):e._pullAgain=!0)}function Er(e){Fr(e),e._pendingPullIntos=[]}function jr(e,r){let t=!1;"closed"===e._state&&(t=!0);const o=Wr(r);"default"===r.readerType?ar(e,o,t):function(e,r,t){const o=e._reader._readIntoRequests.shift();o._resolve(or(r,t,o._forAuthorCode))}(e,o,t)}function Wr(e){const r=e.bytesFilled,t=e.elementSize;return new e.ctor(e.buffer,e.byteOffset,r/t)}function Or(e,r,t,o){e._queue.push({buffer:r,byteOffset:t,byteLength:o}),e._queueTotalSize+=o}function Br(e,r){const t=r.elementSize,o=r.bytesFilled-r.bytesFilled%t,n=Math.min(e._queueTotalSize,r.byteLength-r.bytesFilled),a=r.bytesFilled+n,i=a-a%t;let s=n,l=!1;i>o&&(s=i-r.bytesFilled,l=!0);const c=e._queue;for(;s>0;){const t=c[0],o=Math.min(s,t.byteLength),n=r.byteOffset+r.bytesFilled;Se(r.buffer,n,t.buffer,t.byteOffset,o),t.byteLength===o?c.shift():(t.byteOffset+=o,t.byteLength-=o),e._queueTotalSize-=o,zr(e,o,r),s-=o}return l}function zr(e,r,t){Fr(e),t.bytesFilled+=r}function kr(e){0===e._queueTotalSize&&!0===e._closeRequested?(Mr(e),tr(e._controlledReadableByteStream)):Ar(e)}function Fr(e){void 0!==e._byobRequest&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=void 0,e._byobRequest=void 0)}function Ir(e){for(;e._pendingPullIntos.length>0;){if(0===e._queueTotalSize)return;const r=e._pendingPullIntos[0];!0===Br(e,r)&&(Nr(e),jr(e._controlledReadableByteStream,r))}}function Dr(e,r){const t=e._pendingPullIntos[0];if("closed"===e._controlledReadableByteStream._state){if(0!==r)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");!function(e,r){r.buffer=Te(r.buffer);const t=e._controlledReadableByteStream;if(!0===lr(t))for(;ir(t)>0;)jr(t,Nr(e))}(e,t)}else!function(e,r,t){if(t.bytesFilled+r>t.byteLength)throw new RangeError("bytesWritten out of range");if(zr(e,r,t),t.bytesFilled<t.elementSize)return;Nr(e);const o=t.bytesFilled%t.elementSize;if(o>0){const r=t.byteOffset+t.bytesFilled,n=t.buffer.slice(r-o,r);Or(e,n,0,n.byteLength)}t.buffer=Te(t.buffer),t.bytesFilled-=o,jr(e._controlledReadableByteStream,t),Ir(e)}(e,r,t);Ar(e)}function Nr(e){const r=e._pendingPullIntos.shift();return Fr(e),r}function Mr(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0}function Lr(e,r){const t=e._controlledReadableByteStream;"readable"===t._state&&(Er(e),ke(e),Mr(e),nr(t,r))}function Vr(e){const r=e._controlledReadableByteStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function Yr(e,r,t,o,n,a,i){r._controlledReadableByteStream=e,r._pullAgain=!1,r._pulling=!1,Er(r),r._queue=r._queueTotalSize=void 0,ke(r),r._closeRequested=!1,r._started=!1,r._strategyHWM=Ce(a),r._pullAlgorithm=o,r._cancelAlgorithm=n,r._autoAllocateChunkSize=i,r._pendingPullIntos=[],e._readableStreamController=r;const s=t();Promise.resolve(s).then(()=>{r._started=!0,Ar(r)},e=>{Lr(r,e)}).catch(Oe)}function $r(e){if("object"!=typeof e||null===e)return!1;const r=Object.getOwnPropertyDescriptor(AbortSignal.prototype,"aborted").get;try{return r.call(e),!0}catch(e){return!1}}function Hr(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function Ur(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function xr(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}function Qr(e,r){e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function Gr(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function Jr(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function Kr(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function Xr(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}var Zr=Ue.ReadableStream;const{createDataProperty:et}=v;const{createDataProperty:rt}=v;T("streams:transform-stream:verbose");const{InvokeOrNoop:tt,CreateAlgorithmFromUnderlyingMethod:ot,PromiseCall:nt,typeIsObject:at,ValidateAndNormalizeHighWaterMark:it,IsNonNegativeNumber:st,MakeSizeAlgorithmFromSizeFunction:lt}=v,{CreateReadableStream:ct,ReadableStreamDefaultControllerClose:ut,ReadableStreamDefaultControllerEnqueue:dt,ReadableStreamDefaultControllerError:ft,ReadableStreamDefaultControllerGetDesiredSize:mt,ReadableStreamDefaultControllerHasBackpressure:ht,ReadableStreamDefaultControllerCanCloseOrEnqueue:_t}=Ue,{CreateWritableStream:bt,WritableStreamDefaultControllerErrorIfNeeded:yt}=N;class TransformStream{constructor(e={},r={},t={}){const o=r.size;let n=r.highWaterMark;const a=t.size;let i=t.highWaterMark;if(void 0!==e.writableType)throw new RangeError("Invalid writable type specified");const s=lt(o);if(void 0===n&&(n=1),n=it(n),void 0!==e.readableType)throw new RangeError("Invalid readable type specified");const l=lt(a);let c;void 0===i&&(i=0),i=it(i),pt(this,new Promise(e=>{c=e}),n,s,i,l),function(e,r){const t=Object.create(TransformStreamDefaultController.prototype);let o=e=>{try{return Ct(t,e),Promise.resolve()}catch(e){return Promise.reject(e)}};const n=r.transform;if(void 0!==n){if("function"!=typeof n)throw new TypeError("transform is not a method");o=(e=>nt(n,r,[e,t]))}const a=ot(r,"flush",0,[t]);Rt(e,t,o,a)}(this,e);const u=tt(e,"start",[this._transformStreamController]);c(u)}get readable(){if(!1===wt(this))throw Et("readable");return this._readable}get writable(){if(!1===wt(this))throw Et("writable");return this._writable}}function pt(e,r,t,o,n,a){function i(){return r}e._writable=bt(i,function(r){return function(e,r){const t=e._transformStreamController;if(!0===e._backpressure){const o=e._backpressureChangePromise;return o.then(()=>{const o=e._writable,n=o._state;if("erroring"===n)throw o._storedError;return qt(t,r)})}return qt(t,r)}(e,r)},function(){return function(e){const r=e._readable,t=e._transformStreamController,o=t._flushAlgorithm();return Tt(t),o.then(()=>{if("errored"===r._state)throw r._storedError;const e=r._readableStreamController;!0===_t(e)&&ut(e)}).catch(t=>{throw St(e,t),r._storedError})}(e)},function(r){return function(e,r){return St(e,r),Promise.resolve()}(e,r)},t,o),e._readable=ct(i,function(){return function(e){return vt(e,!1),e._backpressureChangePromise}(e)},function(r){return gt(e,r),Promise.resolve()},n,a),e._backpressure=void 0,e._backpressureChangePromise=void 0,e._backpressureChangePromise_resolve=void 0,vt(e,!0),e._transformStreamController=void 0}function wt(e){return!!at(e)&&!!Object.prototype.hasOwnProperty.call(e,"_transformStreamController")}function St(e,r){ft(e._readable._readableStreamController,r),gt(e,r)}function gt(e,r){Tt(e._transformStreamController),yt(e._writable._writableStreamController,r),!0===e._backpressure&&vt(e,!1)}function vt(e,r){void 0!==e._backpressureChangePromise&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=new Promise(r=>{e._backpressureChangePromise_resolve=r}),e._backpressure=r}class TransformStreamDefaultController{constructor(){throw new TypeError("TransformStreamDefaultController instances cannot be created directly")}get desiredSize(){if(!1===Pt(this))throw At("desiredSize");const e=this._controlledTransformStream._readable._readableStreamController;return mt(e)}enqueue(e){if(!1===Pt(this))throw At("enqueue");Ct(this,e)}error(e){if(!1===Pt(this))throw At("error");!function(e,r){St(e._controlledTransformStream,r)}(this,e)}terminate(){if(!1===Pt(this))throw At("terminate");!function(e){const r=e._controlledTransformStream,t=r._readable._readableStreamController;!0===_t(t)&&ut(t);const o=new TypeError("TransformStream terminated");gt(r,o)}(this)}}function Pt(e){return!!at(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream")}function Rt(e,r,t,o){r._controlledTransformStream=e,e._transformStreamController=r,r._transformAlgorithm=t,r._flushAlgorithm=o}function Tt(e){e._transformAlgorithm=void 0,e._flushAlgorithm=void 0}function Ct(e,r){const t=e._controlledTransformStream,o=t._readable._readableStreamController;if(!1===_t(o))throw new TypeError("Readable side is not in a state that permits enqueue");try{dt(o,r)}catch(e){throw gt(t,e),t._readable._storedError}ht(o)!==t._backpressure&&vt(t,!0)}function qt(e,r){return e._transformAlgorithm(r).catch(r=>{throw St(e._controlledTransformStream,r),r})}function At(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function Et(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}var jt={CreateTransformStream:function(e,r,t,o=1,n=(()=>1),a=0,i=(()=>1)){const s=Object.create(TransformStream.prototype);let l;pt(s,new Promise(e=>{l=e}),o,n,a,i),Rt(s,Object.create(TransformStreamDefaultController.prototype),r,t);const c=e();return l(c),s},TransformStream:TransformStream}.TransformStream;e.ReadableStream=Zr,e.WritableStream=we,e.ByteLengthQueuingStrategy=class ByteLengthQueuingStrategy{constructor({highWaterMark:e}){et(this,"highWaterMark",e)}size(e){return e.byteLength}},e.CountQueuingStrategy=class CountQueuingStrategy{constructor({highWaterMark:e}){rt(this,"highWaterMark",e)}size(){return 1}},e.TransformStream=jt,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=ponyfill.es6.min.js.map
