{"version":3,"file":"polyfill.min.js","sources":["../src/stub/symbol.js","../src/stub/number-isinteger.js","../src/utils.js","../src/stub/number-isnan.js","../spec/reference-implementation/lib/helpers.js","../src/stub/helpers.js","../src/stub/assert.js","../spec/reference-implementation/lib/utils.js","../spec/reference-implementation/lib/queue-with-sizes.js","../spec/reference-implementation/lib/writable-stream.js","../spec/reference-implementation/lib/readable-stream.js","../spec/reference-implementation/lib/byte-length-queuing-strategy.js","../spec/reference-implementation/lib/count-queuing-strategy.js","../spec/reference-implementation/lib/transform-stream.js","../src/polyfill.js"],"sourcesContent":["const SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n  Symbol :\n  description => `Symbol(${description})`;\n\nexport default SymbolPolyfill;\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nconst NumberIsInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\nexport default NumberIsInteger;\n","export function noop() {\n  // do nothing\n}\n\nfunction getGlobals() {\n  /* global self, window, global */\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n","'use strict';\r\nconst assert = require('better-assert');\r\n\r\nconst isFakeDetached = Symbol('is \"detached\" for our purposes');\r\n\r\nfunction IsPropertyKey(argument) {\r\n  return typeof argument === 'string' || typeof argument === 'symbol';\r\n}\r\n\r\nexports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';\r\n\r\nexports.createDataProperty = (o, p, v) => {\r\n  assert(exports.typeIsObject(o));\r\n  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });\r\n};\r\n\r\nexports.createArrayFromList = elements => {\r\n  // We use arrays to represent lists, so this is basically a no-op.\r\n  // Do a slice though just in case we happen to depend on the unique-ness.\r\n  return elements.slice();\r\n};\r\n\r\nexports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {\r\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\r\n};\r\n\r\nexports.IsFiniteNonNegativeNumber = v => {\r\n  if (exports.IsNonNegativeNumber(v) === false) {\r\n    return false;\r\n  }\r\n\r\n  if (v === Infinity) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nexports.IsNonNegativeNumber = v => {\r\n  if (typeof v !== 'number') {\r\n    return false;\r\n  }\r\n\r\n  if (Number.isNaN(v)) {\r\n    return false;\r\n  }\r\n\r\n  if (v < 0) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nfunction Call(F, V, args) {\r\n  if (typeof F !== 'function') {\r\n    throw new TypeError('Argument is not a function');\r\n  }\r\n\r\n  return Function.prototype.apply.call(F, V, args);\r\n}\r\n\r\nexports.Call = Call;\r\n\r\nexports.CreateAlgorithmFromUnderlyingMethod = (underlyingObject, methodName, algoArgCount, extraArgs) => {\r\n  assert(underlyingObject !== undefined);\r\n  assert(IsPropertyKey(methodName));\r\n  assert(algoArgCount === 0 || algoArgCount === 1);\r\n  assert(Array.isArray(extraArgs));\r\n  const method = underlyingObject[methodName];\r\n  if (method !== undefined) {\r\n    if (typeof method !== 'function') {\r\n      throw new TypeError(`${method} is not a method`);\r\n    }\r\n    switch (algoArgCount) {\r\n      case 0: {\r\n        return () => {\r\n          return PromiseCall(method, underlyingObject, extraArgs);\r\n        };\r\n      }\r\n\r\n      case 1: {\r\n        return arg => {\r\n          const fullArgs = [arg].concat(extraArgs);\r\n          return PromiseCall(method, underlyingObject, fullArgs);\r\n        };\r\n      }\r\n    }\r\n  }\r\n  return () => Promise.resolve();\r\n};\r\n\r\nexports.InvokeOrNoop = (O, P, args) => {\r\n  assert(O !== undefined);\r\n  assert(IsPropertyKey(P));\r\n  assert(Array.isArray(args));\r\n\r\n  const method = O[P];\r\n  if (method === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  return Call(method, O, args);\r\n};\r\n\r\nfunction PromiseCall(F, V, args) {\r\n  assert(typeof F === 'function');\r\n  assert(V !== undefined);\r\n  assert(Array.isArray(args));\r\n  try {\r\n    return Promise.resolve(Call(F, V, args));\r\n  } catch (value) {\r\n    return Promise.reject(value);\r\n  }\r\n}\r\n\r\nexports.PromiseCall = PromiseCall;\r\n\r\n// Not implemented correctly\r\nexports.TransferArrayBuffer = O => {\r\n  assert(!exports.IsDetachedBuffer(O));\r\n  const transferredIshVersion = O.slice();\r\n\r\n  // This is specifically to fool tests that test \"is transferred\" by taking a non-zero-length\r\n  // ArrayBuffer and checking if its byteLength starts returning 0.\r\n  Object.defineProperty(O, 'byteLength', {\r\n    get() {\r\n      return 0;\r\n    }\r\n  });\r\n  O[isFakeDetached] = true;\r\n\r\n  return transferredIshVersion;\r\n};\r\n\r\n// Not implemented correctly\r\nexports.IsDetachedBuffer = O => {\r\n  return isFakeDetached in O;\r\n};\r\n\r\nexports.ValidateAndNormalizeHighWaterMark = highWaterMark => {\r\n  highWaterMark = Number(highWaterMark);\r\n  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\r\n    throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\r\n  }\r\n\r\n  return highWaterMark;\r\n};\r\n\r\nexports.MakeSizeAlgorithmFromSizeFunction = size => {\r\n  if (size === undefined) {\r\n    return () => 1;\r\n  }\r\n  if (typeof size !== 'function') {\r\n    throw new TypeError('size property of a queuing strategy must be a function');\r\n  }\r\n  return chunk => size(chunk);\r\n};\r\n\r\nexports.PerformPromiseThen = (promise, onFulfilled, onRejected) => {\r\n  // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\r\n  // approximation.\r\n  return Promise.prototype.then.call(promise, onFulfilled, onRejected);\r\n};\r\n\r\nexports.WaitForAll = (promises, successSteps, failureSteps) => {\r\n  let rejected = false;\r\n  const rejectionHandler = arg => {\r\n    if (rejected === false) {\r\n      rejected = true;\r\n      failureSteps(arg);\r\n    }\r\n  };\r\n  let index = 0;\r\n  let fulfilledCount = 0;\r\n  const total = promises.length;\r\n  const result = new Array(total);\r\n  for (const promise of promises) {\r\n    const promiseIndex = index;\r\n    const fulfillmentHandler = arg => {\r\n      result[promiseIndex] = arg;\r\n      ++fulfilledCount;\r\n      if (fulfilledCount === total) {\r\n        successSteps(result);\r\n      }\r\n    };\r\n    exports.PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\r\n    ++index;\r\n  }\r\n};\r\n\r\nexports.WaitForAllPromise = (promises, successSteps, failureSteps = undefined) => {\r\n  let resolvePromise;\r\n  let rejectPromise;\r\n  const promise = new Promise((resolve, reject) => {\r\n    resolvePromise = resolve;\r\n    rejectPromise = reject;\r\n  });\r\n  if (failureSteps === undefined) {\r\n    failureSteps = arg => {\r\n      throw arg;\r\n    };\r\n  }\r\n  const successStepsWrapper = results => {\r\n    try {\r\n      const stepsResult = successSteps(results);\r\n      resolvePromise(stepsResult);\r\n    } catch (e) {\r\n      rejectPromise(e);\r\n    }\r\n  };\r\n  const failureStepsWrapper = reason => {\r\n    try {\r\n      const stepsResult = failureSteps(reason);\r\n      resolvePromise(stepsResult);\r\n    } catch (e) {\r\n      rejectPromise(e);\r\n    }\r\n  };\r\n  exports.WaitForAll(promises, successStepsWrapper, failureStepsWrapper);\r\n  return promise;\r\n};\r\n","export {\n  typeIsObject,\n  createDataProperty,\n  createArrayFromList,\n  ArrayBufferCopy,\n  IsFiniteNonNegativeNumber,\n  IsNonNegativeNumber,\n  Call,\n  CreateAlgorithmFromUnderlyingMethod,\n  InvokeOrNoop,\n  PromiseCall,\n  ValidateAndNormalizeHighWaterMark,\n  MakeSizeAlgorithmFromSizeFunction,\n  PerformPromiseThen,\n  WaitForAll,\n  WaitForAllPromise\n} from '../../spec/reference-implementation/lib/helpers';\n\n// Not implemented correctly\nexport function TransferArrayBuffer(O) {\n  return O;\n}\n\n// Not implemented correctly\nexport function IsDetachedBuffer(O) { // eslint-disable-line no-unused-vars\n  return false;\n}\n","import { noop } from '../utils';\n\nexport default function assert() {\n  // do nothing\n}\n\nassert.AssertionError = noop;\n","'use strict';\nconst assert = require('assert');\n\nexports.rethrowAssertionErrorRejection = e => {\n  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n  // expect any errors, but assertion errors are always problematic.\n  if (e && e instanceof assert.AssertionError) {\n    setTimeout(() => {\n      throw e;\n    }, 0);\n  }\n};\n","'use strict';\nconst assert = require('better-assert');\nconst { IsFiniteNonNegativeNumber } = require('./helpers.js');\n\nexports.DequeueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift();\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n};\n\nexports.EnqueueValueWithSize = (container, value, size) => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  size = Number(size);\n  if (!IsFiniteNonNegativeNumber(size)) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n};\n\nexports.PeekQueueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue[0];\n  return pair.value;\n};\n\nexports.ResetQueue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = [];\n  container._queueTotalSize = 0;\n};\n","'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:writable-stream:verbose');\n\nconst { CreateAlgorithmFromUnderlyingMethod, InvokeOrNoop, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, PeekQueueValue, ResetQueue } = require('./queue-with-sizes.js');\n\nconst AbortSteps = Symbol('[[AbortSteps]]');\nconst ErrorSteps = Symbol('[[ErrorSteps]]');\n\nclass WritableStream {\n  constructor(underlyingSink = {}, strategy = {}) {\n    InitializeWritableStream(this);\n\n    const size = strategy.size;\n    let highWaterMark = strategy.highWaterMark;\n\n    const type = underlyingSink.type;\n\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n    if (highWaterMark === undefined) {\n      highWaterMark = 1;\n    }\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  get locked() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  abort(reason) {\n    if (IsWritableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  getWriter() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nmodule.exports = {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter(stream) {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream(stream) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = [];\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsWritableStreamLocked(stream) {\n  assert(IsWritableStream(stream) === true);\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream, reason) {\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest._promise = promise;\n\n  if (wasAlreadyErroring === false) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream) {\n  assert(IsWritableStreamLocked(stream) === true);\n  assert(stream._state === 'writable');\n\n  const promise = new Promise((resolve, reject) => {\n    const writeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream, error) {\n  verbose('WritableStreamDealWithRejection(stream, %o)', error);\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream, reason) {\n  verbose('WritableStreamStartErroring(stream, %o)', reason);\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream) {\n  verbose('WritableStreamFinishErroring()');\n  assert(stream._state === 'erroring');\n  assert(WritableStreamHasOperationMarkedInFlight(stream) === false);\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  for (const writeRequest of stream._writeRequests) {\n    writeRequest._reject(storedError);\n  }\n  stream._writeRequests = [];\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring === true) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  promise.then(\n      () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      },\n      reason => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    verbose('WritableStreamHasOperationMarkedInFlight() is false');\n    return false;\n  }\n\n  verbose('WritableStreamHasOperationMarkedInFlight() is true');\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  verbose('WritableStreamRejectCloseAndClosedPromiseIfNeeded()');\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n    writer._closedPromise.catch(() => {});\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n  assert(stream._state === 'writable');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure === true) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(backpressure === false);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\nclass WritableStreamDefaultWriter {\n  constructor(stream) {\n    if (IsWritableStream(stream) === false) {\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\n    }\n    if (IsWritableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n      this._closedPromise.catch(() => {});\n    }\n  }\n\n  get closed() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  get desiredSize() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  get ready() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  abort(reason) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  close() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return Promise.reject(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  releaseLock() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  write(chunk) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.reject(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const promise = new Promise((resolve, reject) => {\n    const closeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  if (stream._backpressure === true && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.resolve();\n  }\n\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n  writer._closedPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  verbose('WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)', error);\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n  writer._readyPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    'Writer was released and can no longer be used to monitor the stream\\'s closedness');\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined;\n}\n\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return Promise.reject(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nclass WritableStreamDefaultController {\n  constructor() {\n    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\n  }\n\n  error(e) {\n    if (IsWritableStreamDefaultController(this) === false) {\n      throw new TypeError(\n        'WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  [AbortSteps](reason) {\n    const result = this._abortAlgorithm(reason);\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                              abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(IsWritableStream(stream) === true);\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = Promise.resolve(startResult);\n  startPromise.then(\n      () => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      },\n      r => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n      }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n  assert(underlyingSink !== undefined);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSink, 'start', [controller]);\n  }\n\n  const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\n  const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\n  const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._writeAlgorithm = undefined;\n  controller._closeAlgorithm = undefined;\n  controller._abortAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n}\n\nfunction WritableStreamDefaultControllerClose(controller) {\n  EnqueueValueWithSize(controller, 'close', 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n  const writeRecord = { chunk };\n\n  try {\n    EnqueueValueWithSize(controller, writeRecord, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  verbose('WritableStreamDefaultControllerAdvanceQueueIfNeeded()');\n  const stream = controller._controlledWritableStream;\n\n  if (controller._started === false) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return;\n  }\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const writeRecord = PeekQueueValue(controller);\n  if (writeRecord === 'close') {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  sinkClosePromise.then(\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  sinkWritePromise.then(\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    reason => {\n      if (stream._state === 'writable') {\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n      }\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller, error) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name) {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer) {\n  writer._closedPromise = new Promise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  writer._closedPromise = Promise.resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResolve(writer) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer) {\n  verbose('defaultWriterReadyPromiseInitialize()');\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseInitializeAsRejected(writer, %o)', reason);\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  verbose('defaultWriterReadyPromiseInitializeAsResolved()');\n  writer._readyPromise = Promise.resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n  verbose('defaultWriterReadyPromiseReject(writer, %o)', reason);\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer) {\n  verbose('defaultWriterReadyPromiseReset()');\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseResetToRejected(writer, %o)', reason);\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseResolve(writer) {\n  verbose('defaultWriterReadyPromiseResolve()');\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n","'use strict';\n/* global AbortSignal:false */\n\nconst assert = require('better-assert');\nconst { ArrayBufferCopy, CreateAlgorithmFromUnderlyingMethod, IsFiniteNonNegativeNumber, InvokeOrNoop,\n        IsDetachedBuffer, TransferArrayBuffer, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, createArrayFromList, typeIsObject, WaitForAllPromise } =\n      require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, ResetQueue } = require('./queue-with-sizes.js');\nconst { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked,\n        WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation,\n        WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite, WritableStreamCloseQueuedOrInFlight } =\n      require('./writable-stream.js');\n\nconst CancelSteps = Symbol('[[CancelSteps]]');\nconst PullSteps = Symbol('[[PullSteps]]');\n\nclass ReadableStream {\n  constructor(underlyingSource = {}, strategy = {}) {\n    InitializeReadableStream(this);\n\n    const size = strategy.size;\n    let highWaterMark = strategy.highWaterMark;\n\n    const type = underlyingSource.type;\n    const typeString = String(type);\n    if (typeString === 'bytes') {\n      if (size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n\n      if (highWaterMark === undefined) {\n        highWaterMark = 0;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n    } else if (type === undefined) {\n      const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n\n      if (highWaterMark === undefined) {\n        highWaterMark = 1;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n    } else {\n      throw new RangeError('Invalid type is specified');\n    }\n  }\n\n  get locked() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  cancel(reason) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  getReader({ mode } = {}) {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    if (mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    mode = String(mode);\n\n    if (mode === 'byob') {\n      return AcquireReadableStreamBYOBReader(this);\n    }\n\n    throw new RangeError('Invalid mode is specified');\n  }\n\n  pipeThrough({ writable, readable }, { preventClose, preventAbort, preventCancel, signal } = {}) {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('pipeThrough');\n    }\n\n    if (IsWritableStream(writable) === false) {\n      throw new TypeError('writable argument to pipeThrough must be a WritableStream');\n    }\n\n    if (IsReadableStream(readable) === false) {\n      throw new TypeError('readable argument to pipeThrough must be a ReadableStream');\n    }\n\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    if (signal !== undefined && !isAbortSignal(signal)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough\\'s signal option must be an AbortSignal');\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n    }\n    if (IsWritableStreamLocked(writable) === true) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n    }\n\n    const promise = ReadableStreamPipeTo(this, writable, preventClose, preventAbort, preventCancel, signal);\n\n    promise.catch(() => {});\n\n    return readable;\n  }\n\n  pipeTo(dest, { preventClose, preventAbort, preventCancel, signal } = {}) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('pipeTo'));\n    }\n    if (IsWritableStream(dest) === false) {\n      return Promise.reject(\n          new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\n    }\n\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    if (signal !== undefined && !isAbortSignal(signal)) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo\\'s signal option must be an AbortSignal'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n    }\n    if (IsWritableStreamLocked(dest) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n    }\n\n    return ReadableStreamPipeTo(this, dest, preventClose, preventAbort, preventCancel, signal);\n  }\n\n  tee() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return createArrayFromList(branches);\n  }\n}\n\nmodule.exports = {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  ReadableStream,\n  IsReadableStreamDisturbed,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure,\n  ReadableStreamDefaultControllerCanCloseOrEnqueue\n};\n\n// Abstract operations for the ReadableStream.\n\nfunction AcquireReadableStreamBYOBReader(stream) {\n  return new ReadableStreamBYOBReader(stream);\n}\n\nfunction AcquireReadableStreamDefaultReader(stream) {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  SetUpReadableStreamDefaultController(\n      stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 0,\n                                  autoAllocateChunkSize = undefined) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nfunction IsReadableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDisturbed(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  return stream._disturbed;\n}\n\nfunction IsReadableStreamLocked(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n  assert(IsReadableStream(source) === true);\n  assert(IsWritableStream(dest) === true);\n  assert(typeof preventClose === 'boolean');\n  assert(typeof preventAbort === 'boolean');\n  assert(typeof preventCancel === 'boolean');\n  assert(signal === undefined || isAbortSignal(signal));\n  assert(IsReadableStreamLocked(source) === false);\n  assert(IsWritableStreamLocked(dest) === false);\n\n  const reader = AcquireReadableStreamDefaultReader(source);\n  const writer = AcquireWritableStreamDefaultWriter(dest);\n\n  let shuttingDown = false;\n\n  // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n  let currentWrite = Promise.resolve();\n\n  return new Promise((resolve, reject) => {\n    let abortAlgorithm;\n    if (signal !== undefined) {\n      abortAlgorithm = () => {\n        const error = new DOMException('Aborted', 'AbortError');\n        const actions = [];\n        if (preventAbort === false) {\n          actions.push(() => {\n            if (dest._state === 'writable') {\n              return WritableStreamAbort(dest, error);\n            }\n            return Promise.resolve();\n          });\n        }\n        if (preventCancel === false) {\n          actions.push(() => {\n            if (source._state === 'readable') {\n              return ReadableStreamCancel(source, error);\n            }\n            return Promise.resolve();\n          });\n        }\n        shutdownWithAction(() => WaitForAllPromise(actions.map(action => action()), results => results), true, error);\n      };\n\n      if (signal.aborted === true) {\n        abortAlgorithm();\n        return;\n      }\n\n      signal.addEventListener('abort', abortAlgorithm);\n    }\n\n    // Using reader and writer, read all chunks from this and write them to dest\n    // - Backpressure must be enforced\n    // - Shutdown must stop all activity\n    function pipeLoop() {\n      return new Promise((resolveLoop, rejectLoop) => {\n        function next(done) {\n          if (done) {\n            resolveLoop();\n          } else {\n            pipeStep().then(next, rejectLoop);\n          }\n        }\n\n        next(false);\n      });\n    }\n\n    function pipeStep() {\n      if (shuttingDown === true) {\n        return Promise.resolve(true);\n      }\n\n      return writer._readyPromise.then(() => {\n        return ReadableStreamDefaultReaderRead(reader).then(({ value, done }) => {\n          if (done === true) {\n            return true;\n          }\n\n          currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(() => {});\n          return false;\n        });\n      });\n    }\n\n    // Errors must be propagated forward\n    isOrBecomesErrored(source, reader._closedPromise, storedError => {\n      if (preventAbort === false) {\n        shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n    });\n\n    // Errors must be propagated backward\n    isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n      if (preventCancel === false) {\n        shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n    });\n\n    // Closing must be propagated forward\n    isOrBecomesClosed(source, reader._closedPromise, () => {\n      if (preventClose === false) {\n        shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n      } else {\n        shutdown();\n      }\n    });\n\n    // Closing must be propagated backward\n    if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\n      const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n      if (preventCancel === false) {\n        shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n      } else {\n        shutdown(true, destClosed);\n      }\n    }\n\n    pipeLoop().catch(err => {\n      currentWrite = Promise.resolve();\n      rethrowAssertionErrorRejection(err);\n    });\n\n    function waitForWritesToFinish() {\n      // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n      // for that too.\n      const oldCurrentWrite = currentWrite;\n      return currentWrite.then(() => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n    }\n\n    function isOrBecomesErrored(stream, promise, action) {\n      if (stream._state === 'errored') {\n        action(stream._storedError);\n      } else {\n        promise.catch(action).catch(rethrowAssertionErrorRejection);\n      }\n    }\n\n    function isOrBecomesClosed(stream, promise, action) {\n      if (stream._state === 'closed') {\n        action();\n      } else {\n        promise.then(action).catch(rethrowAssertionErrorRejection);\n      }\n    }\n\n    function shutdownWithAction(action, originalIsError, originalError) {\n      if (shuttingDown === true) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n        waitForWritesToFinish().then(doTheRest);\n      } else {\n        doTheRest();\n      }\n\n      function doTheRest() {\n        action().then(\n            () => finalize(originalIsError, originalError),\n            newError => finalize(true, newError)\n        )\n            .catch(rethrowAssertionErrorRejection);\n      }\n    }\n\n    function shutdown(isError, error) {\n      if (shuttingDown === true) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n        waitForWritesToFinish().then(() => finalize(isError, error)).catch(rethrowAssertionErrorRejection);\n      } else {\n        finalize(isError, error);\n      }\n    }\n\n    function finalize(isError, error) {\n      WritableStreamDefaultWriterRelease(writer);\n      ReadableStreamReaderGenericRelease(reader);\n\n      if (signal !== undefined) {\n        signal.removeEventListener('abort', abortAlgorithm);\n      }\n      if (isError) {\n        reject(error);\n      } else {\n        resolve(undefined);\n      }\n    }\n  });\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n  assert(IsReadableStream(stream) === true);\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader(stream);\n\n  let closedOrErrored = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1;\n  let reason2;\n  let branch1;\n  let branch2;\n\n  let resolveCancelPromise;\n  const cancelPromise = new Promise(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm() {\n    return ReadableStreamDefaultReaderRead(reader).then(result => {\n      assert(typeIsObject(result));\n      const value = result.value;\n      const done = result.done;\n      assert(typeof done === 'boolean');\n\n      if (done === true && closedOrErrored === false) {\n        if (canceled1 === false) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n        }\n        if (canceled2 === false) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n        }\n        closedOrErrored = true;\n      }\n\n      if (closedOrErrored === true) {\n        return;\n      }\n\n      const value1 = value;\n      const value2 = value;\n\n      // There is no way to access the cloning code right now in the reference implementation.\n      // If we add one then we'll need an implementation for serializable objects.\n      // if (canceled2 === false && cloneForBranch2 === true) {\n      //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n      // }\n\n      if (canceled1 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n      }\n\n      if (canceled2 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n      }\n    });\n  }\n\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {}\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  reader._closedPromise.catch(r => {\n    if (closedOrErrored === true) {\n      return;\n    }\n\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n    closedOrErrored = true;\n  });\n\n  return [branch1, branch2];\n}\n\n// ReadableStream API exposed for controllers.\n\nfunction ReadableStreamAddReadIntoRequest(stream, forAuthorCode) {\n  assert(IsReadableStreamBYOBReader(stream._reader) === true);\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  const promise = new Promise((resolve, reject) => {\n    const readIntoRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _forAuthorCode: forAuthorCode\n    };\n\n    stream._reader._readIntoRequests.push(readIntoRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamAddReadRequest(stream, forAuthorCode) {\n  assert(IsReadableStreamDefaultReader(stream._reader) === true);\n  assert(stream._state === 'readable');\n\n  const promise = new Promise((resolve, reject) => {\n    const readRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _forAuthorCode: forAuthorCode\n    };\n\n    stream._reader._readRequests.push(readRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return sourceCancelPromise.then(() => undefined);\n}\n\nfunction ReadableStreamClose(stream) {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const { _resolve, _forAuthorCode } of reader._readRequests) {\n      _resolve(ReadableStreamCreateReadResult(undefined, true, _forAuthorCode));\n    }\n    reader._readRequests = [];\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  return undefined;\n}\n\nfunction ReadableStreamCreateReadResult(value, done, forAuthorCode) {\n  let prototype = null;\n  if (forAuthorCode === true) {\n    prototype = Object.prototype;\n  }\n  assert(typeof done === 'boolean');\n  const obj = Object.create(prototype);\n  Object.defineProperty(obj, 'value', { value, enumerable: true, writable: true, configurable: true });\n  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });\n  return obj;\n}\n\nfunction ReadableStreamError(stream, e) {\n  assert(IsReadableStream(stream) === true);\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const readRequest of reader._readRequests) {\n      readRequest._reject(e);\n    }\n\n    reader._readRequests = [];\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n\n    for (const readIntoRequest of reader._readIntoRequests) {\n      readIntoRequest._reject(e);\n    }\n\n    reader._readIntoRequests = [];\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n  reader._closedPromise.catch(() => {});\n}\n\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift();\n  readIntoRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readIntoRequest._forAuthorCode));\n}\n\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift();\n  readRequest._resolve(ReadableStreamCreateReadResult(chunk, done, readRequest._forAuthorCode));\n}\n\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n}\n\nfunction ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n}\n\nfunction ReadableStreamHasBYOBReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamBYOBReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamHasDefaultReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nclass ReadableStreamDefaultReader {\n  constructor(stream) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n    }\n    if (IsReadableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = [];\n  }\n\n  get closed() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    return ReadableStreamDefaultReaderRead(this, true);\n  }\n\n  releaseLock() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nclass ReadableStreamBYOBReader {\n  constructor(stream) {\n    if (!IsReadableStream(stream)) {\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\n          'byte source');\n    }\n    if (IsReadableByteStreamController(stream._readableStreamController) === false) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n          'source');\n    }\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = [];\n  }\n\n  get closed() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read(view) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return Promise.reject(new TypeError('view must be an array buffer view'));\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));\n    }\n\n    if (view.byteLength === 0) {\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\n    }\n\n    return ReadableStreamBYOBReaderRead(this, view, true);\n  }\n\n  releaseLock() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\n// Abstract operations for the readers.\n\nfunction IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    reader._closedPromise.catch(() => {});\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nfunction ReadableStreamReaderGenericRelease(reader) {\n  assert(reader._ownerReadableStream !== undefined);\n  assert(reader._ownerReadableStream._reader === reader);\n\n  if (reader._ownerReadableStream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  }\n  reader._closedPromise.catch(() => {});\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n}\n\nfunction ReadableStreamBYOBReaderRead(reader, view, forAuthorCode = false) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  // Controllers must implement this.\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view, forAuthorCode);\n}\n\nfunction ReadableStreamDefaultReaderRead(reader, forAuthorCode = false) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(ReadableStreamCreateReadResult(undefined, true, forAuthorCode));\n  }\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(stream._state === 'readable');\n\n  return stream._readableStreamController[PullSteps](forAuthorCode);\n}\n\n// Controllers\n\nclass ReadableStreamDefaultController {\n  constructor() {\n    throw new TypeError();\n  }\n\n  get desiredSize() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    ResetQueue(this);\n    const result = this._cancelAlgorithm(reason);\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [PullSteps](forAuthorCode) {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested === true && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      return Promise.resolve(ReadableStreamCreateReadResult(chunk, false, forAuthorCode));\n    }\n\n    const pendingPromise = ReadableStreamAddReadRequest(stream, forAuthorCode);\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    return pendingPromise;\n  }\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n      return undefined;\n    },\n    e => {\n      ReadableStreamDefaultControllerError(controller, e);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableStream;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction ReadableStreamDefaultControllerClose(controller) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\n\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerError(controller, e) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue(controller);\n\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  const state = controller._controlledReadableStream._state;\n\n  if (controller._closeRequested === false && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction SetUpReadableStreamDefaultController(\n  stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n    () => {\n      controller._started = true;\n\n      assert(controller._pulling === false);\n      assert(controller._pullAgain === false);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    },\n    r => {\n      ReadableStreamDefaultControllerError(controller, r);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark,\n                                                                  sizeAlgorithm) {\n  assert(underlyingSource !== undefined);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\n\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                       highWaterMark, sizeAlgorithm);\n}\n\nclass ReadableStreamBYOBRequest {\n  constructor() {\n    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\n  }\n\n  get view() {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  respond(bytesWritten) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view.buffer) === true) {\n      throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  respondWithNewView(view) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      throw new TypeError('The supplied view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nclass ReadableByteStreamController {\n  constructor() {\n    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\n  }\n\n  get byobRequest() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      const view = new Uint8Array(firstDescriptor.buffer,\n                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n      SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n      this._byobRequest = byobRequest;\n    }\n\n    return this._byobRequest;\n  }\n\n  get desiredSize() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n    }\n\n    if (IsDetachedBuffer(chunk.buffer) === true) {\n      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    if (this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      firstDescriptor.bytesFilled = 0;\n    }\n\n    ResetQueue(this);\n\n    const result = this._cancelAlgorithm(reason);\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [PullSteps](forAuthorCode) {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream) === true);\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      const entry = this._queue.shift();\n      this._queueTotalSize -= entry.byteLength;\n\n      ReadableByteStreamControllerHandleQueueDrain(this);\n\n      let view;\n      try {\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n      } catch (viewE) {\n        return Promise.reject(viewE);\n      }\n\n      return Promise.resolve(ReadableStreamCreateReadResult(view, false, forAuthorCode));\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        return Promise.reject(bufferE);\n      }\n\n      const pullIntoDescriptor = {\n        buffer,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        ctor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    const promise = ReadableStreamAddReadRequest(stream, forAuthorCode);\n\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n\n    return promise;\n  }\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nfunction IsReadableByteStreamController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      ReadableByteStreamControllerError(controller, e);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = [];\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  assert(stream._state !== 'errored');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.ctor(\n      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue[0];\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (ready === false) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === undefined) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = undefined;\n  controller._byobRequest = undefined;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  assert(controller._closeRequested === false);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos[0];\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerPullInto(controller, view, forAuthorCode) {\n  const stream = controller._controlledReadableByteStream;\n\n  let elementSize = 1;\n  if (view.constructor !== DataView) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n\n  const ctor = view.constructor;\n\n  const buffer = TransferArrayBuffer(view.buffer);\n  const pullIntoDescriptor = {\n    buffer,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize,\n    ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    return ReadableStreamAddReadIntoRequest(stream, forAuthorCode);\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    return Promise.resolve(ReadableStreamCreateReadResult(emptyView, true, forAuthorCode));\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      return Promise.resolve(ReadableStreamCreateReadResult(filledView, false, forAuthorCode));\n    }\n\n    if (controller._closeRequested === true) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      return Promise.reject(e);\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  const promise = ReadableStreamAddReadIntoRequest(stream, forAuthorCode);\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n\n  return promise;\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  assert(firstDescriptor.bytesFilled === 0);\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream) === true) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n    throw new RangeError('bytesWritten out of range');\n  }\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    // TODO: Figure out whether we should detach the buffer or not here.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(stream._state === 'readable');\n\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  const descriptor = controller._pendingPullIntos.shift();\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested === true) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nfunction ReadableByteStreamControllerClose(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\n\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  const buffer = chunk.buffer;\n  const byteOffset = chunk.byteOffset;\n  const byteLength = chunk.byteLength;\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (ReadableStreamHasDefaultReader(stream) === true) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(IsReadableStreamLocked(stream) === false);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerError(controller, e) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableByteStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\n    throw new RangeError('bytesWritten must be a finite');\n  }\n\n  assert(controller._pendingPullIntos.length > 0);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.byteLength !== view.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n\n  firstDescriptor.buffer = view.buffer;\n\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\n\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                           highWaterMark, autoAllocateChunkSize) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = [];\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n      () => {\n        controller._started = true;\n\n        assert(controller._pulling === false);\n        assert(controller._pullAgain === false);\n\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      },\n      r => {\n        ReadableByteStreamControllerError(controller, r);\n      }\n  )\n      .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n  assert(underlyingByteSource !== undefined);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\n\n  let autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize !== undefined) {\n    autoAllocateChunkSize = Number(autoAllocateChunkSize);\n    if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\n      throw new RangeError('autoAllocateChunkSize must be a positive integer');\n    }\n  }\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n}\n\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n  assert(IsReadableByteStreamController(controller) === true);\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view) === true);\n  assert(IsDetachedBuffer(view.buffer) === false);\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStream.\n\nfunction isAbortSignal(value) {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n\n  // Use the brand check to distinguish a real AbortSignal from a fake one.\n  const aborted = Object.getOwnPropertyDescriptor(AbortSignal.prototype, 'aborted').get;\n  try {\n    aborted.call(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\n// Helper functions for the readers.\n\nfunction readerLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\nfunction defaultReaderClosedPromiseInitialize(reader) {\n  reader._closedPromise = new Promise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  reader._closedPromise = Promise.reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  reader._closedPromise = Promise.resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  reader._closedPromise = Promise.reject(reason);\n}\n\nfunction defaultReaderClosedPromiseResolve(reader) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction byobReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n","'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class ByteLengthQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size(chunk) {\n    return chunk.byteLength;\n  }\n};\n","'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class CountQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size() {\n    return 1;\n  }\n};\n","'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:transform-stream:verbose');\nconst { InvokeOrNoop, CreateAlgorithmFromUnderlyingMethod, PromiseCall, typeIsObject,\n        ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction } = require('./helpers.js');\nconst { CreateReadableStream, ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue,\n        ReadableStreamDefaultControllerError, ReadableStreamDefaultControllerGetDesiredSize,\n        ReadableStreamDefaultControllerHasBackpressure,\n        ReadableStreamDefaultControllerCanCloseOrEnqueue } = require('./readable-stream.js');\nconst { CreateWritableStream, WritableStreamDefaultControllerErrorIfNeeded } = require('./writable-stream.js');\n\n// Class TransformStream\n\nclass TransformStream {\n  constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\n    const writableSizeFunction = writableStrategy.size;\n    let writableHighWaterMark = writableStrategy.highWaterMark;\n    const readableSizeFunction = readableStrategy.size;\n    let readableHighWaterMark = readableStrategy.highWaterMark;\n\n    const writableType = transformer.writableType;\n\n    if (writableType !== undefined) {\n      throw new RangeError('Invalid writable type specified');\n    }\n\n    const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\n    if (writableHighWaterMark === undefined) {\n      writableHighWaterMark = 1;\n    }\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\n\n    const readableType = transformer.readableType;\n\n    if (readableType !== undefined) {\n      throw new RangeError('Invalid readable type specified');\n    }\n\n    const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\n    if (readableHighWaterMark === undefined) {\n      readableHighWaterMark = 0;\n    }\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\n\n    let startPromise_resolve;\n    const startPromise = new Promise(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                              readableSizeAlgorithm);\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    const startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\n    startPromise_resolve(startResult);\n  }\n\n  get readable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  get writable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\n// Transform Stream Abstract Operations\n\nfunction CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark = 1,\n                               writableSizeAlgorithm = () => 1, readableHighWaterMark = 0,\n                               readableSizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve;\n  const startPromise = new Promise(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm,\n                                   readableHighWaterMark, readableSizeAlgorithm) {\n  function startAlgorithm() {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk) {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason) {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm() {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm() {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason) {\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n    return Promise.resolve();\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined;\n  stream._backpressureChangePromise = undefined;\n  stream._backpressureChangePromise_resolve = undefined;\n  TransformStreamSetBackpressure(stream, true);\n\n  // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\n  stream._transformStreamController = undefined;\n}\n\nfunction IsTransformStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n  verbose('TransformStreamError()');\n\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  if (stream._backpressure === true) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n  verbose(`TransformStreamSetBackpressure() [backpressure = ${backpressure}]`);\n\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = new Promise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\nclass TransformStreamDefaultController {\n  constructor() {\n    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\n  }\n\n  get desiredSize() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n\n  enqueue(chunk) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(reason) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  terminate() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n  assert(IsTransformStream(stream) === true);\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n  assert(transformer !== undefined);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm = chunk => {\n    try {\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\n      return Promise.resolve();\n    } catch (transformResultE) {\n      return Promise.reject(transformResultE);\n    }\n  };\n  const transformMethod = transformer.transform;\n  if (transformMethod !== undefined) {\n    if (typeof transformMethod !== 'function') {\n      throw new TypeError('transform is not a method');\n    }\n    transformAlgorithm = chunk => PromiseCall(transformMethod, transformer, [chunk, controller]);\n  }\n\n  const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n  controller._transformAlgorithm = undefined;\n  controller._flushAlgorithm = undefined;\n}\n\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  verbose('TransformStreamDefaultControllerEnqueue()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure === true);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller, e) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n  const transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromise.catch(r => {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\n\nfunction TransformStreamDefaultControllerTerminate(controller) {\n  verbose('TransformStreamDefaultControllerTerminate()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n    ReadableStreamDefaultControllerClose(readableController);\n  }\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n  verbose('TransformStreamDefaultSinkWriteAlgorithm()');\n\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure === true) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return backpressureChangePromise\n        .then(() => {\n          const writable = stream._writable;\n          const state = writable._state;\n          if (state === 'erroring') {\n            throw writable._storedError;\n          }\n          assert(state === 'writable');\n          return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n        });\n  }\n\n  return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n  // errored.\n  TransformStreamError(stream, reason);\n  return Promise.resolve();\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n  verbose('TransformStreamDefaultSinkCloseAlgorithm()');\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  const controller = stream._transformStreamController;\n  const flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  // Return a promise that is fulfilled with undefined on success.\n  return flushPromise.then(() => {\n    if (readable._state === 'errored') {\n      throw readable._storedError;\n    }\n    const readableController = readable._readableStreamController;\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n      ReadableStreamDefaultControllerClose(readableController);\n    }\n  }).catch(r => {\n    TransformStreamError(stream, r);\n    throw readable._storedError;\n  });\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n  verbose('TransformStreamDefaultSourcePullAlgorithm()');\n\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure === true);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\nmodule.exports = { CreateTransformStream, TransformStream };\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n","import {\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  ReadableStream,\n  TransformStream,\n  WritableStream\n} from './ponyfill';\nimport { globals } from './utils';\n\n// Export\nexport * from './ponyfill';\n\nconst exports = {\n  ReadableStream,\n  WritableStream,\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  TransformStream\n};\n\n// Add classes to global scope\nif (typeof globals !== 'undefined') {\n  Object.assign(globals, exports);\n}\n"],"names":["SymbolPolyfill","Symbol","iterator","description","NumberIsInteger","Number","isInteger","value","isFinite","Math","floor","noop","globals","self","window","global","NumberIsNaN","isNaN","x","isFakeDetached","Call","F","V","args","TypeError","Function","prototype","apply","call","PromiseCall","Promise","resolve","reject","exports","o","p","v","Object","defineProperty","writable","enumerable","configurable","elements","slice","dest","destOffset","src","srcOffset","n","Uint8Array","set","IsNonNegativeNumber","Infinity","Number.isNaN","underlyingObject","methodName","algoArgCount","extraArgs","method","undefined","arg","fullArgs","concat","O","P","transferredIshVersion","get","highWaterMark","RangeError","size","chunk","promise","onFulfilled","onRejected","then","promises","successSteps","failureSteps","rejected","rejectionHandler","index","fulfilledCount","total","length","result","Array","promiseIndex","PerformPromiseThen","resolvePromise","rejectPromise","WaitForAll","results","stepsResult","e","reason","assert","AssertionError","setTimeout","IsFiniteNonNegativeNumber","require$$0","container","pair","_queue","shift","_queueTotalSize","push","CreateAlgorithmFromUnderlyingMethod","require$$1","InvokeOrNoop","ValidateAndNormalizeHighWaterMark","MakeSizeAlgorithmFromSizeFunction","typeIsObject","rethrowAssertionErrorRejection","require$$2","DequeueValue","require$$3","EnqueueValueWithSize","PeekQueueValue","ResetQueue","AbortSteps","ErrorSteps","WritableStream","underlyingSink","strategy","InitializeWritableStream","this","type","sizeAlgorithm","stream","controller","create","WritableStreamDefaultController","writeAlgorithm","closeAlgorithm","abortAlgorithm","SetUpWritableStreamDefaultController","SetUpWritableStreamDefaultControllerFromUnderlyingSink","abort","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","WritableStreamAbort","getWriter","AcquireWritableStreamDefaultWriter","CreateWritableStream","startAlgorithm","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultWriterCloseWithErrorPropagation","writer","_ownerWritableStream","state","_state","WritableStreamCloseQueuedOrInFlight","_storedError","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamDefaultWriter","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","hasOwnProperty","_promise","wasAlreadyErroring","_resolve","_reject","_reason","_wasAlreadyErroring","WritableStreamStartErroring","WritableStreamDealWithRejection","error","WritableStreamFinishErroring","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","_started","storedError","abortRequest","WritableStreamRejectCloseAndClosedPromiseIfNeeded","WritableStreamFinishInFlightClose","_closedPromise_resolve","_closedPromise_reject","_closedPromiseState","defaultWriterClosedPromiseResolve","defaultWriterClosedPromiseReject","_closedPromise","catch","WritableStreamUpdateBackpressure","backpressure","_readyPromise","_readyPromise_resolve","_readyPromise_reject","_readyPromiseState","defaultWriterReadyPromiseReset","defaultWriterReadyPromiseResolve","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseInitializeAsResolved","defaultWriterClosedPromiseInitializeAsRejected","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultWriterAbort","close","releaseLock","write","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterGetDesiredSize","closeRequest","WritableStreamDefaultControllerAdvanceQueueIfNeeded","WritableStreamDefaultControllerClose","WritableStreamDefaultWriterEnsureClosedPromiseRejected","defaultWriterClosedPromiseResetToRejected","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","releasedError","chunkSize","_strategySizeAlgorithm","chunkSizeE","WritableStreamDefaultControllerGetChunkSize","writeRequest","WritableStreamAddWriteRequest","writeRecord","enqueueE","_controlledWritableStream","WritableStreamDefaultControllerGetBackpressure","WritableStreamDefaultControllerWrite","IsWritableStreamDefaultController","WritableStreamDefaultControllerError","_abortAlgorithm","WritableStreamDefaultControllerClearAlgorithms","_strategyHWM","_writeAlgorithm","_closeAlgorithm","startResult","r","WritableStreamMarkCloseRequestInFlight","sinkClosePromise","WritableStreamFinishInFlightCloseWithError","WritableStreamDefaultControllerProcessClose","WritableStreamMarkFirstWriteRequestInFlight","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamDefaultControllerProcessWrite","name","ArrayBufferCopy","IsDetachedBuffer","TransferArrayBuffer","createArrayFromList","WaitForAllPromise","CancelSteps","PullSteps","ReadableStream","underlyingSource","InitializeReadableStream","String","underlyingByteSource","ReadableByteStreamController","pullAlgorithm","cancelAlgorithm","autoAllocateChunkSize","Number.isInteger","SetUpReadableByteStreamController","SetUpReadableByteStreamControllerFromUnderlyingSource","ReadableStreamDefaultController","SetUpReadableStreamDefaultController","SetUpReadableStreamDefaultControllerFromUnderlyingSource","cancel","IsReadableStream","IsReadableStreamLocked","ReadableStreamCancel","getReader","mode","AcquireReadableStreamDefaultReader","ReadableStreamBYOBReader","AcquireReadableStreamBYOBReader","pipeThrough","readable","preventClose","preventAbort","preventCancel","signal","Boolean","isAbortSignal","ReadableStreamPipeTo","pipeTo","tee","branches","cloneForBranch2","reason1","reason2","branch1","branch2","resolveCancelPromise","reader","closedOrErrored","canceled1","canceled2","cancelPromise","ReadableStreamDefaultReaderRead","done","ReadableStreamDefaultControllerClose","_readableStreamController","value1","value2","ReadableStreamDefaultControllerEnqueue","CreateReadableStream","compositeReason","cancelResult","ReadableStreamDefaultControllerError","ReadableStreamTee","CreateReadableByteStream","IsReadableStreamDisturbed","_disturbed","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerHasBackpressure","ReadableStreamDefaultControllerShouldCallPull","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamDefaultReader","_reader","source","shuttingDown","currentWrite","DOMException","actions","shutdownWithAction","map","action","aborted","addEventListener","isOrBecomesErrored","shutdown","isOrBecomesClosed","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","ReadableStreamReaderGenericRelease","removeEventListener","resolveLoop","rejectLoop","next","err","ReadableStreamAddReadIntoRequest","forAuthorCode","readIntoRequest","_forAuthorCode","_readIntoRequests","ReadableStreamAddReadRequest","readRequest","_readRequests","ReadableStreamClose","IsReadableStreamDefaultReader","ReadableStreamCreateReadResult","defaultReaderClosedPromiseResolve","obj","ReadableStreamError","defaultReaderClosedPromiseReject","ReadableStreamFulfillReadRequest","ReadableStreamGetNumReadIntoRequests","ReadableStreamGetNumReadRequests","ReadableStreamHasBYOBReader","IsReadableStreamBYOBReader","ReadableStreamHasDefaultReader","ReadableStreamReaderGenericInitialize","defaultReaderBrandCheckException","_ownerReadableStream","readerLockException","ReadableStreamReaderGenericCancel","read","IsReadableByteStreamController","byobReaderBrandCheckException","view","ArrayBuffer","isView","buffer","byteLength","_controlledReadableByteStream","elementSize","constructor","DataView","BYTES_PER_ELEMENT","ctor","pullIntoDescriptor","byteOffset","bytesFilled","readerType","_pendingPullIntos","emptyView","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","ReadableByteStreamControllerHandleQueueDrain","_closeRequested","ReadableByteStreamControllerError","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerPullInto","ReadableStreamBYOBReaderRead","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","defaultReaderClosedPromiseResetToRejected","IsReadableStreamDefaultController","defaultControllerBrandCheckException","enqueue","_cancelAlgorithm","ReadableStreamDefaultControllerClearAlgorithms","_controlledReadableStream","ReadableStreamDefaultControllerCallPullIfNeeded","pendingPromise","_pulling","_pullAlgorithm","_pullAgain","ReadableStreamBYOBRequest","respond","bytesWritten","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_associatedReadableByteStreamController","_view","ReadableByteStreamControllerRespondInternal","ReadableByteStreamControllerRespond","respondWithNewView","firstDescriptor","ReadableByteStreamControllerRespondWithNewView","byteStreamControllerBrandCheckException","firstPendingPullInto","ReadableByteStreamControllerClearAlgorithms","ReadableByteStreamControllerClose","transferredBuffer","ReadableByteStreamControllerEnqueueChunkToQueue","transferredView","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerEnqueue","entry","viewE","_autoAllocateChunkSize","bufferE","_byobRequest","byobRequest","request","SetUpReadableStreamBYOBRequest","ReadableByteStreamControllerGetDesiredSize","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerClearPendingPullIntos","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerCommitPullIntoDescriptor","ReadableStreamFulfillReadIntoRequest","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerRespondInClosedState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInReadableState","descriptor","getOwnPropertyDescriptor","AbortSignal","createDataProperty","TransformStream","transformer","writableStrategy","readableStrategy","writableSizeFunction","writableHighWaterMark","readableSizeFunction","readableHighWaterMark","writableType","writableSizeAlgorithm","readableType","startPromise_resolve","readableSizeAlgorithm","InitializeTransformStream","TransformStreamDefaultController","transformAlgorithm","TransformStreamDefaultControllerEnqueue","transformResultE","transformMethod","transform","flushAlgorithm","SetUpTransformStreamDefaultController","SetUpTransformStreamDefaultControllerFromTransformer","_transformStreamController","IsTransformStream","_readable","_writable","startPromise","backpressureChangePromise","_backpressureChangePromise","TransformStreamDefaultControllerPerformTransform","TransformStreamDefaultSinkWriteAlgorithm","flushPromise","_flushAlgorithm","TransformStreamDefaultControllerClearAlgorithms","readableController","TransformStreamError","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamSetBackpressure","TransformStreamDefaultSourcePullAlgorithm","TransformStreamErrorWritableAndUnblockWrite","_backpressureChangePromise_resolve","IsTransformStreamDefaultController","_controlledTransformStream","TransformStreamDefaultControllerError","terminate","TransformStreamDefaultControllerTerminate","_transformAlgorithm","CreateTransformStream","ByteLengthQueuingStrategy","CountQueuingStrategy"],"mappings":"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"}