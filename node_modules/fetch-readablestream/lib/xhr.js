'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeXhrTransport = makeXhrTransport;
exports.parseResposneHeaders = parseResposneHeaders;

var _Headers = require('./polyfill/Headers');

function createAbortError() {
  // From https://github.com/mo/abortcontroller-polyfill/blob/master/src/abortableFetch.js#L56-L64

  try {
    return new DOMException('Aborted', 'AbortError');
  } catch (err) {
    // IE 11 does not support calling the DOMException constructor, use a
    // regular error object on it instead.
    var abortError = new Error('Aborted');
    abortError.name = 'AbortError';
    return abortError;
  }
}

function makeXhrTransport(_ref) {
  var responseType = _ref.responseType,
      responseParserFactory = _ref.responseParserFactory;

  return function xhrTransport(url, options) {
    var xhr = new XMLHttpRequest();
    var responseParser = responseParserFactory();

    var responseStreamController = void 0;
    var cancelled = false;

    var responseStream = new ReadableStream({
      start: function start(c) {
        responseStreamController = c;
      },
      cancel: function cancel() {
        cancelled = true;
        xhr.abort();
      }
    });

    var _options$method = options.method,
        method = _options$method === undefined ? 'GET' : _options$method,
        signal = options.signal;


    xhr.open(method, url);
    xhr.responseType = responseType;
    xhr.withCredentials = options.credentials !== 'omit';
    if (options.headers) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = options.headers.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pair = _step.value;

          xhr.setRequestHeader(pair[0], pair[1]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    return new Promise(function (resolve, reject) {
      if (options.body && (method === 'GET' || method === 'HEAD')) {
        reject(new TypeError("Failed to execute 'fetchStream' on 'Window': Request with GET/HEAD method cannot have body"));
      }

      if (signal) {
        if (signal.aborted) {
          // If already aborted, reject immediately & send nothing.
          reject(createAbortError());
          return;
        } else {
          signal.addEventListener('abort', function () {
            // If we abort later, kill the XHR & reject the promise if possible.
            xhr.abort();
            if (responseStreamController) {
              responseStreamController.error(createAbortError());
            }
            reject(createAbortError());
          }, { once: true });
        }
      }

      xhr.onreadystatechange = function () {
        if (xhr.readyState === xhr.HEADERS_RECEIVED) {
          return resolve({
            body: responseStream,
            headers: parseResposneHeaders(xhr.getAllResponseHeaders()),
            ok: xhr.status >= 200 && xhr.status < 300,
            status: xhr.status,
            statusText: xhr.statusText,
            url: makeResponseUrl(xhr.responseURL, url)
          });
        }
      };

      xhr.onerror = function () {
        return reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function () {
        reject(new TypeError('Network request failed'));
      };

      xhr.onprogress = function () {
        if (!cancelled) {
          var bytes = responseParser(xhr.response);
          responseStreamController.enqueue(bytes);
        }
      };

      xhr.onload = function () {
        responseStreamController.close();
      };

      xhr.send(options.body);
    });
  };
}

function makeHeaders() {
  // Prefer the native method if provided by the browser.
  if (typeof Headers !== 'undefined') {
    return new Headers();
  }
  return new _Headers.Headers();
}

function makeResponseUrl(responseUrl, requestUrl) {
  if (!responseUrl) {
    // best guess; note this will not correctly handle redirects.
    if (requestUrl.substring(0, 4) !== "http") {
      return location.origin + requestUrl;
    }
    return requestUrl;
  }
  return responseUrl;
}

function parseResposneHeaders(str) {
  var hdrs = makeHeaders();
  if (str) {
    var pairs = str.split('\r\n');
    for (var i = 0; i < pairs.length; i++) {
      var p = pairs[i];
      var index = p.indexOf(': ');
      if (index > 0) {
        var key = p.substring(0, index);
        var value = p.substring(index + 2);
        hdrs.append(key, value);
      }
    }
  }
  return hdrs;
}