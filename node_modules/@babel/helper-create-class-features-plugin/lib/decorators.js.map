{"version":3,"names":["_core","require","_helperReplaceSupers","_helperSplitExportDeclaration","_helperSkipTransparentExpressionWrappers","incrementId","id","idx","length","unshift","current","createPrivateUidGeneratorForClass","classPath","currentPrivateId","privateNames","Set","traverse","PrivateName","path","add","node","name","reifiedId","String","fromCharCode","has","t","privateName","identifier","createLazyPrivateUidGeneratorForClass","generator","replaceClassWithVar","className","type","varId","scope","generateUidIdentifierBasedOnNode","classId","rename","get","replaceWith","cloneNode","parent","generateDeclaredUidIdentifier","newClassExpr","classExpression","superClass","body","newPath","sequenceExpression","generateClassProperty","key","value","isStatic","classPrivateProperty","undefined","classProperty","addProxyAccessorsFor","element","originalKey","targetKey","version","isComputed","static","thisArg","thisExpression","getterBody","blockStatement","returnStatement","memberExpression","setterBody","expressionStatement","assignmentExpression","getter","setter","classPrivateMethod","classMethod","insertAfter","extractProxyAccessorsFor","template","expression","ast","FIELD","ACCESSOR","METHOD","GETTER","SETTER","STATIC_OLD_VERSION","STATIC","DECORATORS_HAVE_THIS","getElementKind","kind","isDecoratorInfo","info","filteredOrderedDecoratorInfo","filtered","filter","el","generateDecorationList","decorators","decoratorsThis","decsCount","hasOneThis","some","Boolean","decs","i","push","unaryExpression","numericLiteral","hasThis","generateDecorationExprs","arrayExpression","map","flag","privateMethods","extractElementLocalAssignments","decorationInfo","localIds","locals","Array","isArray","addCallAccessorsFor","getId","setId","callExpression","isNotTsParameter","movePrivateAccessor","methodLocalVar","params","block","isClassDecoratableElementPath","staticBlockToIIFE","arrowFunctionExpression","maybeSequenceExpression","exprs","createSetFunctionNameCall","state","addHelper","createToPropertyKeyCall","propertyKey","transformClass","constantSuper","propertyVisitor","classDecorators","hasElementDecorators","generateClassPrivateUid","assignments","scopeParent","memoiseExpression","hint","localEvaluatedId","ClassProperty","ClassPrivateProperty","ClassAccessorProperty","computed","newId","newField","keyPath","isConstantExpression","insertBefore","expr","crawl","elementDecoratorInfo","firstFieldPath","constructorPath","requiresProtoInit","requiresStaticInit","decoratedPrivateMethods","protoInitLocal","staticInitLocal","classInitLocal","classIdLocal","Map","maybeExtractDecorator","decorator","isMemberExpression","object","isSuper","isThisExpression","set","needsDeclaraionForClassBinding","isClassDeclaration","classDecorator","generateUidIdentifier","lastInstancePrivateName","needsInstancePrivateBrandCheck","hasDecorators","decoratorPath","isPrivate","isClassPrivateProperty","isClassMethod","newFieldInitId","newValue","initId","valuePath","v","replaceSupers","ReplaceSupers","methodPath","objectRef","superRef","file","refToPreserve","replace","async","isAsync","functionExpression","remove","nameExpr","stringLiteral","d","elementDecorations","classDecorationsFlag","classDecorations","dec","elementLocals","protoInitCall","CallExpression","exit","skip","ClassMethod","super","spreadElement","restElement","size","parentPath","parentParentPath","left","buildCodeFrameError","classLocals","classInitInjected","classInitCall","originalClass","statics","staticBlocks","forEach","isStaticBlock","isProperty","isClassProperty","isClassPrivateMethod","allValues","staticsClass","staticBlock","toStatement","constructorBody","newExpr","newExpression","arguments","maybeGenerateMemoised","createLocalsAssignment","variableDeclaration","variableDeclarator","maybePrivateBranName","setClassName","lhs","rhs","args","availableHelper","arrayPattern","objectPattern","objectProperty","isProtoKey","isDecorated","shouldTransformElement","shouldTransformClass","NamedEvaluationVisitoryFactory","isAnonymous","visitor","handleComputedProperty","propertyPath","keyValue","ref","VariableDeclarator","initializer","skipTransparentExprWrappers","AssignmentExpression","operator","AssignmentPattern","ObjectExpression","isDecoratedAnonymousClassExpression","isClassExpression","_default","assertVersion","assumption","loose","inherits","_assumption","VISITED","WeakSet","namedEvaluationVisitor","visitClass","_className","_node$id","Object","assign","ExportDefaultDeclaration","declaration","updatedVarDeclarationPath","splitExportDeclaration","ExportNamedDeclaration","Class"],"sources":["../src/decorators.ts"],"sourcesContent":["import type { NodePath, Scope, Visitor } from \"@babel/traverse\";\nimport { types as t, template } from \"@babel/core\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport * as charCodes from \"charcodes\";\nimport type { PluginAPI, PluginObject, PluginPass } from \"@babel/core\";\nimport { skipTransparentExprWrappers } from \"@babel/helper-skip-transparent-expression-wrappers\";\n\ninterface Options {\n  /** @deprecated use `constantSuper` assumption instead. Only supported in 2021-12 version. */\n  loose?: boolean;\n}\n\ntype ClassDecoratableElement =\n  | t.ClassMethod\n  | t.ClassPrivateMethod\n  | t.ClassProperty\n  | t.ClassPrivateProperty\n  | t.ClassAccessorProperty;\n\ntype ClassElement =\n  | ClassDecoratableElement\n  | t.TSDeclareMethod\n  | t.TSIndexSignature\n  | t.StaticBlock;\n\ntype DecoratorVersionKind = \"2023-05\" | \"2023-01\" | \"2022-03\" | \"2021-12\";\n\nfunction incrementId(id: number[], idx = id.length - 1): void {\n  // If index is -1, id needs an additional character, unshift A\n  if (idx === -1) {\n    id.unshift(charCodes.uppercaseA);\n    return;\n  }\n\n  const current = id[idx];\n\n  if (current === charCodes.uppercaseZ) {\n    // if current is Z, skip to a\n    id[idx] = charCodes.lowercaseA;\n  } else if (current === charCodes.lowercaseZ) {\n    // if current is z, reset to A and carry the 1\n    id[idx] = charCodes.uppercaseA;\n    incrementId(id, idx - 1);\n  } else {\n    // else, increment by one\n    id[idx] = current + 1;\n  }\n}\n\n/**\n * Generates a new private name that is unique to the given class. This can be\n * used to create extra class fields and methods for the implementation, while\n * keeping the length of those names as small as possible. This is important for\n * minification purposes (though private names can generally be minified,\n * transpilations and polyfills cannot yet).\n */\nfunction createPrivateUidGeneratorForClass(\n  classPath: NodePath<t.ClassDeclaration | t.ClassExpression>,\n): () => t.PrivateName {\n  const currentPrivateId: number[] = [];\n  const privateNames = new Set<string>();\n\n  classPath.traverse({\n    PrivateName(path) {\n      privateNames.add(path.node.id.name);\n    },\n  });\n\n  return (): t.PrivateName => {\n    let reifiedId;\n    do {\n      incrementId(currentPrivateId);\n      reifiedId = String.fromCharCode(...currentPrivateId);\n    } while (privateNames.has(reifiedId));\n\n    return t.privateName(t.identifier(reifiedId));\n  };\n}\n\n/**\n * Wraps the above generator function so that it's run lazily the first time\n * it's actually required. Several types of decoration do not require this, so it\n * saves iterating the class elements an additional time and allocating the space\n * for the Sets of element names.\n */\nfunction createLazyPrivateUidGeneratorForClass(\n  classPath: NodePath<t.ClassDeclaration | t.ClassExpression>,\n): () => t.PrivateName {\n  let generator: () => t.PrivateName;\n\n  return (): t.PrivateName => {\n    if (!generator) {\n      generator = createPrivateUidGeneratorForClass(classPath);\n    }\n\n    return generator();\n  };\n}\n\n/**\n * Takes a class definition and the desired class name if anonymous and\n * replaces it with an equivalent class declaration (path) which is then\n * assigned to a local variable (id). This allows us to reassign the local variable with the\n * decorated version of the class. The class definition retains its original\n * name so that `toString` is not affected, other references to the class\n * are renamed instead.\n */\nfunction replaceClassWithVar(\n  path: NodePath<t.ClassDeclaration | t.ClassExpression>,\n  className: string | t.Identifier | t.StringLiteral | undefined,\n): {\n  id: t.Identifier;\n  path: NodePath<t.ClassDeclaration | t.ClassExpression>;\n} {\n  if (path.type === \"ClassDeclaration\") {\n    const id = path.node.id;\n    const className = id.name;\n    const varId = path.scope.generateUidIdentifierBasedOnNode(id);\n    const classId = t.identifier(className);\n\n    path.scope.rename(className, varId.name);\n\n    path.get(\"id\").replaceWith(classId);\n\n    return { id: t.cloneNode(varId), path };\n  } else {\n    let varId: t.Identifier;\n\n    if (path.node.id) {\n      className = path.node.id.name;\n      varId = path.scope.parent.generateDeclaredUidIdentifier(className);\n      path.scope.rename(className, varId.name);\n    } else {\n      varId = path.scope.parent.generateDeclaredUidIdentifier(\n        typeof className === \"string\" ? className : \"decorated_class\",\n      );\n    }\n\n    const newClassExpr = t.classExpression(\n      typeof className === \"string\" ? t.identifier(className) : null,\n      path.node.superClass,\n      path.node.body,\n    );\n\n    const [newPath] = path.replaceWith(\n      t.sequenceExpression([newClassExpr, varId]),\n    );\n\n    return {\n      id: t.cloneNode(varId),\n      path: newPath.get(\"expressions.0\") as NodePath<t.ClassExpression>,\n    };\n  }\n}\n\nfunction generateClassProperty(\n  key: t.PrivateName | t.Identifier,\n  value: t.Expression | undefined,\n  isStatic: boolean,\n): t.ClassPrivateProperty | t.ClassProperty {\n  if (key.type === \"PrivateName\") {\n    return t.classPrivateProperty(key, value, undefined, isStatic);\n  } else {\n    return t.classProperty(key, value, undefined, undefined, isStatic);\n  }\n}\n\nfunction addProxyAccessorsFor(\n  className: t.Identifier,\n  element: NodePath<ClassDecoratableElement>,\n  originalKey: t.PrivateName | t.Expression,\n  targetKey: t.PrivateName,\n  version: DecoratorVersionKind,\n  isComputed = false,\n): void {\n  const { static: isStatic } = element.node;\n\n  const thisArg =\n    version === \"2023-05\" && isStatic ? className : t.thisExpression();\n\n  const getterBody = t.blockStatement([\n    t.returnStatement(\n      t.memberExpression(t.cloneNode(thisArg), t.cloneNode(targetKey)),\n    ),\n  ]);\n\n  const setterBody = t.blockStatement([\n    t.expressionStatement(\n      t.assignmentExpression(\n        \"=\",\n        t.memberExpression(t.cloneNode(thisArg), t.cloneNode(targetKey)),\n        t.identifier(\"v\"),\n      ),\n    ),\n  ]);\n\n  let getter: t.ClassMethod | t.ClassPrivateMethod,\n    setter: t.ClassMethod | t.ClassPrivateMethod;\n\n  if (originalKey.type === \"PrivateName\") {\n    getter = t.classPrivateMethod(\n      \"get\",\n      t.cloneNode(originalKey),\n      [],\n      getterBody,\n      isStatic,\n    );\n    setter = t.classPrivateMethod(\n      \"set\",\n      t.cloneNode(originalKey),\n      [t.identifier(\"v\")],\n      setterBody,\n      isStatic,\n    );\n  } else {\n    getter = t.classMethod(\n      \"get\",\n      t.cloneNode(originalKey),\n      [],\n      getterBody,\n      isComputed,\n      isStatic,\n    );\n    setter = t.classMethod(\n      \"set\",\n      t.cloneNode(originalKey),\n      [t.identifier(\"v\")],\n      setterBody,\n      isComputed,\n      isStatic,\n    );\n  }\n\n  element.insertAfter(setter);\n  element.insertAfter(getter);\n}\n\nfunction extractProxyAccessorsFor(\n  targetKey: t.PrivateName,\n  version: DecoratorVersionKind,\n): (t.FunctionExpression | t.ArrowFunctionExpression)[] {\n  if (version !== \"2023-05\" && version !== \"2023-01\") {\n    return [\n      template.expression.ast`\n        function () {\n          return this.${t.cloneNode(targetKey)};\n        }\n      ` as t.FunctionExpression,\n      template.expression.ast`\n        function (value) {\n          this.${t.cloneNode(targetKey)} = value;\n        }\n      ` as t.FunctionExpression,\n    ];\n  }\n  return [\n    template.expression.ast`\n      o => o.${t.cloneNode(targetKey)}\n    ` as t.ArrowFunctionExpression,\n    template.expression.ast`\n      (o, v) => o.${t.cloneNode(targetKey)} = v\n    ` as t.ArrowFunctionExpression,\n  ];\n}\n\n// 3 bits reserved to this (0-7)\nconst FIELD = 0;\nconst ACCESSOR = 1;\nconst METHOD = 2;\nconst GETTER = 3;\nconst SETTER = 4;\n\nconst STATIC_OLD_VERSION = 5; // Before 2023-05\nconst STATIC = 8; // 1 << 3\nconst DECORATORS_HAVE_THIS = 16; // 1 << 3\n\nfunction getElementKind(element: NodePath<ClassDecoratableElement>): number {\n  switch (element.node.type) {\n    case \"ClassProperty\":\n    case \"ClassPrivateProperty\":\n      return FIELD;\n    case \"ClassAccessorProperty\":\n      return ACCESSOR;\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (element.node.kind === \"get\") {\n        return GETTER;\n      } else if (element.node.kind === \"set\") {\n        return SETTER;\n      } else {\n        return METHOD;\n      }\n  }\n}\n\n// Information about the decorators applied to an element\ninterface DecoratorInfo {\n  // The expressions of the decorators themselves\n  decorators: t.Expression[];\n  decoratorsThis: t.Expression[];\n\n  // The kind of the decorated value, matches the kind value passed to applyDecs\n  kind: number;\n\n  // whether or not the field is static\n  isStatic: boolean;\n\n  // The name of the decorator\n  name: t.StringLiteral | t.Expression;\n\n  privateMethods:\n    | (t.FunctionExpression | t.ArrowFunctionExpression)[]\n    | undefined;\n\n  // The names of local variables that will be used/returned from the decoration\n  locals: t.Identifier | t.Identifier[] | undefined;\n}\n\n// Information about a computed property key. These must be evaluated\n// interspersed with decorator expressions, which is why they get added to the\n// array of DecoratorInfos later on.\ninterface ComputedPropInfo {\n  localComputedNameId: t.Identifier;\n  keyNode: t.Expression;\n}\n\nfunction isDecoratorInfo(\n  info: DecoratorInfo | ComputedPropInfo,\n): info is DecoratorInfo {\n  return \"decorators\" in info;\n}\n\nfunction filteredOrderedDecoratorInfo(\n  info: (DecoratorInfo | ComputedPropInfo)[],\n): DecoratorInfo[] {\n  const filtered = info.filter(isDecoratorInfo);\n\n  return [\n    ...filtered.filter(\n      el => el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER,\n    ),\n    ...filtered.filter(\n      el => !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER,\n    ),\n    ...filtered.filter(el => el.isStatic && el.kind === FIELD),\n    ...filtered.filter(el => !el.isStatic && el.kind === FIELD),\n  ];\n}\n\nfunction generateDecorationList(\n  decorators: t.Expression[],\n  decoratorsThis: (t.Expression | null)[],\n  version: DecoratorVersionKind,\n) {\n  const decsCount = decorators.length;\n  const hasOneThis = decoratorsThis.some(Boolean);\n  const decs: t.Expression[] = [];\n  for (let i = 0; i < decsCount; i++) {\n    if (version === \"2023-05\" && hasOneThis) {\n      decs.push(\n        decoratorsThis[i] || t.unaryExpression(\"void\", t.numericLiteral(0)),\n      );\n    }\n    decs.push(decorators[i]);\n  }\n\n  return { hasThis: hasOneThis, decs };\n}\n\nfunction generateDecorationExprs(\n  info: (DecoratorInfo | ComputedPropInfo)[],\n  version: DecoratorVersionKind,\n): t.ArrayExpression {\n  return t.arrayExpression(\n    filteredOrderedDecoratorInfo(info).map(el => {\n      const { decs, hasThis } = generateDecorationList(\n        el.decorators,\n        el.decoratorsThis,\n        version,\n      );\n\n      let flag = el.kind;\n      if (el.isStatic) {\n        flag += version === \"2023-05\" ? STATIC : STATIC_OLD_VERSION;\n      }\n      if (hasThis) flag += DECORATORS_HAVE_THIS;\n\n      return t.arrayExpression([\n        decs.length === 1 ? decs[0] : t.arrayExpression(decs),\n        t.numericLiteral(flag),\n        el.name,\n        ...(el.privateMethods || []),\n      ]);\n    }),\n  );\n}\n\nfunction extractElementLocalAssignments(\n  decorationInfo: (DecoratorInfo | ComputedPropInfo)[],\n) {\n  const localIds: t.Identifier[] = [];\n\n  for (const el of filteredOrderedDecoratorInfo(decorationInfo)) {\n    const { locals } = el;\n\n    if (Array.isArray(locals)) {\n      localIds.push(...locals);\n    } else if (locals !== undefined) {\n      localIds.push(locals);\n    }\n  }\n\n  return localIds;\n}\n\nfunction addCallAccessorsFor(\n  element: NodePath,\n  key: t.PrivateName,\n  getId: t.Identifier,\n  setId: t.Identifier,\n) {\n  element.insertAfter(\n    t.classPrivateMethod(\n      \"get\",\n      t.cloneNode(key),\n      [],\n      t.blockStatement([\n        t.returnStatement(\n          t.callExpression(t.cloneNode(getId), [t.thisExpression()]),\n        ),\n      ]),\n    ),\n  );\n\n  element.insertAfter(\n    t.classPrivateMethod(\n      \"set\",\n      t.cloneNode(key),\n      [t.identifier(\"v\")],\n      t.blockStatement([\n        t.expressionStatement(\n          t.callExpression(t.cloneNode(setId), [\n            t.thisExpression(),\n            t.identifier(\"v\"),\n          ]),\n        ),\n      ]),\n    ),\n  );\n}\n\nfunction isNotTsParameter(\n  node: t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty,\n): node is t.Identifier | t.Pattern | t.RestElement {\n  return node.type !== \"TSParameterProperty\";\n}\n\nfunction movePrivateAccessor(\n  element: NodePath<t.ClassPrivateMethod>,\n  key: t.PrivateName,\n  methodLocalVar: t.Identifier,\n  isStatic: boolean,\n) {\n  let params: (t.Identifier | t.RestElement)[];\n  let block: t.Statement[];\n\n  if (element.node.kind === \"set\") {\n    params = [t.identifier(\"v\")];\n    block = [\n      t.expressionStatement(\n        t.callExpression(methodLocalVar, [\n          t.thisExpression(),\n          t.identifier(\"v\"),\n        ]),\n      ),\n    ];\n  } else {\n    params = [];\n    block = [\n      t.returnStatement(t.callExpression(methodLocalVar, [t.thisExpression()])),\n    ];\n  }\n\n  element.replaceWith(\n    t.classPrivateMethod(\n      element.node.kind,\n      t.cloneNode(key),\n      params,\n      t.blockStatement(block),\n      isStatic,\n    ),\n  );\n}\n\nfunction isClassDecoratableElementPath(\n  path: NodePath<ClassElement>,\n): path is NodePath<ClassDecoratableElement> {\n  const { type } = path;\n\n  return (\n    type !== \"TSDeclareMethod\" &&\n    type !== \"TSIndexSignature\" &&\n    type !== \"StaticBlock\"\n  );\n}\n\nfunction staticBlockToIIFE(block: t.StaticBlock) {\n  return t.callExpression(\n    t.arrowFunctionExpression([], t.blockStatement(block.body)),\n    [],\n  );\n}\n\nfunction maybeSequenceExpression(exprs: t.Expression[]) {\n  if (exprs.length === 0) return t.unaryExpression(\"void\", t.numericLiteral(0));\n  if (exprs.length === 1) return exprs[0];\n  return t.sequenceExpression(exprs);\n}\n\nfunction createSetFunctionNameCall(\n  state: PluginPass,\n  className: t.Identifier | t.StringLiteral,\n) {\n  return t.callExpression(state.addHelper(\"setFunctionName\"), [\n    t.thisExpression(),\n    className,\n  ]);\n}\n\nfunction createToPropertyKeyCall(state: PluginPass, propertyKey: t.Expression) {\n  return t.callExpression(state.addHelper(\"toPropertyKey\"), [propertyKey]);\n}\n\nfunction transformClass(\n  path: NodePath<t.ClassExpression | t.ClassDeclaration>,\n  state: PluginPass,\n  constantSuper: boolean,\n  version: DecoratorVersionKind,\n  className: string | t.Identifier | t.StringLiteral | undefined,\n  propertyVisitor: Visitor<PluginPass>,\n): NodePath {\n  const body = path.get(\"body.body\");\n\n  const classDecorators = path.node.decorators;\n  let hasElementDecorators = false;\n\n  const generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path);\n\n  const assignments: t.AssignmentExpression[] = [];\n  const scopeParent: Scope = path.scope.parent;\n  const memoiseExpression = (expression: t.Expression, hint: string) => {\n    const localEvaluatedId = scopeParent.generateDeclaredUidIdentifier(hint);\n    assignments.push(t.assignmentExpression(\"=\", localEvaluatedId, expression));\n    return t.cloneNode(localEvaluatedId);\n  };\n\n  // Iterate over the class to see if we need to decorate it, and also to\n  // transform simple auto accessors which are not decorated\n  for (const element of body) {\n    if (!isClassDecoratableElementPath(element)) {\n      continue;\n    }\n\n    if (element.node.decorators && element.node.decorators.length > 0) {\n      switch (element.node.type) {\n        case \"ClassProperty\":\n          // @ts-expect-error todo: propertyVisitor.ClassProperty should be callable. Improve typings.\n          propertyVisitor.ClassProperty(\n            element as NodePath<t.ClassProperty>,\n            state,\n          );\n          break;\n        case \"ClassPrivateProperty\":\n          // @ts-expect-error todo: propertyVisitor.ClassPrivateProperty should be callable. Improve typings.\n          propertyVisitor.ClassPrivateProperty(\n            element as NodePath<t.ClassPrivateProperty>,\n            state,\n          );\n          break;\n        case \"ClassAccessorProperty\":\n          // @ts-expect-error todo: propertyVisitor.ClassAccessorProperty should be callable. Improve typings.\n          propertyVisitor.ClassAccessorProperty(\n            element as NodePath<t.ClassAccessorProperty>,\n            state,\n          );\n          break;\n      }\n      hasElementDecorators = true;\n    } else if (element.node.type === \"ClassAccessorProperty\") {\n      // @ts-expect-error todo: propertyVisitor.ClassAccessorProperty should be callable. Improve typings.\n      propertyVisitor.ClassAccessorProperty(\n        element as NodePath<t.ClassAccessorProperty>,\n        state,\n      );\n      const { key, value, static: isStatic, computed } = element.node;\n\n      const newId = generateClassPrivateUid();\n      const newField = generateClassProperty(newId, value, isStatic);\n      const keyPath = element.get(\"key\");\n      const [newPath] = element.replaceWith(newField);\n\n      addProxyAccessorsFor(\n        path.node.id,\n        newPath,\n        computed && !keyPath.isConstantExpression()\n          ? memoiseExpression(\n              createToPropertyKeyCall(state, key as t.Expression),\n              \"computedKey\",\n            )\n          : key,\n        newId,\n        version,\n        computed,\n      );\n    }\n  }\n\n  if (!classDecorators && !hasElementDecorators) {\n    // If nothing is decorated but we have assignments, it must be the memoised\n    // computed keys of class accessors\n    if (assignments.length > 0) {\n      path.insertBefore(assignments.map(expr => t.expressionStatement(expr)));\n\n      // Recrawl the scope to make sure new identifiers are properly synced\n      path.scope.crawl();\n    }\n    // If nothing is decorated and no assignments inserted, return\n    return;\n  }\n\n  const elementDecoratorInfo: (DecoratorInfo | ComputedPropInfo)[] = [];\n\n  // The initializer of the first non-static field will be injected with the protoInit call\n  let firstFieldPath:\n    | NodePath<t.ClassProperty | t.ClassPrivateProperty>\n    | undefined;\n  let constructorPath: NodePath<t.ClassMethod> | undefined;\n  let requiresProtoInit = false;\n  let requiresStaticInit = false;\n  const decoratedPrivateMethods = new Set<string>();\n\n  let protoInitLocal: t.Identifier,\n    staticInitLocal: t.Identifier,\n    classInitLocal: t.Identifier,\n    classIdLocal: t.Identifier;\n\n  const decoratorsThis = new Map<t.Decorator, t.Expression>();\n  const maybeExtractDecorator = (decorator: t.Decorator) => {\n    const { expression } = decorator;\n    if (version === \"2023-05\" && t.isMemberExpression(expression)) {\n      let object;\n      if (\n        t.isSuper(expression.object) ||\n        t.isThisExpression(expression.object)\n      ) {\n        object = memoiseExpression(t.thisExpression(), \"obj\");\n      } else if (!scopeParent.isStatic(expression.object)) {\n        object = memoiseExpression(expression.object, \"obj\");\n        expression.object = object;\n      } else {\n        object = expression.object;\n      }\n      decoratorsThis.set(decorator, t.cloneNode(object));\n    }\n    if (!scopeParent.isStatic(expression)) {\n      decorator.expression = memoiseExpression(expression, \"dec\");\n    }\n  };\n\n  let needsDeclaraionForClassBinding = false;\n  if (classDecorators) {\n    classInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initClass\");\n    needsDeclaraionForClassBinding = path.isClassDeclaration();\n    ({ id: classIdLocal, path } = replaceClassWithVar(path, className));\n\n    path.node.decorators = null;\n\n    for (const classDecorator of classDecorators) {\n      maybeExtractDecorator(classDecorator);\n    }\n  } else {\n    if (!path.node.id) {\n      path.node.id = path.scope.generateUidIdentifier(\"Class\");\n    }\n    classIdLocal = t.cloneNode(path.node.id);\n  }\n\n  let lastInstancePrivateName: t.PrivateName;\n  let needsInstancePrivateBrandCheck = false;\n\n  if (hasElementDecorators) {\n    for (const element of body) {\n      if (!isClassDecoratableElementPath(element)) {\n        continue;\n      }\n\n      const { node } = element;\n      const decorators = element.get(\"decorators\");\n\n      const hasDecorators = Array.isArray(decorators) && decorators.length > 0;\n\n      if (hasDecorators) {\n        for (const decoratorPath of decorators) {\n          maybeExtractDecorator(decoratorPath.node);\n        }\n      }\n\n      const isComputed =\n        \"computed\" in element.node && element.node.computed === true;\n      if (isComputed) {\n        if (!element.get(\"key\").isConstantExpression()) {\n          node.key = memoiseExpression(\n            createToPropertyKeyCall(state, node.key as t.Expression),\n            \"computedKey\",\n          );\n        }\n      }\n\n      const kind = getElementKind(element);\n      const { key } = node;\n\n      const isPrivate = key.type === \"PrivateName\";\n\n      const isStatic = !!element.node.static;\n\n      let name = \"computedKey\";\n\n      if (isPrivate) {\n        name = key.id.name;\n      } else if (!isComputed && key.type === \"Identifier\") {\n        name = key.name;\n      }\n\n      if (isPrivate && !isStatic) {\n        if (hasDecorators) {\n          needsInstancePrivateBrandCheck = true;\n        }\n        if (t.isClassPrivateProperty(node) || !lastInstancePrivateName) {\n          lastInstancePrivateName = key;\n        }\n      }\n\n      if (element.isClassMethod({ kind: \"constructor\" })) {\n        constructorPath = element;\n      }\n\n      if (hasDecorators) {\n        let locals: t.Identifier | t.Identifier[];\n        let privateMethods: Array<\n          t.FunctionExpression | t.ArrowFunctionExpression\n        >;\n\n        if (kind === ACCESSOR) {\n          const { value } = element.node as t.ClassAccessorProperty;\n\n          const params: t.Expression[] = [t.thisExpression()];\n\n          if (value) {\n            params.push(t.cloneNode(value));\n          }\n\n          const newId = generateClassPrivateUid();\n          const newFieldInitId =\n            element.scope.parent.generateDeclaredUidIdentifier(`init_${name}`);\n          const newValue = t.callExpression(\n            t.cloneNode(newFieldInitId),\n            params,\n          );\n\n          const newField = generateClassProperty(newId, newValue, isStatic);\n          const [newPath] = element.replaceWith(newField);\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(newId, version);\n\n            const getId = newPath.scope.parent.generateDeclaredUidIdentifier(\n              `get_${name}`,\n            );\n            const setId = newPath.scope.parent.generateDeclaredUidIdentifier(\n              `set_${name}`,\n            );\n\n            addCallAccessorsFor(newPath, key, getId, setId);\n\n            locals = [newFieldInitId, getId, setId];\n          } else {\n            addProxyAccessorsFor(\n              path.node.id,\n              newPath,\n              key,\n              newId,\n              version,\n              isComputed,\n            );\n            locals = newFieldInitId;\n          }\n        } else if (kind === FIELD) {\n          const initId = element.scope.parent.generateDeclaredUidIdentifier(\n            `init_${name}`,\n          );\n          const valuePath = (\n            element as NodePath<t.ClassProperty | t.ClassPrivateProperty>\n          ).get(\"value\");\n\n          valuePath.replaceWith(\n            t.callExpression(\n              t.cloneNode(initId),\n              [t.thisExpression(), valuePath.node].filter(v => v),\n            ),\n          );\n\n          locals = initId;\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(key, version);\n          }\n        } else if (isPrivate) {\n          locals = element.scope.parent.generateDeclaredUidIdentifier(\n            `call_${name}`,\n          );\n\n          const replaceSupers = new ReplaceSupers({\n            constantSuper,\n            methodPath: element as NodePath<t.ClassPrivateMethod>,\n            objectRef: classIdLocal,\n            superRef: path.node.superClass,\n            file: state.file,\n            refToPreserve: classIdLocal,\n          });\n\n          replaceSupers.replace();\n\n          const {\n            params,\n            body,\n            async: isAsync,\n          } = element.node as t.ClassPrivateMethod;\n\n          privateMethods = [\n            t.functionExpression(\n              undefined,\n              params.filter(isNotTsParameter),\n              body,\n              isAsync,\n            ),\n          ];\n\n          if (kind === GETTER || kind === SETTER) {\n            movePrivateAccessor(\n              element as NodePath<t.ClassPrivateMethod>,\n              t.cloneNode(key),\n              t.cloneNode(locals),\n              isStatic,\n            );\n          } else {\n            const node = element.node as t.ClassPrivateMethod;\n\n            // Unshift\n            path.node.body.body.unshift(\n              t.classPrivateProperty(key, t.cloneNode(locals), [], node.static),\n            );\n\n            decoratedPrivateMethods.add(key.id.name);\n\n            element.remove();\n          }\n        }\n\n        let nameExpr: t.Expression;\n\n        if (isComputed) {\n          nameExpr = t.cloneNode(key as t.Expression);\n        } else if (key.type === \"PrivateName\") {\n          nameExpr = t.stringLiteral(key.id.name);\n        } else if (key.type === \"Identifier\") {\n          nameExpr = t.stringLiteral(key.name);\n        } else {\n          nameExpr = t.cloneNode(key as t.Expression);\n        }\n\n        elementDecoratorInfo.push({\n          kind,\n          decorators: decorators.map(d => d.node.expression),\n          decoratorsThis: decorators.map(d => decoratorsThis.get(d.node)),\n          name: nameExpr,\n          isStatic,\n          privateMethods,\n          locals,\n        });\n\n        if (kind !== FIELD) {\n          if (isStatic) {\n            requiresStaticInit = true;\n          } else {\n            requiresProtoInit = true;\n          }\n        }\n\n        if (element.node) {\n          element.node.decorators = null;\n        }\n\n        if (\n          !firstFieldPath &&\n          !isStatic &&\n          (kind === FIELD || kind === ACCESSOR)\n        ) {\n          firstFieldPath = element as NodePath<\n            t.ClassProperty | t.ClassPrivateProperty\n          >;\n        }\n      }\n    }\n  }\n\n  const elementDecorations = generateDecorationExprs(\n    elementDecoratorInfo,\n    version,\n  );\n  let classDecorationsFlag = 0;\n  let classDecorations: t.Expression[] = [];\n  if (classDecorators) {\n    const { hasThis, decs } = generateDecorationList(\n      classDecorators.map(el => el.expression),\n      classDecorators.map(dec => decoratorsThis.get(dec)),\n      version,\n    );\n    classDecorationsFlag = hasThis ? 1 : 0;\n    classDecorations = decs;\n  }\n\n  const elementLocals: t.Identifier[] =\n    extractElementLocalAssignments(elementDecoratorInfo);\n\n  if (requiresProtoInit) {\n    protoInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initProto\");\n    elementLocals.push(protoInitLocal);\n\n    const protoInitCall = t.callExpression(t.cloneNode(protoInitLocal), [\n      t.thisExpression(),\n    ]);\n\n    if (firstFieldPath) {\n      const value = firstFieldPath.get(\"value\");\n      const body: t.Expression[] = [protoInitCall];\n\n      if (value.node) {\n        body.push(value.node);\n      }\n\n      value.replaceWith(t.sequenceExpression(body));\n    } else if (constructorPath) {\n      if (path.node.superClass) {\n        constructorPath.traverse({\n          CallExpression: {\n            exit(path) {\n              if (!path.get(\"callee\").isSuper()) return;\n\n              path.replaceWith(\n                t.callExpression(t.cloneNode(protoInitLocal), [path.node]),\n              );\n\n              path.skip();\n            },\n          },\n          ClassMethod(path) {\n            if (path.node.kind === \"constructor\") {\n              path.skip();\n            }\n          },\n        });\n      } else {\n        constructorPath.node.body.body.unshift(\n          t.expressionStatement(protoInitCall),\n        );\n      }\n    } else {\n      const body: t.Statement[] = [t.expressionStatement(protoInitCall)];\n\n      if (path.node.superClass) {\n        body.unshift(\n          t.expressionStatement(\n            t.callExpression(t.super(), [\n              t.spreadElement(t.identifier(\"args\")),\n            ]),\n          ),\n        );\n      }\n\n      path.node.body.body.unshift(\n        t.classMethod(\n          \"constructor\",\n          t.identifier(\"constructor\"),\n          [t.restElement(t.identifier(\"args\"))],\n          t.blockStatement(body),\n        ),\n      );\n    }\n  }\n\n  if (requiresStaticInit) {\n    staticInitLocal = scopeParent.generateDeclaredUidIdentifier(\"initStatic\");\n    elementLocals.push(staticInitLocal);\n  }\n\n  if (decoratedPrivateMethods.size > 0) {\n    path.traverse({\n      PrivateName(path) {\n        if (!decoratedPrivateMethods.has(path.node.id.name)) return;\n\n        const parentPath = path.parentPath;\n        const parentParentPath = parentPath.parentPath;\n\n        if (\n          // this.bar().#x = 123;\n          (parentParentPath.node.type === \"AssignmentExpression\" &&\n            parentParentPath.node.left === parentPath.node) ||\n          // this.#x++;\n          parentParentPath.node.type === \"UpdateExpression\" ||\n          // ([...this.#x] = foo);\n          parentParentPath.node.type === \"RestElement\" ||\n          // ([this.#x] = foo);\n          parentParentPath.node.type === \"ArrayPattern\" ||\n          // ({ a: this.#x } = bar);\n          (parentParentPath.node.type === \"ObjectProperty\" &&\n            parentParentPath.node.value === parentPath.node &&\n            parentParentPath.parentPath.type === \"ObjectPattern\") ||\n          // for (this.#x of []);\n          (parentParentPath.node.type === \"ForOfStatement\" &&\n            parentParentPath.node.left === parentPath.node)\n        ) {\n          throw path.buildCodeFrameError(\n            `Decorated private methods are not updatable, but \"#${path.node.id.name}\" is updated via this expression.`,\n          );\n        }\n      },\n    });\n  }\n\n  const classLocals: t.Identifier[] = [];\n  let classInitInjected = false;\n  const classInitCall =\n    classInitLocal && t.callExpression(t.cloneNode(classInitLocal), []);\n\n  const originalClass = path.node;\n\n  if (classDecorators) {\n    classLocals.push(classIdLocal, classInitLocal);\n    const statics: (\n      | t.ClassProperty\n      | t.ClassPrivateProperty\n      | t.ClassPrivateMethod\n    )[] = [];\n    let staticBlocks: t.StaticBlock[] = [];\n    path.get(\"body.body\").forEach(element => {\n      // Static blocks cannot be compiled to \"instance blocks\", but we can inline\n      // them as IIFEs in the next property.\n      if (element.isStaticBlock()) {\n        staticBlocks.push(element.node);\n        element.remove();\n        return;\n      }\n\n      const isProperty =\n        element.isClassProperty() || element.isClassPrivateProperty();\n\n      if (\n        (isProperty || element.isClassPrivateMethod()) &&\n        element.node.static\n      ) {\n        if (isProperty && staticBlocks.length > 0) {\n          const allValues: t.Expression[] = staticBlocks.map(staticBlockToIIFE);\n          if (element.node.value) allValues.push(element.node.value);\n          element.node.value = maybeSequenceExpression(allValues);\n          staticBlocks = [];\n        }\n\n        element.node.static = false;\n        statics.push(element.node);\n        element.remove();\n      }\n    });\n\n    if (statics.length > 0 || staticBlocks.length > 0) {\n      const staticsClass = template.expression.ast`\n        class extends ${state.addHelper(\"identity\")} {}\n      ` as t.ClassExpression;\n      staticsClass.body.body = [\n        t.staticBlock([\n          t.toStatement(originalClass, true) ||\n            // If toStatement returns false, originalClass must be an anonymous ClassExpression,\n            // because `export default @dec ...` has been handled in the export visitor before.\n            t.expressionStatement(originalClass as t.ClassExpression),\n        ]),\n        ...statics,\n      ];\n\n      const constructorBody: t.Expression[] = [];\n\n      const newExpr = t.newExpression(staticsClass, []);\n\n      if (staticBlocks.length > 0) {\n        constructorBody.push(...staticBlocks.map(staticBlockToIIFE));\n      }\n      if (classInitCall) {\n        classInitInjected = true;\n        constructorBody.push(classInitCall);\n      }\n      if (constructorBody.length > 0) {\n        constructorBody.unshift(\n          t.callExpression(t.super(), [t.cloneNode(classIdLocal)]),\n        );\n\n        staticsClass.body.body.push(\n          t.classMethod(\n            \"constructor\",\n            t.identifier(\"constructor\"),\n            [],\n            t.blockStatement([\n              t.expressionStatement(t.sequenceExpression(constructorBody)),\n            ]),\n          ),\n        );\n      } else {\n        newExpr.arguments.push(t.cloneNode(classIdLocal));\n      }\n\n      path.replaceWith(newExpr);\n    }\n  }\n  if (!classInitInjected && classInitCall) {\n    path.node.body.body.push(\n      t.staticBlock([t.expressionStatement(classInitCall)]),\n    );\n  }\n\n  let { superClass } = originalClass;\n  if (superClass && (process.env.BABEL_8_BREAKING || version === \"2023-05\")) {\n    const id = path.scope.maybeGenerateMemoised(superClass);\n    if (id) {\n      originalClass.superClass = t.assignmentExpression(\"=\", id, superClass);\n      superClass = id;\n    }\n  }\n\n  originalClass.body.body.unshift(\n    t.staticBlock(\n      [\n        t.expressionStatement(\n          createLocalsAssignment(\n            elementLocals,\n            classLocals,\n            elementDecorations,\n            t.arrayExpression(classDecorations),\n            t.numericLiteral(classDecorationsFlag),\n            needsInstancePrivateBrandCheck ? lastInstancePrivateName : null,\n            typeof className === \"object\" ? className : undefined,\n            t.cloneNode(superClass),\n            state,\n            version,\n          ),\n        ),\n        requiresStaticInit &&\n          t.expressionStatement(\n            t.callExpression(t.cloneNode(staticInitLocal), [\n              t.thisExpression(),\n            ]),\n          ),\n      ].filter(Boolean),\n    ),\n  );\n\n  // When path is a ClassExpression, path.insertBefore will convert `path`\n  // into a SequenceExpression\n  path.insertBefore(assignments.map(expr => t.expressionStatement(expr)));\n\n  if (needsDeclaraionForClassBinding) {\n    path.insertBefore(\n      t.variableDeclaration(\"let\", [\n        t.variableDeclarator(t.cloneNode(classIdLocal)),\n      ]),\n    );\n  }\n\n  // Recrawl the scope to make sure new identifiers are properly synced\n  path.scope.crawl();\n\n  return path;\n}\n\nfunction createLocalsAssignment(\n  elementLocals: t.Identifier[],\n  classLocals: t.Identifier[],\n  elementDecorations: t.ArrayExpression,\n  classDecorations: t.ArrayExpression,\n  classDecorationsFlag: t.NumericLiteral,\n  maybePrivateBranName: t.PrivateName | null,\n  setClassName: t.Identifier | t.StringLiteral | undefined,\n  superClass: null | t.Expression,\n  state: PluginPass,\n  version: DecoratorVersionKind,\n) {\n  let lhs, rhs;\n  const args: t.Expression[] = [\n    setClassName\n      ? createSetFunctionNameCall(state, setClassName)\n      : t.thisExpression(),\n    elementDecorations,\n    classDecorations,\n  ];\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (\n      version === \"2021-12\" ||\n      (version === \"2022-03\" && !state.availableHelper(\"applyDecs2203R\"))\n    ) {\n      const lhs = t.arrayPattern([...elementLocals, ...classLocals]);\n      const rhs = t.callExpression(\n        state.addHelper(version === \"2021-12\" ? \"applyDecs\" : \"applyDecs2203\"),\n        args,\n      );\n      return t.assignmentExpression(\"=\", lhs, rhs);\n    }\n  }\n\n  if (process.env.BABEL_8_BREAKING || version === \"2023-05\") {\n    if (\n      maybePrivateBranName ||\n      superClass ||\n      classDecorationsFlag.value !== 0\n    ) {\n      args.push(classDecorationsFlag);\n    }\n    if (maybePrivateBranName) {\n      args.push(\n        template.expression.ast`\n            _ => ${t.cloneNode(maybePrivateBranName)} in _\n          ` as t.ArrowFunctionExpression,\n      );\n    } else if (superClass) {\n      args.push(t.unaryExpression(\"void\", t.numericLiteral(0)));\n    }\n    if (superClass) args.push(superClass);\n    rhs = t.callExpression(state.addHelper(\"applyDecs2305\"), args);\n  } else if (version === \"2023-01\") {\n    if (maybePrivateBranName) {\n      args.push(\n        template.expression.ast`\n            _ => ${t.cloneNode(maybePrivateBranName)} in _\n          ` as t.ArrowFunctionExpression,\n      );\n    }\n    rhs = t.callExpression(state.addHelper(\"applyDecs2301\"), args);\n  } else {\n    rhs = t.callExpression(state.addHelper(\"applyDecs2203R\"), args);\n  }\n  // optimize `{ c: [classLocals] } = applyapplyDecs2203R(...)` to\n  // `[classLocals] = applyapplyDecs2203R(...).c`\n  if (elementLocals.length > 0) {\n    if (classLocals.length > 0) {\n      lhs = t.objectPattern([\n        t.objectProperty(t.identifier(\"e\"), t.arrayPattern(elementLocals)),\n        t.objectProperty(t.identifier(\"c\"), t.arrayPattern(classLocals)),\n      ]);\n    } else {\n      lhs = t.arrayPattern(elementLocals);\n      rhs = t.memberExpression(rhs, t.identifier(\"e\"), false, false);\n    }\n  } else {\n    // invariant: classLocals.length > 0\n    lhs = t.arrayPattern(classLocals);\n    rhs = t.memberExpression(rhs, t.identifier(\"c\"), false, false);\n  }\n\n  return t.assignmentExpression(\"=\", lhs, rhs);\n}\n\nfunction isProtoKey(\n  node: t.Identifier | t.StringLiteral | t.BigIntLiteral | t.NumericLiteral,\n) {\n  return node.type === \"Identifier\"\n    ? node.name === \"__proto__\"\n    : node.value === \"__proto__\";\n}\n\nfunction isDecorated(node: t.Class | ClassDecoratableElement) {\n  return node.decorators && node.decorators.length > 0;\n}\n\nfunction shouldTransformElement(node: ClassElement) {\n  switch (node.type) {\n    case \"ClassAccessorProperty\":\n      return true;\n    case \"ClassMethod\":\n    case \"ClassProperty\":\n    case \"ClassPrivateMethod\":\n    case \"ClassPrivateProperty\":\n      return isDecorated(node);\n    default:\n      return false;\n  }\n}\n\nfunction shouldTransformClass(node: t.Class) {\n  return isDecorated(node) || node.body.body.some(shouldTransformElement);\n}\n\n// Todo: unify name references logic with helper-function-name\nfunction NamedEvaluationVisitoryFactory(\n  isAnonymous: (path: NodePath) => boolean,\n  visitor: (\n    path: NodePath,\n    state: PluginPass,\n    name:\n      | string\n      | t.Identifier\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral,\n  ) => void,\n) {\n  function handleComputedProperty(\n    propertyPath: NodePath<\n      t.ObjectProperty | t.ClassProperty | t.ClassAccessorProperty\n    >,\n    key: t.Expression,\n    state: PluginPass,\n  ): t.StringLiteral | t.Identifier {\n    switch (key.type) {\n      case \"StringLiteral\":\n        return t.stringLiteral(key.value);\n      case \"NumericLiteral\":\n      case \"BigIntLiteral\": {\n        const keyValue = key.value + \"\";\n        propertyPath.get(\"key\").replaceWith(t.stringLiteral(keyValue));\n        return t.stringLiteral(keyValue);\n      }\n      default: {\n        const ref = propertyPath.scope.maybeGenerateMemoised(key);\n        propertyPath\n          .get(\"key\")\n          .replaceWith(\n            t.assignmentExpression(\n              \"=\",\n              ref,\n              createToPropertyKeyCall(state, key),\n            ),\n          );\n        return t.cloneNode(ref);\n      }\n    }\n  }\n  return {\n    VariableDeclarator(path, state) {\n      const id = path.node.id;\n      if (id.type === \"Identifier\") {\n        const initializer = skipTransparentExprWrappers(path.get(\"init\"));\n        if (isAnonymous(initializer)) {\n          const name = id.name;\n          visitor(initializer, state, name);\n        }\n      }\n    },\n    AssignmentExpression(path, state) {\n      const id = path.node.left;\n      if (id.type === \"Identifier\") {\n        const initializer = skipTransparentExprWrappers(path.get(\"right\"));\n        if (isAnonymous(initializer)) {\n          switch (path.node.operator) {\n            case \"=\":\n            case \"&&=\":\n            case \"||=\":\n            case \"??=\":\n              visitor(initializer, state, id.name);\n          }\n        }\n      }\n    },\n    AssignmentPattern(path, state) {\n      const id = path.node.left;\n      if (id.type === \"Identifier\") {\n        const initializer = skipTransparentExprWrappers(path.get(\"right\"));\n        if (isAnonymous(initializer)) {\n          const name = id.name;\n          visitor(initializer, state, name);\n        }\n      }\n    },\n    // We listen on ObjectExpression so that we don't have to visit\n    // the object properties under object patterns\n    ObjectExpression(path, state) {\n      for (const propertyPath of path.get(\"properties\")) {\n        const { node } = propertyPath;\n        if (node.type !== \"ObjectProperty\") continue;\n        const id = node.key;\n        const initializer = skipTransparentExprWrappers(\n          propertyPath.get(\"value\"),\n        );\n        if (isAnonymous(initializer)) {\n          if (!node.computed) {\n            // 13.2.5.5 RS: PropertyDefinitionEvaluation\n            if (!isProtoKey(id as t.StringLiteral | t.Identifier)) {\n              if (id.type === \"Identifier\") {\n                visitor(initializer, state, id.name);\n              } else {\n                const className = t.stringLiteral(\n                  (id as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)\n                    .value + \"\",\n                );\n                visitor(initializer, state, className);\n              }\n            }\n          } else {\n            const ref = handleComputedProperty(\n              propertyPath as NodePath<t.ObjectProperty>,\n              // The key of a computed object property must not be a private name\n              id as t.Expression,\n              state,\n            );\n            visitor(initializer, state, ref);\n          }\n        }\n      }\n    },\n    ClassPrivateProperty(path, state) {\n      const { node } = path;\n      const initializer = skipTransparentExprWrappers(path.get(\"value\"));\n      if (isAnonymous(initializer)) {\n        const className = t.stringLiteral(\"#\" + node.key.id.name);\n        visitor(initializer, state, className);\n      }\n    },\n    ClassAccessorProperty(path, state) {\n      const { node } = path;\n      const id = node.key;\n      const initializer = skipTransparentExprWrappers(path.get(\"value\"));\n      if (isAnonymous(initializer)) {\n        if (!node.computed) {\n          if (id.type === \"Identifier\") {\n            visitor(initializer, state, id.name);\n          } else if (id.type === \"PrivateName\") {\n            const className = t.stringLiteral(\"#\" + id.id.name);\n            visitor(initializer, state, className);\n          } else {\n            const className = t.stringLiteral(\n              (id as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)\n                .value + \"\",\n            );\n            visitor(initializer, state, className);\n          }\n        } else {\n          const ref = handleComputedProperty(\n            path,\n            // The key of a computed accessor property must not be a private name\n            id as t.Expression,\n            state,\n          );\n          visitor(initializer, state, ref);\n        }\n      }\n    },\n    ClassProperty(path, state) {\n      const { node } = path;\n      const id = node.key;\n      const initializer = skipTransparentExprWrappers(path.get(\"value\"));\n      if (isAnonymous(initializer)) {\n        if (!node.computed) {\n          if (id.type === \"Identifier\") {\n            visitor(initializer, state, id.name);\n          } else {\n            const className = t.stringLiteral(\n              (id as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)\n                .value + \"\",\n            );\n            visitor(initializer, state, className);\n          }\n        } else {\n          const ref = handleComputedProperty(path, id, state);\n          visitor(initializer, state, ref);\n        }\n      }\n    },\n  } satisfies Visitor<PluginPass>;\n}\n\nfunction isDecoratedAnonymousClassExpression(path: NodePath) {\n  return (\n    path.isClassExpression({ id: null }) && shouldTransformClass(path.node)\n  );\n}\n\nexport default function (\n  { assertVersion, assumption }: PluginAPI,\n  { loose }: Options,\n  // TODO(Babel 8): Only keep 2023-05\n  version: \"2023-05\" | \"2023-01\" | \"2022-03\" | \"2021-12\",\n  inherits: PluginObject[\"inherits\"],\n): PluginObject {\n  if (process.env.BABEL_8_BREAKING) {\n    assertVersion(process.env.IS_PUBLISH ? PACKAGE_JSON.version : \"^7.21.0\");\n  } else {\n    if (version === \"2023-05\" || version === \"2023-01\") {\n      assertVersion(\"^7.21.0\");\n    } else if (version === \"2021-12\") {\n      assertVersion(\"^7.16.0\");\n    } else {\n      assertVersion(\"^7.19.0\");\n    }\n  }\n\n  const VISITED = new WeakSet<NodePath>();\n  const constantSuper = assumption(\"constantSuper\") ?? loose;\n\n  const namedEvaluationVisitor: Visitor<PluginPass> =\n    NamedEvaluationVisitoryFactory(\n      isDecoratedAnonymousClassExpression,\n      visitClass,\n    );\n\n  function visitClass(\n    path: NodePath<t.Class>,\n    state: PluginPass,\n    className: string | t.Identifier | t.StringLiteral | undefined,\n  ) {\n    if (VISITED.has(path)) return;\n    const { node } = path;\n    className ??= node.id?.name;\n    const newPath = transformClass(\n      path,\n      state,\n      constantSuper,\n      version,\n      className,\n      namedEvaluationVisitor,\n    );\n    if (newPath) {\n      VISITED.add(newPath);\n      return;\n    }\n    VISITED.add(path);\n  }\n\n  return {\n    name: \"proposal-decorators\",\n    inherits: inherits,\n\n    visitor: {\n      ExportDefaultDeclaration(path, state) {\n        const { declaration } = path.node;\n        if (\n          declaration?.type === \"ClassDeclaration\" &&\n          // When compiling class decorators we need to replace the class\n          // binding, so we must split it in two separate declarations.\n          isDecorated(declaration)\n        ) {\n          const isAnonymous = !declaration.id;\n          const updatedVarDeclarationPath = splitExportDeclaration(\n            path,\n          ) as unknown as NodePath<t.ClassDeclaration>;\n          if (isAnonymous) {\n            visitClass(\n              updatedVarDeclarationPath,\n              state,\n              t.stringLiteral(\"default\"),\n            );\n          }\n        }\n      },\n      ExportNamedDeclaration(path) {\n        const { declaration } = path.node;\n        if (\n          declaration?.type === \"ClassDeclaration\" &&\n          // When compiling class decorators we need to replace the class\n          // binding, so we must split it in two separate declarations.\n          isDecorated(declaration)\n        ) {\n          splitExportDeclaration(path);\n        }\n      },\n\n      Class(path, state) {\n        visitClass(path, state, undefined);\n      },\n\n      ...namedEvaluationVisitor,\n    },\n  };\n}\n"],"mappings":"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"}