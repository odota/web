"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = __importDefault(require("uuid"));
const texts_1 = require("./texts");
const internal_1 = require("./types/internal/");
const upload_1 = require("./upload");
const error_decorator_1 = require("./error-decorator");
const report_commands_factory_1 = __importDefault(require("./report-commands-factory"));
const transport_1 = __importDefault(require("./transport"));
const assign_reporter_methods_1 = __importDefault(require("./assign-reporter-methods"));
const validate_settings_1 = require("./validate-settings");
const create_report_url_1 = __importDefault(require("./create-report-url"));
const blank_reporter_1 = __importDefault(require("./blank-reporter"));
function addArrayValueByKey(collection, key, value) {
    if (!collection[key])
        collection[key] = [value];
    else if (!collection[key].includes(value))
        collection[key].push(value);
}
;
function reporterObjectFactory(readFile, fetch, settings, logger, tcVersion) {
    if (!validate_settings_1.validateSettings(settings, tcVersion, logger))
        return blank_reporter_1.default;
    const { authenticationToken, buildId, dashboardUrl, isLogEnabled, noScreenshotUpload, noVideoUpload, runId, responseTimeout, requestRetryCount, ciInfo } = settings;
    const id = runId || uuid_1.default();
    const transport = new transport_1.default(fetch, dashboardUrl, authenticationToken, isLogEnabled, logger, responseTimeout, requestRetryCount);
    const uploader = new upload_1.Uploader(readFile, transport, logger);
    const reportCommands = report_commands_factory_1.default(id, transport);
    const testRunToWarningsMap = {};
    const runWarnings = [];
    const testRunToActionsMap = {};
    const browserToRunsMap = {};
    const testRunIdToTestIdMap = {};
    const errorsToTestIdMap = {};
    const reporterPluginObject = {
        ...blank_reporter_1.default,
        createErrorDecorator: error_decorator_1.errorDecorator,
        async init() {
            const validationResponse = await transport.fetchFromDashboard('api/validateReporter', {
                method: 'POST',
                body: JSON.stringify({
                    reportId: id,
                    reporterVersion: require('../package.json').version,
                    tcVersion
                })
            });
            if (!validationResponse.ok) {
                const responseText = await validationResponse.text();
                const errorMessage = responseText ? responseText : texts_1.AUTHENTICATION_TOKEN_REJECTED;
                logger.error(errorMessage);
                throw new Error(errorMessage);
            }
        },
        getReportUrl() {
            return create_report_url_1.default(buildId || id, dashboardUrl, authenticationToken);
        }
    };
    async function uploadWarnings() {
        const warningsRunIds = Object.keys(testRunToWarningsMap);
        if (!warningsRunIds.length && !runWarnings.length)
            return void 0;
        const warningsInfo = [];
        for (const testRunId of warningsRunIds)
            warningsInfo.push({ testRunId, warnings: testRunToWarningsMap[testRunId] });
        if (runWarnings.length)
            warningsInfo.push({ warnings: runWarnings });
        return await uploader.uploadRunWarning(id, warningsInfo);
    }
    assign_reporter_methods_1.default(reporterPluginObject, {
        async reportTaskStart(startTime, userAgents, testCount, taskStructure) {
            logger.log(texts_1.createReportUrlMessage(buildId || id, authenticationToken, dashboardUrl));
            await reportCommands.sendTaskStartCommand({
                startTime, userAgents, testCount,
                buildId: buildId,
                taskStructure, ciInfo
            });
        },
        async reportFixtureStart() {
            return;
        },
        async reportWarnings(warning) {
            if (warning.testRunId) {
                if (!testRunToWarningsMap[warning.testRunId])
                    testRunToWarningsMap[warning.testRunId] = [];
                testRunToWarningsMap[warning.testRunId].push(warning);
                const testId = testRunIdToTestIdMap[warning.testRunId];
                if (testId) {
                    await reportCommands.sendReportWarningsCommand({
                        testId: testId,
                    });
                }
            }
            else
                runWarnings.push(warning);
        },
        async reportTestStart(name, meta, testStartInfo) {
            const testId = testStartInfo.testId;
            for (const testRunId of testStartInfo.testRunIds)
                testRunIdToTestIdMap[testRunId] = testId;
            browserToRunsMap[testId] = {};
            await reportCommands.sendTestStartCommand({ testId });
        },
        async reportTestActionDone(apiActionName, actionInfo) {
            const { test: { phase, id: testId }, command, testRunId, err, duration, browser } = actionInfo;
            if (!testRunToActionsMap[testRunId])
                testRunToActionsMap[testRunId] = [];
            const action = {
                duration,
                apiName: apiActionName,
                testPhase: phase,
                command
            };
            if (err) {
                if (err.id)
                    addArrayValueByKey(errorsToTestIdMap, testId, err.id);
                action.error = internal_1.createTestError(err, error_decorator_1.curly(this.useWordWrap(false).setIndent(0).formatError(err)));
            }
            testRunToActionsMap[testRunId].push(action);
            if (!browser)
                return;
            const { alias } = browser;
            const testBrowserRuns = browserToRunsMap[testId];
            if (testBrowserRuns)
                addArrayValueByKey(testBrowserRuns, alias, testRunId);
        },
        async reportTestDone(name, testRunInfo) {
            const { screenshots, videos, errs, durationMs, testId, browsers, skipped, unstable } = testRunInfo;
            const testRunToScreenshotsMap = {};
            const testRunToVideosMap = {};
            const testRunToErrorsMap = {};
            if (!noScreenshotUpload) {
                for (const screenshotInfo of screenshots) {
                    const { screenshotPath, testRunId } = screenshotInfo;
                    const uploadId = await uploader.uploadFile(screenshotPath);
                    if (!uploadId)
                        continue;
                    addArrayValueByKey(testRunToScreenshotsMap, testRunId, uploadId);
                }
            }
            if (!noVideoUpload) {
                for (const videoInfo of videos) {
                    const { videoPath, testRunId } = videoInfo;
                    const uploadId = await uploader.uploadFile(videoPath);
                    if (!uploadId)
                        continue;
                    addArrayValueByKey(testRunToVideosMap, testRunId, uploadId);
                }
            }
            for (const err of errs) {
                if (err.id && errorsToTestIdMap[testId] && errorsToTestIdMap[testId].includes(err.id))
                    continue;
                const { testRunId } = err;
                testRunToErrorsMap[testRunId] = internal_1.createTestError(err, error_decorator_1.curly(this.useWordWrap(false).setIndent(0).formatError(err)));
            }
            delete errorsToTestIdMap[testId];
            const testBrowserRuns = browserToRunsMap[testId];
            const browserRuns = browsers.reduce((runs, browser) => {
                const { alias, testRunId } = browser;
                const runIds = testBrowserRuns && testBrowserRuns[alias] || null;
                let videoUploadIds = [];
                if (!noVideoUpload) {
                    const videoTestRunId = runIds && runIds.find(videoRunId => testRunToVideosMap[videoRunId] && testRunToVideosMap[videoRunId].length) || testRunId;
                    if (videoTestRunId)
                        videoUploadIds = testRunToVideosMap[videoTestRunId];
                }
                const getBrowserRunInfo = (attemptRunId, attempt) => {
                    const result = {
                        browser,
                        screenshotUploadIds: testRunToScreenshotsMap[attemptRunId],
                        videoUploadIds,
                        actions: testRunToActionsMap[attemptRunId],
                        thirdPartyError: testRunToErrorsMap[attemptRunId],
                        quarantineAttempt: attempt,
                        warnings: testRunToWarningsMap[attemptRunId],
                    };
                    delete testRunToActionsMap[attemptRunId];
                    delete testRunToWarningsMap[attemptRunId];
                    return result;
                };
                if (runIds && runIds.length) {
                    let quarantineAttempt = runIds.length > 1 ? 1 : void 0;
                    for (const attemptRunId of runIds) {
                        runs[attemptRunId] = getBrowserRunInfo(attemptRunId, quarantineAttempt);
                        if (quarantineAttempt)
                            quarantineAttempt++;
                    }
                    delete testBrowserRuns[alias];
                }
                else
                    runs[testRunId] = getBrowserRunInfo(testRunId);
                return runs;
            }, {});
            const testDonePayload = {
                testId: testId,
                skipped,
                errorCount: errs.length,
                duration: durationMs,
                unstable,
                uploadId: await uploader.uploadTest(name, internal_1.createDashboardTestRunInfo(testRunInfo, browserRuns))
            };
            if (browserToRunsMap && browserToRunsMap[testId])
                delete browserToRunsMap[testId];
            await reportCommands.sendTestDoneCommand(testDonePayload);
        },
        async reportTaskDone(endTime, passed, warnings, result) {
            const warningsUploadId = await uploadWarnings();
            await uploader.waitUploads();
            await reportCommands.sendTaskDoneCommand({
                endTime, passed, warningsUploadId, warnings, result,
                buildId: buildId
            });
        }
    }, isLogEnabled);
    return reporterPluginObject;
}
exports.default = reporterObjectFactory;
;
