"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Uploader = void 0;
const internal_1 = require("./types/internal");
const texts_1 = require("./texts");
class Uploader {
    constructor(readFile, transport, logger) {
        this._transport = transport;
        this._uploads = [];
        this._logger = logger;
        this._readFile = readFile;
    }
    async _getUploadInfo(uploadEntityId) {
        const response = await this._transport.fetchFromDashboard('api/getUploadUrl');
        if (response.ok)
            return await response.json();
        this._logger.error(texts_1.createGetUploadInfoError(uploadEntityId, response.toString()));
        return null;
    }
    async _upload(uploadInfo, uploadEntity, uploadError) {
        const { uploadUrl, uploadId } = uploadInfo;
        const response = await this._transport.fetch(uploadUrl, {
            method: 'PUT',
            headers: {
                'Content-Length': uploadEntity.length
            },
            body: uploadEntity
        });
        await this._transport.sendResolveCommand({
            aggregateId: uploadId,
            aggregateName: internal_1.AggregateNames.Upload,
            type: internal_1.AggregateCommandType.createUpload,
            payload: {
                status: response.ok ? internal_1.UploadStatus.Completed : internal_1.UploadStatus.Failed
            }
        });
        if (!response.ok)
            this._logger.error(`${uploadError}. Response: ${response}`);
    }
    async uploadFile(filePath) {
        const uploadInfo = await this._getUploadInfo(filePath);
        if (!uploadInfo)
            return void 0;
        const file = await this._readFile(filePath);
        this._uploads.push(this._upload(uploadInfo, file, texts_1.createFileUploadError(uploadInfo.uploadId, filePath)));
        return uploadInfo.uploadId;
    }
    requestUploadEntity(uploadInfo, uploadObject, error) {
        const buffer = Buffer.from(JSON.stringify(uploadObject, (key, value) => value instanceof RegExp ? value.toString() : value));
        this._uploads.push(this._upload(uploadInfo, buffer, error));
    }
    async uploadTest(uploadEntityId, testRunInfo) {
        const uploadInfo = await this._getUploadInfo(uploadEntityId);
        if (!uploadInfo)
            return void 0;
        this.requestUploadEntity(uploadInfo, testRunInfo, texts_1.createTestUploadError(uploadInfo.uploadId, uploadEntityId));
        return uploadInfo.uploadId;
    }
    async uploadRunWarning(uploadEntityId, warningInfo) {
        const uploadInfo = await this._getUploadInfo(uploadEntityId);
        if (!uploadInfo)
            return void 0;
        this.requestUploadEntity(uploadInfo, warningInfo, texts_1.createWarningUploadError(uploadInfo.uploadId, uploadEntityId));
        return uploadInfo.uploadId;
    }
    async waitUploads() {
        await Promise.all(this._uploads);
    }
}
exports.Uploader = Uploader;
