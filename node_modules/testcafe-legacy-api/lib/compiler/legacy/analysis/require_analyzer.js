"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = void 0;
const uglify_js_1 = require("../../tools/uglify-js/uglify-js");
const Common = __importStar(require("../common"));
const Ast = __importStar(require("../ast"));
const CallAnalyzer = __importStar(require("./call_analyzer"));
const steps_analyzer_1 = __importDefault(require("./steps_analyzer"));
function extractMixins(ast, descriptor, errs, sourceIndex) {
    var walker = uglify_js_1.uglify.ast_walker(), mixinAnalyzer = new steps_analyzer_1.default(true, descriptor.rawMixinsStepData, errs, sourceIndex), requireCodeRebuild = false;
    walker.with_walkers({
        'string': function () {
            var astPath = walker.stack(), topStatement = astPath[1][0];
            if (this[1] === Common.MIXIN_DECLARATION_MARKER) {
                topStatement.remove = true;
                requireCodeRebuild = true;
                mixinAnalyzer.run(walker.stack(), descriptor.filename, descriptor.jsCode);
            }
        }
    }, function () {
        walker.walk(ast);
    });
    return requireCodeRebuild;
}
function analyzeRequireCode(requireAst, descriptor, errs, sourceIndex) {
    //OPTIMIZATION: use footprints to determine if we need deeper analysis
    var originalSrc = descriptor.jsCode;
    if (Common.MIXIN_FOOTPRINT_REGEXP.test(descriptor.jsCode)) {
        var rebuildCode = extractMixins(requireAst, descriptor, errs, sourceIndex);
        //NOTE: we need to rebuild js code if mixins were removed from AST
        if (rebuildCode) {
            requireAst = Ast.getRemainderAst(requireAst);
            descriptor.jsCode = requireAst ? uglify_js_1.uglify.gen_code(requireAst, { beautify: true }) : '';
        }
    }
    if (Common.ACTION_OR_ASSERTION_FOOTPRINT_REGEXP.test(descriptor.jsCode)) {
        //NOTE: validate what require file doesn't contain action functions calls and update source index
        if (CallAnalyzer.run(requireAst, descriptor.filename, errs, true, sourceIndex, originalSrc)) {
            //NOTE: if call analyzer found assertions and added them to index, we need to rebuild again
            descriptor.jsCode = requireAst ? uglify_js_1.uglify.gen_code(requireAst, { beautify: true }) : '';
        }
    }
}
function run(requireFilename, ownerFilename, sourceIndex, hammerheadProcessScript, callback) {
    var errs = [], descriptor = {
        hasErrs: false,
        jsCode: null,
        rawMixinsStepData: {},
        filename: requireFilename
    };
    Ast.construct(requireFilename, ownerFilename, function (parsingErr, requireAst, srcCode) {
        if (parsingErr)
            errs.push(parsingErr);
        else if (requireAst) {
            descriptor.jsCode = srcCode;
            analyzeRequireCode(requireAst, descriptor, errs, sourceIndex);
        }
        if (!errs.length)
            descriptor.jsCode = hammerheadProcessScript(descriptor.jsCode, false);
        //NOTE: User can forget ';' at the end of the require js file. In this case, an js exception may occure after
        //requires merging. So we add ';' at the end of the require code manually
        if (descriptor.jsCode && descriptor.jsCode[descriptor.jsCode.length - 1] !== ';')
            descriptor.jsCode += ';';
        descriptor.hasErrs = !!errs.length;
        callback(errs, descriptor);
    });
}
exports.run = run;
;
