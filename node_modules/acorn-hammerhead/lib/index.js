"use strict";

exports.__esModule = true;
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;
exports.version = void 0;

var _state = require("./state.js");

exports.Parser = _state.Parser;

require("./parseutil.js");

require("./statement.js");

require("./lval.js");

require("./expression.js");

require("./location.js");

require("./scope.js");

var _options = require("./options.js");

exports.defaultOptions = _options.defaultOptions;

var _locutil = require("./locutil.js");

exports.Position = _locutil.Position;
exports.SourceLocation = _locutil.SourceLocation;
exports.getLineInfo = _locutil.getLineInfo;

var _node = require("./node.js");

exports.Node = _node.Node;

var _tokentype = require("./tokentype.js");

exports.TokenType = _tokentype.TokenType;
exports.tokTypes = _tokentype.types;
exports.keywordTypes = _tokentype.keywords;

var _tokencontext = require("./tokencontext.js");

exports.TokContext = _tokencontext.TokContext;
exports.tokContexts = _tokencontext.types;

var _identifier = require("./identifier.js");

exports.isIdentifierChar = _identifier.isIdentifierChar;
exports.isIdentifierStart = _identifier.isIdentifierStart;

var _tokenize = require("./tokenize.js");

exports.Token = _tokenize.Token;

var _whitespace = require("./whitespace.js");

exports.isNewLine = _whitespace.isNewLine;
exports.lineBreak = _whitespace.lineBreak;
exports.lineBreakG = _whitespace.lineBreakG;
exports.nonASCIIwhitespace = _whitespace.nonASCIIwhitespace;

var utils = _interopRequireWildcard(require("./util"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/acornjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/acornjs/acorn/issues
//
// [walk]: util/walk.js
const version = "8.7.0";
exports.version = version;
_state.Parser.acorn = {
  Parser: _state.Parser,
  version,
  defaultOptions: _options.defaultOptions,
  Position: _locutil.Position,
  SourceLocation: _locutil.SourceLocation,
  getLineInfo: _locutil.getLineInfo,
  Node: _node.Node,
  TokenType: _tokentype.TokenType,
  tokTypes: _tokentype.types,
  keywordTypes: _tokentype.keywords,
  TokContext: _tokencontext.TokContext,
  tokContexts: _tokencontext.types,
  isIdentifierChar: _identifier.isIdentifierChar,
  isIdentifierStart: _identifier.isIdentifierStart,
  Token: _tokenize.Token,
  isNewLine: _whitespace.isNewLine,
  lineBreak: _whitespace.lineBreak,
  lineBreakG: _whitespace.lineBreakG,
  nonASCIIwhitespace: _whitespace.nonASCIIwhitespace
}; // The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return _state.Parser.parse(input, options);
} // This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.


function parseExpressionAt(input, pos, options) {
  return _state.Parser.parseExpressionAt(input, pos, options);
} // Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.


function tokenizer(input, options) {
  return _state.Parser.tokenizer(input, options);
} // =============================================================================
// =============================================================================
// ===================== TestCafe performance patch ============================
// =====================||||||||||||||||||||||||||||============================
// =====================vvvvvvvvvvvvvvvvvvvvvvvvvvvv============================


const storedWordsRegexp = utils.wordsRegexp;
const wordsRegexpCache = {};

utils.wordsRegexp = function (words) {
  if (!wordsRegexpCache[words]) wordsRegexpCache[words] = storedWordsRegexp(words);
  return wordsRegexpCache[words];
}; // =====================^^^^^^^^^^^^^^^^^^^^^^^^^^^^============================
// =====================||||||||||||||||||||||||||||============================
// ===================== TestCafe performance patch ============================
// =============================================================================
// =============================================================================