"use strict";

exports.__esModule = true;
exports.isNewLine = isNewLine;
exports.lineBreakG = exports.lineBreak = void 0;
exports.nextLineBreak = nextLineBreak;
exports.skipWhiteSpace = exports.nonASCIIwhitespace = void 0;
// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.
const lineBreak = /\r\n?|\n|\u2028|\u2029/;
exports.lineBreak = lineBreak;
const lineBreakG = new RegExp(lineBreak.source, "g");
exports.lineBreakG = lineBreakG;

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;
}

function nextLineBreak(code, from, end = code.length) {
  for (let i = from; i < end; i++) {
    let next = code.charCodeAt(i);
    if (isNewLine(next)) return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
  }

  return -1;
}

const nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
exports.nonASCIIwhitespace = nonASCIIwhitespace;
const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
exports.skipWhiteSpace = skipWhiteSpace;