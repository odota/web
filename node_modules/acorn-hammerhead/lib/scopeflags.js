"use strict";

exports.__esModule = true;
exports.SCOPE_VAR = exports.SCOPE_TOP = exports.SCOPE_SUPER = exports.SCOPE_SIMPLE_CATCH = exports.SCOPE_GENERATOR = exports.SCOPE_FUNCTION = exports.SCOPE_DIRECT_SUPER = exports.SCOPE_CLASS_STATIC_BLOCK = exports.SCOPE_ASYNC = exports.SCOPE_ARROW = exports.BIND_VAR = exports.BIND_SIMPLE_CATCH = exports.BIND_OUTSIDE = exports.BIND_NONE = exports.BIND_LEXICAL = exports.BIND_FUNCTION = void 0;
exports.functionFlags = functionFlags;
// Each scope gets a bitset that may contain these flags
const SCOPE_TOP = 1,
  SCOPE_FUNCTION = 2,
  SCOPE_ASYNC = 4,
  SCOPE_GENERATOR = 8,
  SCOPE_ARROW = 16,
  SCOPE_SIMPLE_CATCH = 32,
  SCOPE_SUPER = 64,
  SCOPE_DIRECT_SUPER = 128,
  SCOPE_CLASS_STATIC_BLOCK = 256,
  SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
exports.SCOPE_VAR = SCOPE_VAR;
exports.SCOPE_CLASS_STATIC_BLOCK = SCOPE_CLASS_STATIC_BLOCK;
exports.SCOPE_DIRECT_SUPER = SCOPE_DIRECT_SUPER;
exports.SCOPE_SUPER = SCOPE_SUPER;
exports.SCOPE_SIMPLE_CATCH = SCOPE_SIMPLE_CATCH;
exports.SCOPE_ARROW = SCOPE_ARROW;
exports.SCOPE_GENERATOR = SCOPE_GENERATOR;
exports.SCOPE_ASYNC = SCOPE_ASYNC;
exports.SCOPE_FUNCTION = SCOPE_FUNCTION;
exports.SCOPE_TOP = SCOPE_TOP;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}

// Used in checkLVal* and declareName to determine the type of a binding
const BIND_NONE = 0,
  // Not a binding
  BIND_VAR = 1,
  // Var-style binding
  BIND_LEXICAL = 2,
  // Let- or const-style binding
  BIND_FUNCTION = 3,
  // Function declaration
  BIND_SIMPLE_CATCH = 4,
  // Simple (identifier pattern) catch binding
  BIND_OUTSIDE = 5; // Special case for function names as bound inside the function
exports.BIND_OUTSIDE = BIND_OUTSIDE;
exports.BIND_SIMPLE_CATCH = BIND_SIMPLE_CATCH;
exports.BIND_FUNCTION = BIND_FUNCTION;
exports.BIND_LEXICAL = BIND_LEXICAL;
exports.BIND_VAR = BIND_VAR;
exports.BIND_NONE = BIND_NONE;