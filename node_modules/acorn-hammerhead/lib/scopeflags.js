"use strict";

exports.__esModule = true;
exports.SCOPE_VAR = exports.SCOPE_TOP = exports.SCOPE_SUPER = exports.SCOPE_SIMPLE_CATCH = exports.SCOPE_GENERATOR = exports.SCOPE_FUNCTION = exports.SCOPE_DIRECT_SUPER = exports.SCOPE_CLASS_STATIC_BLOCK = exports.SCOPE_ASYNC = exports.SCOPE_ARROW = exports.BIND_VAR = exports.BIND_SIMPLE_CATCH = exports.BIND_OUTSIDE = exports.BIND_NONE = exports.BIND_LEXICAL = exports.BIND_FUNCTION = void 0;
exports.functionFlags = functionFlags;
// Each scope gets a bitset that may contain these flags
const SCOPE_TOP = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_ASYNC = 4,
      SCOPE_GENERATOR = 8,
      SCOPE_ARROW = 16,
      SCOPE_SIMPLE_CATCH = 32,
      SCOPE_SUPER = 64,
      SCOPE_DIRECT_SUPER = 128,
      SCOPE_CLASS_STATIC_BLOCK = 256,
      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
exports.SCOPE_VAR = SCOPE_VAR;
exports.SCOPE_CLASS_STATIC_BLOCK = SCOPE_CLASS_STATIC_BLOCK;
exports.SCOPE_DIRECT_SUPER = SCOPE_DIRECT_SUPER;
exports.SCOPE_SUPER = SCOPE_SUPER;
exports.SCOPE_SIMPLE_CATCH = SCOPE_SIMPLE_CATCH;
exports.SCOPE_ARROW = SCOPE_ARROW;
exports.SCOPE_GENERATOR = SCOPE_GENERATOR;
exports.SCOPE_ASYNC = SCOPE_ASYNC;
exports.SCOPE_FUNCTION = SCOPE_FUNCTION;
exports.SCOPE_TOP = SCOPE_TOP;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
} // Used in checkLVal* and declareName to determine the type of a binding


const BIND_NONE = 0,
      // Not a binding
BIND_VAR = 1,
      // Var-style binding
BIND_LEXICAL = 2,
      // Let- or const-style binding
BIND_FUNCTION = 3,
      // Function declaration
BIND_SIMPLE_CATCH = 4,
      // Simple (identifier pattern) catch binding
BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

exports.BIND_OUTSIDE = BIND_OUTSIDE;
exports.BIND_SIMPLE_CATCH = BIND_SIMPLE_CATCH;
exports.BIND_FUNCTION = BIND_FUNCTION;
exports.BIND_LEXICAL = BIND_LEXICAL;
exports.BIND_VAR = BIND_VAR;
exports.BIND_NONE = BIND_NONE;