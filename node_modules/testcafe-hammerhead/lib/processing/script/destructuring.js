"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const esotope_hammerhead_1 = require("esotope-hammerhead");
const node_builder_1 = require("./node-builder");
const temp_variables_1 = __importDefault(require("./transformers/temp-variables"));
const instruction_1 = __importDefault(require("./instruction"));
function processObjectProperty(prop, temp, build, baseTempName) {
    const pattern = prop.value;
    const computed = prop.computed || prop.key.type === esotope_hammerhead_1.Syntax.Literal;
    const value = (0, node_builder_1.createMemberExpression)(temp, prop.key, computed);
    process(pattern, value, build, baseTempName);
}
function createObjectRest(tempIdentifier, keys) {
    const restObjectIdentifier = (0, node_builder_1.createIdentifier)(instruction_1.default.restObject);
    return (0, node_builder_1.createSimpleCallExpression)(restObjectIdentifier, [tempIdentifier, (0, node_builder_1.createArrayExpression)(keys)]);
}
function createRestArray(array, startIndex) {
    const restArrayIdentifier = (0, node_builder_1.createIdentifier)(instruction_1.default.restArray);
    return (0, node_builder_1.createSimpleCallExpression)(restArrayIdentifier, [array, (0, node_builder_1.createSimpleLiteral)(startIndex)]);
}
function createTempIdentifierOrUseExisting(value, build, baseTempName) {
    if (value.type === esotope_hammerhead_1.Syntax.Identifier && temp_variables_1.default.isHHTempVariable(value.name))
        return value;
    const tempIdentifier = (0, node_builder_1.createIdentifier)(baseTempName || temp_variables_1.default.generateName(baseTempName));
    build(tempIdentifier, value, true);
    return tempIdentifier;
}
function processObjectPattern(pattern, value, build, baseTempName) {
    if (!value)
        return;
    const properties = pattern.properties;
    const hasRest = properties.length && properties[properties.length - 1].type === esotope_hammerhead_1.Syntax.RestElement;
    const tempIdentifier = createTempIdentifierOrUseExisting(value, build, baseTempName);
    const propNames = [];
    const baseTempNames = [];
    if (!baseTempName)
        baseTempName = tempIdentifier.name;
    if (hasRest) {
        for (let i = 0; i < properties.length - 1; i++) {
            const prop = properties[i];
            const key = prop.key;
            if (key.type === esotope_hammerhead_1.Syntax.Identifier)
                propNames.push(prop.computed ? key : (0, node_builder_1.createSimpleLiteral)(key.name));
            else if (key.type === esotope_hammerhead_1.Syntax.Literal)
                propNames.push(key);
            else {
                const tempPropKey = (0, node_builder_1.createIdentifier)(temp_variables_1.default.generateName());
                build(tempPropKey, key, true);
                propNames.push(tempPropKey);
                prop.key = tempPropKey;
            }
        }
    }
    for (let i = 0; i < properties.length; i++) {
        const prop = properties[i];
        if (prop.type === esotope_hammerhead_1.Syntax.RestElement)
            build(prop.argument, createObjectRest(tempIdentifier, propNames));
        else {
            const assignmentProp = prop;
            let newBaseTempName = temp_variables_1.default.generateName(baseTempName, assignmentProp.key, i);
            if (baseTempNames.indexOf(newBaseTempName) > -1)
                newBaseTempName = temp_variables_1.default.generateName(newBaseTempName, void 0, i);
            baseTempNames.push(newBaseTempName);
            processObjectProperty(assignmentProp, tempIdentifier, build, newBaseTempName);
        }
    }
}
function processArrayPattern(pattern, value, build, baseTempName) {
    if (!value)
        return;
    // NOTE: support iterable objects (GH-2669)
    if (value.type !== esotope_hammerhead_1.Syntax.ArrayExpression)
        value = (0, node_builder_1.createArrayWrapper)(value);
    const tempIdentifier = createTempIdentifierOrUseExisting(value, build, baseTempName);
    if (!baseTempName)
        baseTempName = tempIdentifier.name;
    for (let i = 0; i < pattern.elements.length; i++) {
        let elem = pattern.elements[i];
        if (!elem)
            continue;
        if (elem.type === esotope_hammerhead_1.Syntax.RestElement) {
            value = createRestArray(tempIdentifier, i);
            elem = elem.argument;
        }
        else
            value = (0, node_builder_1.createMemberExpression)(tempIdentifier, (0, node_builder_1.createSimpleLiteral)(i), true);
        process(elem, value, build, temp_variables_1.default.generateName(baseTempName, void 0, i));
    }
}
function processAssignmentPattern(pattern, value, build, baseTempName) {
    if (!value)
        return;
    const { left, right } = pattern;
    const tempIdentifier = createTempIdentifierOrUseExisting(value, build, baseTempName);
    const tempCondition = (0, node_builder_1.createBinaryExpression)(tempIdentifier, '===', (0, node_builder_1.createUndefined)());
    const tempConditional = (0, node_builder_1.createConditionalExpression)(tempCondition, right, tempIdentifier);
    if (!baseTempName)
        baseTempName = tempIdentifier.name;
    baseTempName += '$assign';
    process(left, tempConditional, build, baseTempName);
}
function process(pattern, value, build, baseTempName) {
    if (pattern.type === esotope_hammerhead_1.Syntax.ObjectPattern)
        processObjectPattern(pattern, value, build, baseTempName);
    else if (pattern.type === esotope_hammerhead_1.Syntax.ArrayPattern)
        processArrayPattern(pattern, value, build, baseTempName);
    else if (pattern.type === esotope_hammerhead_1.Syntax.AssignmentPattern)
        processAssignmentPattern(pattern, value, build, baseTempName);
    else
        build(pattern, value);
}
exports.default = process;module.exports = exports.default;

