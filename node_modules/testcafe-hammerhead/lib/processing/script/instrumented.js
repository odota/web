"use strict";
// -------------------------------------------------------------
// WARNING: this file is used by both the client and the server.
// Do not use any browser or node-specific API!
// -------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldInstrumentProperty = exports.shouldInstrumentMethod = exports.PROPERTIES = exports.METHODS = void 0;
// NOTE: constants are exported for the testing purposes
exports.METHODS = [
    'postMessage',
    'replace',
    'assign',
];
exports.PROPERTIES = [
    'href',
    'location',
];
const INSTRUMENTED_METHOD_RE = new RegExp(`^(${exports.METHODS.join('|')})$`);
const INSTRUMENTED_PROPERTY_RE = new RegExp(`^(${exports.PROPERTIES.join('|')})$`);
// NOTE: Mootools framework contains code that removes the RegExp.prototype.test
// method and restores it later.
//    delete z[A]; // z = RegExp.prototype, A = "test"
//    __set$(z, A, x.protect()); // x.protect - returns the removed method
// The __set$ function calls the test method of the regular expression. (GH-331)
const reTest = RegExp.prototype.test;
// NOTE: The Function.prototype.call method can also be removed.
// But only one of the methods can be removed at a time.
const test = (regexp, str) => regexp.test ? regexp.test(str) : reTest.call(regexp, str);
// NOTE: we can't use the map approach here, because
// cases like `WRAPPABLE_METHOD['toString']` will fail.
// We could use the hasOwnProperty test, but it is
// significantly slower than the regular expression test
function shouldInstrumentMethod(name) {
    return test(INSTRUMENTED_METHOD_RE, String(name));
}
exports.shouldInstrumentMethod = shouldInstrumentMethod;
function shouldInstrumentProperty(name) {
    return test(INSTRUMENTED_PROPERTY_RE, String(name));
}
exports.shouldInstrumentProperty = shouldInstrumentProperty;
