"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const esotope_hammerhead_1 = require("esotope-hammerhead");
const node_builder_1 = require("../node-builder");
const replace_node_1 = __importDefault(require("./replace-node"));
const temp_variables_1 = __importDefault(require("./temp-variables"));
function walkDeclarators(node, action) {
    const declarators = [];
    const identifiers = [];
    for (const statement of node.body) {
        if (statement.type === esotope_hammerhead_1.Syntax.VariableDeclaration)
            declarators.push(...statement.declarations);
    }
    for (const declarator of declarators) {
        if (declarator.type === esotope_hammerhead_1.Syntax.VariableDeclarator) {
            if (declarator.id.type === esotope_hammerhead_1.Syntax.Identifier)
                identifiers.push(declarator.id);
            if (declarator.id.type === esotope_hammerhead_1.Syntax.ArrayPattern)
                identifiers.push(...declarator.id.elements);
            if (declarator.id.type === esotope_hammerhead_1.Syntax.ObjectPattern) {
                for (const prop of declarator.id.properties) {
                    if ('value' in prop)
                        identifiers.push(prop.value);
                }
            }
        }
    }
    for (const identifier of identifiers) {
        if (identifier && identifier.type === esotope_hammerhead_1.Syntax.Identifier)
            action(identifier);
    }
}
function replaceDuplicateDeclarators(forOfNode) {
    var _a;
    const forOfLeft = forOfNode.left;
    const nodesToReplace = [];
    const isArrayPatternDeclaration = ((_a = forOfLeft.declarations[0]) === null || _a === void 0 ? void 0 : _a.id.type) === esotope_hammerhead_1.Syntax.ArrayPattern;
    const isBlockStatement = forOfNode.body.type === esotope_hammerhead_1.Syntax.BlockStatement;
    if (!isArrayPatternDeclaration || !isBlockStatement)
        return;
    const leftDeclaration = forOfLeft.declarations[0].id;
    const leftIdentifiers = leftDeclaration.elements;
    walkDeclarators(forOfNode.body, (node) => {
        for (const identifier of leftIdentifiers) {
            if (identifier && identifier.name === node.name)
                nodesToReplace.push(identifier);
        }
    });
    for (const nodeToReplace of nodesToReplace) {
        const destIdentifier = (0, node_builder_1.createIdentifier)(temp_variables_1.default.generateName());
        (0, replace_node_1.default)(nodeToReplace, destIdentifier, leftDeclaration, 'elements');
    }
}
// Transform:
// for (let {href, postMessage} of wins) {} -->
// for (let _hh$temp0 of wins) { let {href, postMessage} = _hh$temp0; }
const forOfTransformer = {
    name: 'for-of',
    nodeReplacementRequireTransform: false,
    nodeTypes: esotope_hammerhead_1.Syntax.ForOfStatement,
    condition: node => {
        let left = node.left;
        if (left.type === esotope_hammerhead_1.Syntax.VariableDeclaration)
            left = left.declarations[0].id;
        return left.type === esotope_hammerhead_1.Syntax.ObjectPattern || left.type === esotope_hammerhead_1.Syntax.ArrayPattern;
    },
    run: node => {
        const tempIdentifier = (0, node_builder_1.createIdentifier)(temp_variables_1.default.generateName());
        const forOfLeft = node.left;
        let statementWithTempAssignment;
        if (forOfLeft.type === esotope_hammerhead_1.Syntax.VariableDeclaration) {
            replaceDuplicateDeclarators(node);
            statementWithTempAssignment = (0, node_builder_1.createVariableDeclaration)(forOfLeft.kind, [
                (0, node_builder_1.createVariableDeclarator)(forOfLeft.declarations[0].id, tempIdentifier),
            ]);
            statementWithTempAssignment.reTransform = true;
            (0, replace_node_1.default)(forOfLeft.declarations[0].id, tempIdentifier, forOfLeft.declarations[0], 'id');
        }
        else {
            const varDeclaration = (0, node_builder_1.createVariableDeclaration)('var', [(0, node_builder_1.createVariableDeclarator)(tempIdentifier)]);
            statementWithTempAssignment = (0, node_builder_1.createAssignmentExprStmt)(forOfLeft, tempIdentifier);
            (0, replace_node_1.default)(forOfLeft, varDeclaration, node, 'left');
        }
        if (node.body.type === esotope_hammerhead_1.Syntax.BlockStatement)
            (0, replace_node_1.default)(null, statementWithTempAssignment, node.body, 'body');
        else
            (0, replace_node_1.default)(node.body, (0, node_builder_1.createBlockStatement)([statementWithTempAssignment, node.body]), node, 'body');
        return null;
    },
};
exports.default = forOfTransformer;module.exports = exports.default;

