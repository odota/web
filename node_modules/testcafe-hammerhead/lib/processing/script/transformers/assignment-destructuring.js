"use strict";
// -------------------------------------------------------------
// WARNING: this file is used by both the client and the server.
// Do not use any browser or node-specific API!
// -------------------------------------------------------------
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_builder_1 = require("../node-builder");
const esotope_hammerhead_1 = require("esotope-hammerhead");
const destructuring_1 = __importDefault(require("../destructuring"));
// Transform:
// ({ location: loc } = window);
// [{ location }, item] = [window, 6]
// -->
// var _hh$temp0, _hh$temp1, _hh$temp1$0;
//
// (_hh$temp0 = window, loc = _hh$temp0.location, _hh$temp0);
// (_hh$temp1 = [window, 6], _hh$temp1$0 = _hh$temp1[0], location = _hh$temp1$0.location, item = _hh$temp1[1], _hh$temp1);
const transformer = {
    nodeReplacementRequireTransform: true,
    nodeTypes: esotope_hammerhead_1.Syntax.AssignmentExpression,
    condition: node => node.operator === '=' && (node.left.type === esotope_hammerhead_1.Syntax.ObjectPattern || node.left.type === esotope_hammerhead_1.Syntax.ArrayPattern),
    run: (node, _parent, _key, tempVars) => {
        const assignments = [];
        let isFirstTemp = true;
        let firstTemp = null;
        destructuring_1.default(node.left, node.right, (pattern, value, isTemp) => {
            if (isFirstTemp) {
                isFirstTemp = false;
                if (isTemp)
                    firstTemp = pattern;
            }
            assignments.push(node_builder_1.createAssignmentExpression(pattern, '=', value));
            if (isTemp && tempVars)
                tempVars.append(pattern.name);
        });
        if (firstTemp)
            assignments.push(firstTemp);
        return node_builder_1.createSequenceExpression(assignments);
    },
};
exports.default = transformer;module.exports = exports.default;

