"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const transformers_1 = __importDefault(require("./transformers"));
const js_protocol_last_expression_1 = __importDefault(require("./transformers/js-protocol-last-expression"));
const static_import_1 = __importDefault(require("./transformers/static-import"));
const dynamic_import_1 = __importDefault(require("./transformers/dynamic-import"));
const replace_node_1 = __importDefault(require("./transformers/replace-node"));
const esotope_hammerhead_1 = require("esotope-hammerhead");
const url_1 = require("../../utils/url");
const stack_processing_1 = require("../../utils/stack-processing");
const node_builder_1 = require("./node-builder");
const temp_variables_1 = __importDefault(require("./transformers/temp-variables"));
class State {
    constructor() {
        this.hasTransformedAncestor = false;
    }
    // NOTE: There is an issue with processing `new` expressions. `new a.src.b()` will be transformed
    // to `new __get$(a, 'src').b()`, which is wrong. The correct result is `new (__get$(a, 'src')).b()`.
    // To solve this problem, we add a 'state' entity. This entity stores the "new" expression, so that
    // we can add it to the changes when the transformation is found.
    static create(currState, node, parent, key, hasTransformedAncestor = false) {
        const isNewExpression = node.type === esotope_hammerhead_1.Syntax.NewExpression;
        const isNewExpressionAncestor = isNewExpression && !currState.newExpressionAncestor;
        const newState = new State();
        newState.hasTransformedAncestor = currState.hasTransformedAncestor || hasTransformedAncestor;
        newState.newExpressionAncestor = isNewExpressionAncestor ? node : currState.newExpressionAncestor;
        newState.newExpressionAncestorParent = isNewExpressionAncestor ? parent : currState.newExpressionAncestorParent;
        // @ts-ignore
        newState.newExpressionAncestorKey = isNewExpressionAncestor ? key : currState.newExpressionAncestorKey;
        return newState;
    }
}
// NOTE: We should avoid using native object prototype methods,
// since they can be overriden by the client code. (GH-245)
const objectToString = Object.prototype.toString;
const objectKeys = Object.keys;
function getChange(node, parentType) {
    /*eslint-disable @typescript-eslint/no-non-null-assertion*/
    const start = node.originStart;
    const end = node.originEnd;
    /*eslint-disable @typescript-eslint/no-non-null-assertion*/
    return { start, end, node, parentType };
}
function transformChildNodes(node, changes, state, tempVars) {
    // @ts-ignore
    const nodeKeys = objectKeys(node);
    for (const key of nodeKeys) {
        const childNode = node[key];
        const stringifiedNode = objectToString.call(childNode);
        if (stringifiedNode === '[object Array]') {
            // @ts-ignore
            const childNodes = childNode;
            for (const nthNode of childNodes) {
                // NOTE: Some items of ArrayExpression can be null
                if (nthNode)
                    transform(nthNode, changes, state, node, key, tempVars);
            }
        }
        else if (stringifiedNode === '[object Object]') {
            // @ts-ignore
            transform(childNode, changes, state, node, key, tempVars);
        }
    }
}
function isNodeTransformed(node) {
    return node.originStart !== void 0 && node.originEnd !== void 0;
}
function addChangeForTransformedNode(state, changes, replacement, parentType) {
    const hasTransformedAncestor = state.hasTransformedAncestor ||
        state.newExpressionAncestor && isNodeTransformed(state.newExpressionAncestor);
    if (hasTransformedAncestor)
        return;
    if (state.newExpressionAncestor && state.newExpressionAncestorParent) {
        replace_node_1.default(state.newExpressionAncestor, state.newExpressionAncestor, state.newExpressionAncestorParent, state.newExpressionAncestorKey);
        changes.push(getChange(state.newExpressionAncestor, state.newExpressionAncestorParent.type));
    }
    else
        changes.push(getChange(replacement, parentType));
}
function addTempVarsDeclaration(node, changes, state, tempVars) {
    const names = tempVars.get();
    if (!names.length)
        return;
    const declaration = node_builder_1.createTempVarsDeclaration(names);
    replace_node_1.default(null, declaration, node, 'body');
    addChangeForTransformedNode(state, changes, declaration, node.type);
}
function beforeTransform(wrapLastExprWithProcessHtml = false, resolver) {
    js_protocol_last_expression_1.default.wrapLastExpr = wrapLastExprWithProcessHtml;
    static_import_1.default.resolver = resolver;
    const isServerSide = typeof window === 'undefined';
    if (isServerSide) {
        dynamic_import_1.default.getBaseUrl = () => {
            if (typeof dynamic_import_1.default.baseUrl === 'undefined')
                dynamic_import_1.default.baseUrl = resolver ? url_1.parseProxyUrl(resolver('./')).destUrl : '';
            return dynamic_import_1.default.baseUrl;
        };
    }
    else {
        dynamic_import_1.default.getBaseUrl = () => {
            if (typeof dynamic_import_1.default.baseUrl === 'undefined') {
                const currentStack = new Error().stack;
                // NOTE: IE11 doesn't give the error stack without the 'throw' statement and doesn't support the 'import' statement
                dynamic_import_1.default.baseUrl = currentStack && stack_processing_1.getFirstDestUrl(currentStack) || '';
            }
            return dynamic_import_1.default.baseUrl;
        };
    }
}
function afterTransform() {
    js_protocol_last_expression_1.default.wrapLastExpr = false;
    static_import_1.default.resolver = void 0;
    dynamic_import_1.default.baseUrl = void 0;
}
function findTransformer(node, parent) {
    const nodeTransformers = transformers_1.default.get(node.type);
    if (nodeTransformers) {
        for (const transformer of nodeTransformers) {
            if (transformer.condition(node, parent))
                return transformer;
        }
    }
    return null;
}
function transform(node, changes, state, parent, key, tempVars) {
    const allowTempVarAdd = node.type === esotope_hammerhead_1.Syntax.BlockStatement;
    let nodeTransformed = false;
    if (allowTempVarAdd)
        tempVars = new temp_variables_1.default();
    if (!node.reTransform && isNodeTransformed(node)) {
        addChangeForTransformedNode(state, changes, node, parent.type);
        nodeTransformed = true;
    }
    else {
        const storedNode = node;
        let transformer = findTransformer(node, parent);
        let replacement = null;
        while (transformer) {
            replacement = transformer.run(replacement || node, parent, key, tempVars);
            if (!replacement)
                break;
            nodeTransformed = true;
            if (!transformer.nodeReplacementRequireTransform)
                break;
            transformer = findTransformer(replacement, parent);
            node = replacement;
        }
        if (nodeTransformed && replacement) {
            replace_node_1.default(storedNode, replacement, parent, key);
            addChangeForTransformedNode(state, changes, replacement, parent.type);
        }
    }
    state = State.create(state, node, parent, key, nodeTransformed);
    transformChildNodes(node, changes, state, tempVars);
    if (allowTempVarAdd)
        addTempVarsDeclaration(node, changes, state, tempVars);
}
function transformProgram(node, wrapLastExprWithProcessHtml = false, resolver) {
    const changes = [];
    const state = new State();
    const tempVars = new temp_variables_1.default();
    temp_variables_1.default.resetCounter();
    beforeTransform(wrapLastExprWithProcessHtml, resolver);
    transformChildNodes(node, changes, state, tempVars);
    addTempVarsDeclaration(node, changes, state, tempVars);
    afterTransform();
    return changes;
}
exports.default = transformProgram;module.exports = exports.default;

