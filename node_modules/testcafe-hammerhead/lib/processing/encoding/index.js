"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeContent = exports.decodeContent = void 0;
const zlib_1 = __importDefault(require("zlib"));
const promisified_functions_1 = require("../../utils/promisified-functions");
const iconv_lite_1 = __importDefault(require("iconv-lite"));
// NOTE: https://github.com/request/request/pull/2492/files
// Be more lenient with decoding compressed responses, since (very rarely)
// servers send slightly invalid gzip responses that are still accepted
// by common browsers.
// Always using Z_SYNC_FLUSH is what cURL does.
// GH-1915
const GZIP_DECODING_OPTIONS = {
    flush: zlib_1.default.Z_SYNC_FLUSH,
    finishFlush: zlib_1.default.Z_SYNC_FLUSH,
};
// NOTE: https://github.com/DevExpress/testcafe-hammerhead/issues/2743
// The default compression level (11) causes the strong performance degradation.
// This is why, we decrease the compression level same as other frameworks
// (https://github.com/dotnet/runtime/issues/26097, https://github.com/koajs/compress/issues/121)
const BROTLI_DECODING_OPTIONS = {
    params: {
        [zlib_1.default.constants.BROTLI_PARAM_QUALITY]: 5,
    },
};
// NOTE: IIS has a bug when it sends 'raw deflate' compressed data for the 'Deflate' Accept-Encoding header.
// (see: http://zoompf.com/2012/02/lose-the-wait-http-compression)
async function inflateWithFallback(data) {
    try {
        return await (0, promisified_functions_1.inflate)(data);
    }
    catch (err) {
        if (err.code === 'Z_DATA_ERROR')
            return await (0, promisified_functions_1.inflateRaw)(data);
        throw err;
    }
}
async function decodeContent(content, encoding, charset) {
    if (encoding === "gzip" /* CONTENT_ENCODING.GZIP */)
        content = await (0, promisified_functions_1.gunzip)(content, GZIP_DECODING_OPTIONS);
    else if (encoding === "deflate" /* CONTENT_ENCODING.DEFLATE */)
        content = await inflateWithFallback(content);
    else if (encoding === "br" /* CONTENT_ENCODING.BROTLI */)
        content = await (0, promisified_functions_1.brotliDecompress)(content, BROTLI_DECODING_OPTIONS);
    charset.fromBOM(content);
    return iconv_lite_1.default.decode(content, charset.get());
}
exports.decodeContent = decodeContent;
async function encodeContent(content, encoding, charset) {
    const encodedContent = iconv_lite_1.default.encode(content, charset.get(), { addBOM: charset.isFromBOM() });
    if (encoding === "gzip" /* CONTENT_ENCODING.GZIP */)
        return (0, promisified_functions_1.gzip)(encodedContent);
    if (encoding === "deflate" /* CONTENT_ENCODING.DEFLATE */)
        return (0, promisified_functions_1.deflate)(encodedContent);
    if (encoding === "br" /* CONTENT_ENCODING.BROTLI */)
        return (0, promisified_functions_1.brotliCompress)(encodedContent, BROTLI_DECODING_OPTIONS);
    return encodedContent;
}
exports.encodeContent = encodeContent;
