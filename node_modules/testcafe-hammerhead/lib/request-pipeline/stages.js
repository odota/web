"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("../utils/logger"));
const http_1 = require("../utils/http");
const request_options_1 = __importDefault(require("./request-options"));
const info_1 = require("../session/events/info");
const utils_1 = require("./utils");
const configure_response_event_1 = __importDefault(require("../session/events/configure-response-event"));
const configure_response_event_options_1 = __importDefault(require("../session/events/configure-response-event-options"));
const names_1 = __importDefault(require("../session/events/names"));
const websocket_1 = require("./websocket");
const lodash_1 = require("lodash");
const resources_1 = require("../processing/resources");
const connection_reset_guard_1 = require("./connection-reset-guard");
const EVENT_SOURCE_REQUEST_TIMEOUT = 60 * 60 * 1000;
exports.default = [
    function handleSocketError(ctx) {
        // NOTE: In some case on MacOS, browser reset connection with server and we need to catch this exception.
        if (!ctx.isWebSocket)
            return;
        ctx.res.on('error', e => {
            logger_1.default.proxy.onWebSocketResponseError(ctx, e);
            // @ts-ignore
            if (e.code === 'ECONNRESET' && !ctx.mock) {
                if (ctx.destRes)
                    ctx.destRes.destroy();
                else
                    ctx.isWebSocketConnectionReset = true;
            }
            else
                throw e;
        });
    },
    async function fetchProxyRequestBody(ctx) {
        if (ctx.isHTMLPage)
            ctx.session.onPageRequest(ctx);
        ctx.reqBody = await http_1.fetchBody(ctx.req);
    },
    async function sendDestinationRequest(ctx) {
        ctx.reqOpts = new request_options_1.default(ctx);
        if (ctx.isSpecialPage) {
            ctx.respondForSpecialPage();
            return;
        }
        if (ctx.session.hasRequestEventListeners()) {
            const requestInfo = new info_1.RequestInfo(ctx);
            ctx.requestFilterRules = await ctx.session.getRequestFilterRules(requestInfo);
            await ctx.forEachRequestFilterRule(async (rule) => {
                const requestEvent = await utils_1.callOnRequestEventCallback(ctx, rule, requestInfo);
                ctx.setupMockIfNecessary(requestEvent);
            });
        }
        if (ctx.mock)
            await ctx.mockResponse();
        else
            await utils_1.sendRequest(ctx);
    },
    async function checkSameOriginPolicyCompliance(ctx) {
        if (ctx.isPassSameOriginPolicy())
            return;
        ctx.isSameOriginPolicyFailed = true;
        await ctx.forEachRequestFilterRule(async (rule) => {
            const configureResponseEvent = new configure_response_event_1.default(rule, ctx, configure_response_event_options_1.default.DEFAULT);
            await ctx.session.callRequestEventCallback(names_1.default.onConfigureResponse, rule, configureResponseEvent);
            await utils_1.callOnResponseEventCallbackForFailedSameOriginCheck(ctx, rule, configure_response_event_options_1.default.DEFAULT);
        });
        logger_1.default.proxy.onCORSFailed(ctx);
    },
    async function decideOnProcessingStrategy(ctx) {
        ctx.goToNextStage = false;
        if (ctx.isWebSocket)
            websocket_1.respondOnWebSocket(ctx);
        else if (ctx.contentInfo.requireProcessing) {
            if (ctx.destRes.statusCode === 204)
                ctx.destRes.statusCode = 200;
            ctx.goToNextStage = true;
        }
        else if (ctx.isSpecialPage) {
            ctx.sendResponseHeaders();
            ctx.res.end();
        }
        // NOTE: Just pipe the content body to the browser if we don't need to process it.
        else {
            await utils_1.callOnConfigureResponseEventForNonProcessedRequest(ctx);
            ctx.sendResponseHeaders();
            if (ctx.contentInfo.isNotModified)
                return await utils_1.callOnResponseEventCallbackForMotModifiedResource(ctx);
            const onResponseEventDataWithBody = ctx.getOnResponseEventData({ includeBody: true });
            const onResponseEventDataWithoutBody = ctx.getOnResponseEventData({ includeBody: false });
            if (onResponseEventDataWithBody.length)
                await utils_1.callOnResponseEventCallbackWithBodyForNonProcessedRequest(ctx, onResponseEventDataWithBody);
            else if (onResponseEventDataWithoutBody.length)
                await utils_1.callOnResponseEventCallbackWithoutBodyForNonProcessedResource(ctx, onResponseEventDataWithoutBody);
            else if (ctx.req.socket.destroyed && !ctx.isDestResReadableEnded)
                ctx.destRes.destroy();
            else {
                ctx.res.once('close', () => !ctx.isDestResReadableEnded && ctx.destRes.destroy());
                await ctx.pipeNonProcessedResponse();
            }
            // NOTE: sets 60 minutes timeout for the "event source" requests instead of 2 minutes by default
            if (ctx.dest.isEventSource) {
                ctx.req.setTimeout(EVENT_SOURCE_REQUEST_TIMEOUT, lodash_1.noop);
                ctx.req.on('close', () => ctx.destRes.destroy());
            }
        }
    },
    async function fetchContent(ctx) {
        await ctx.fetchDestResBody();
        if (ctx.requestFilterRules.length)
            ctx.saveNonProcessedDestResBody(ctx.destResBody);
    },
    async function processContent(ctx) {
        try {
            ctx.destResBody = await resources_1.process(ctx);
        }
        catch (err) {
            utils_1.error(ctx, err);
        }
    },
    async function sendProxyResponse(ctx) {
        const configureResponseEvents = await Promise.all(ctx.requestFilterRules.map(async (rule) => {
            const configureResponseEvent = new configure_response_event_1.default(rule, ctx, configure_response_event_options_1.default.DEFAULT);
            await ctx.session.callRequestEventCallback(names_1.default.onConfigureResponse, rule, configureResponseEvent);
            return configureResponseEvent;
        }));
        ctx.sendResponseHeaders();
        connection_reset_guard_1.connectionResetGuard(async () => {
            await Promise.all(configureResponseEvents.map(async (configureResponseEvent) => {
                await utils_1.callResponseEventCallbackForProcessedRequest(ctx, configureResponseEvent);
            }));
            ctx.res.write(ctx.destResBody);
            ctx.res.end();
        });
    },
];module.exports = exports.default;

