"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resetKeepAliveConnections = exports.regressHttps = exports.shouldRegressHttps = exports.assign = void 0;
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const lru_cache_1 = require("lru-cache");
const tunnel_agent_1 = __importDefault(require("tunnel-agent"));
const SSL3_HOST_CACHE_SIZE = 1000;
/* eslint-disable no-unused-vars */
var TYPE;
(function (TYPE) {
    TYPE["SSL3"] = "SSL3";
    TYPE["TLS"] = "TLS";
    TYPE["HTTP"] = "HTTP";
})(TYPE || (TYPE = {}));
/* eslint-enable no-unused-vars */
const ssl3HostCache = new lru_cache_1.LRUCache({ max: SSL3_HOST_CACHE_SIZE });
const agents = {
    [TYPE.SSL3]: {
        instance: null,
        Ctor: https_1.default.Agent,
        secureProtocol: 'SSLv3_method',
    },
    [TYPE.TLS]: {
        instance: null,
        Ctor: https_1.default.Agent,
    },
    [TYPE.HTTP]: {
        instance: null,
        Ctor: http_1.default.Agent,
    },
};
// Utils
function getAgent(type) {
    const agent = agents[type];
    if (!agent.instance) {
        // @ts-ignore: Cannot use 'new' with an expression whose type lacks a call or construct signature.
        agent.instance = new agent.Ctor({
            keepAlive: true,
            secureProtocol: agent.secureProtocol,
        });
    }
    return agent.instance;
}
function isSSLProtocolErr(err) {
    return !!err.message && err.message.includes('SSL routines');
}
// API
function assign(reqOpts) {
    const proxy = reqOpts.proxy;
    if (proxy && reqOpts.protocol === 'https:') {
        reqOpts.agent = tunnel_agent_1.default.httpsOverHttp({
            proxy,
            rejectUnauthorized: false,
        });
        return;
    }
    let type = '';
    if (reqOpts.protocol === 'http:')
        type = TYPE.HTTP;
    else if (ssl3HostCache.get(reqOpts.host))
        type = TYPE.SSL3;
    else
        type = TYPE.TLS;
    reqOpts.agent = getAgent(type);
}
exports.assign = assign;
function shouldRegressHttps(reqErr, reqOpts) {
    return reqOpts.agent === agents[TYPE.TLS] && isSSLProtocolErr(reqErr);
}
exports.shouldRegressHttps = shouldRegressHttps;
function regressHttps(reqOpts) {
    ssl3HostCache.set(reqOpts.host, true);
    reqOpts.agent = getAgent(TYPE.SSL3);
}
exports.regressHttps = regressHttps;
// NOTE: Since our agents are keep-alive, we need to manually reset connections when we
// switch between servers in tests.
function resetKeepAliveConnections() {
    Object.keys(agents).forEach(type => {
        const agent = agents[type];
        if (agent.instance)
            agent.instance.destroy();
        agent.instance = null;
    });
}
exports.resetKeepAliveConnections = resetKeepAliveConnections;
