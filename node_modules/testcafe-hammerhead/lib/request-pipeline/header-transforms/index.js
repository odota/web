"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupPreventCachingHeaders = exports.transformHeadersCaseToRaw = exports.forResponse = exports.forRequest = void 0;
const builtin_header_names_1 = __importDefault(require("../builtin-header-names"));
const http_1 = require("../../utils/http");
const transforms_1 = require("./transforms");
const FORCED_REQ_HEADERS_BROWSER_CASES = [
    {
        lowerCase: builtin_header_names_1.default.cookie,
        browserCase: 'Cookie',
    },
    {
        lowerCase: builtin_header_names_1.default.origin,
        browserCase: 'Origin',
    },
];
function transformHeaders(srcHeaders, ctx, transformList, forcedTransforms) {
    const destHeaders = {};
    const applyTransform = function (headerName, headers, transforms) {
        const src = headers[headerName];
        const transform = transforms[headerName];
        const dest = transform ? transform(src, ctx) : src;
        if (dest !== void 0)
            destHeaders[headerName] = dest;
    };
    Object.keys(srcHeaders).forEach(headerName => applyTransform(headerName, srcHeaders, transformList));
    if (forcedTransforms)
        Object.keys(forcedTransforms).forEach(headerName => applyTransform(headerName, destHeaders, forcedTransforms));
    return destHeaders;
}
// API
function forRequest(ctx) {
    return transformHeaders(ctx.req.headers, ctx, transforms_1.requestTransforms, transforms_1.forcedRequestTransforms);
}
exports.forRequest = forRequest;
function forResponse(ctx) {
    return transformHeaders(ctx.destRes.headers, ctx, transforms_1.responseTransforms, transforms_1.forcedResponseTransforms);
}
exports.forResponse = forResponse;
// NOTE: We doesn't send a cross-domain client request as cross-domain.
// Therefore, the "origin" header can be absent and we cannot decide its case. GH-2382
// The similar situation also occurs with the forced "cookie" header.
function calculateForcedHeadersCase(headers, processedHeaders, headersNames) {
    const isBrowserRefererStartsWithUpperChar = processedHeaders.hasOwnProperty('Referer'); // eslint-disable-line no-prototype-builtins
    for (const { lowerCase, browserCase } of FORCED_REQ_HEADERS_BROWSER_CASES) {
        if (isBrowserRefererStartsWithUpperChar && headers.hasOwnProperty(lowerCase)) { // eslint-disable-line no-prototype-builtins
            processedHeaders[browserCase] = headers[lowerCase];
            headersNames[headersNames.indexOf(lowerCase)] = void 0;
        }
    }
}
function transformOriginHeaders(headers, processedHeaders, headersNames, rawHeaders) {
    for (let i = 0; i < rawHeaders.length; i += 2) {
        const rawHeaderName = rawHeaders[i];
        const lowerCasedRawHeaderName = rawHeaderName.toLowerCase();
        const headerIndex = headersNames.indexOf(lowerCasedRawHeaderName);
        if (headerIndex > -1) {
            processedHeaders[rawHeaderName] = headers[lowerCasedRawHeaderName];
            headersNames[headerIndex] = void 0;
        }
    }
}
function addServiceHeaders(headers, processedHeaders, headersNames) {
    for (const headerName of headersNames) {
        if (headerName !== void 0)
            processedHeaders[headerName] = headers[headerName];
    }
}
function transformHeadersCaseToRaw(headers, rawHeaders) {
    const processedHeaders = {};
    const headersNames = Object.keys(headers);
    transformOriginHeaders(headers, processedHeaders, headersNames, rawHeaders);
    calculateForcedHeadersCase(headers, processedHeaders, headersNames);
    addServiceHeaders(headers, processedHeaders, headersNames);
    return processedHeaders;
}
exports.transformHeadersCaseToRaw = transformHeadersCaseToRaw;
function setupPreventCachingHeaders(headers) {
    headers[builtin_header_names_1.default.cacheControl] = http_1.PREVENT_CACHING_HEADERS[builtin_header_names_1.default.cacheControl];
    headers[builtin_header_names_1.default.pragma] = http_1.PREVENT_CACHING_HEADERS[builtin_header_names_1.default.pragma];
    delete headers[builtin_header_names_1.default.eTag];
    delete headers[builtin_header_names_1.default.expires];
}
exports.setupPreventCachingHeaders = setupPreventCachingHeaders;
