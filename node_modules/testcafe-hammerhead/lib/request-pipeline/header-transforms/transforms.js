"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.forcedResponseTransforms = exports.responseTransforms = exports.forcedRequestTransforms = exports.requestTransforms = void 0;
const builtin_header_names_1 = __importDefault(require("../builtin-header-names"));
const urlUtils = __importStar(require("../../utils/url"));
const url_1 = require("url");
const same_origin_policy_1 = require("../same-origin-policy");
const cookie_1 = require("../../utils/cookie");
const headers_1 = require("../../utils/headers");
function skip() {
    return void 0;
}
function skipIfStateSnapshotIsApplied(src, ctx) {
    return ctx.restoringStorages ? void 0 : src;
}
function transformAuthorizationHeader(src) {
    return headers_1.hasAuthorizationPrefix(src) ? headers_1.removeAuthorizationPrefix(src) : void 0;
}
function generateSyncCookie(ctx, parsedServerCookies) {
    parsedServerCookies = parsedServerCookies.filter(cookie => !cookie.httpOnly);
    let syncWithClientCookies = parsedServerCookies
        .map(cookie => {
        cookie.isServerSync = true;
        cookie.sid = ctx.session.id;
        return cookie_1.formatSyncCookie(cookie);
    });
    if (ctx.parsedClientSyncCookie) {
        const outdatedSyncCookies = ctx.parsedClientSyncCookie.actual.filter(clientCookie => {
            if (clientCookie.isClientSync && !clientCookie.isWindowSync)
                return true;
            for (const serverCookie of parsedServerCookies) {
                if (cookie_1.isOutdatedSyncCookie(clientCookie, serverCookie))
                    return true;
            }
            return false;
        });
        syncWithClientCookies = ctx.parsedClientSyncCookie.outdated
            .concat(outdatedSyncCookies)
            .map(cookie_1.generateDeleteSyncCookieStr)
            .concat(syncWithClientCookies);
    }
    return syncWithClientCookies;
}
function resolveAndGetProxyUrl(url, ctx) {
    url = urlUtils.prepareUrl(url);
    const { host } = url_1.parse(url);
    let isCrossDomain = false;
    if (!host)
        url = url_1.resolve(ctx.dest.url, url);
    if (ctx.isIframe && ctx.dest.referer) {
        const isCrossDomainLocationBeforeRedirect = !urlUtils.sameOriginCheck(ctx.dest.referer, ctx.dest.url);
        const isCrossDomainLocationAfterRedirect = !urlUtils.sameOriginCheck(ctx.dest.referer, url);
        isCrossDomain = isCrossDomainLocationBeforeRedirect !== isCrossDomainLocationAfterRedirect;
    }
    else if (ctx.isAjax) {
        return ctx.toProxyUrl(url, isCrossDomain, ctx.contentInfo.contentTypeUrlToken, void 0, ctx.dest.reqOrigin, ctx.dest.credentials);
    }
    return ctx.toProxyUrl(url, isCrossDomain, ctx.contentInfo.contentTypeUrlToken);
}
function transformRefreshHeader(src, ctx) {
    return urlUtils.processMetaRefreshContent(src, url => resolveAndGetProxyUrl(url, ctx));
}
function processSetCookieHeader(src, ctx) {
    const parsedCookies = src && !same_origin_policy_1.shouldOmitCredentials(ctx) ? ctx.session.cookies.setByServer(ctx.dest.url, src) : [];
    return generateSyncCookie(ctx, parsedCookies);
}
function transformContentDispositionHeader(src, ctx) {
    return ctx.contentInfo.isAttachment && !(src && src.includes('attachment')) ? 'attachment;' + src || '' : src;
}
// Request headers
exports.requestTransforms = {
    [builtin_header_names_1.default.host]: (_src, ctx) => ctx.dest.host,
    [builtin_header_names_1.default.referer]: (_src, ctx) => {
        const referer = ctx.dest.referer;
        return referer && !urlUtils.isSpecialPage(referer) ? referer : void 0;
    },
    [builtin_header_names_1.default.origin]: (_src, ctx) => ctx.dest.reqOrigin || ctx.dest.domain,
    [builtin_header_names_1.default.contentLength]: (_src, ctx) => ctx.reqBody.length,
    [builtin_header_names_1.default.cookie]: skip,
    [builtin_header_names_1.default.ifModifiedSince]: skipIfStateSnapshotIsApplied,
    [builtin_header_names_1.default.ifNoneMatch]: skipIfStateSnapshotIsApplied,
    [builtin_header_names_1.default.authorization]: transformAuthorizationHeader,
    [builtin_header_names_1.default.proxyAuthorization]: transformAuthorizationHeader,
};
exports.forcedRequestTransforms = {
    [builtin_header_names_1.default.cookie]: (_src, ctx) => same_origin_policy_1.shouldOmitCredentials(ctx) ? void 0 : ctx.session.cookies.getHeader(ctx.dest) || void 0,
};
// Response headers
exports.responseTransforms = {
    // NOTE: Disable Content Security Policy (see http://en.wikipedia.org/wiki/Content_Security_Policy).
    [builtin_header_names_1.default.contentSecurityPolicy]: skip,
    [builtin_header_names_1.default.contentSecurityPolicyReportOnly]: skip,
    [builtin_header_names_1.default.xContentSecurityPolicy]: skip,
    [builtin_header_names_1.default.xContentSecurityPolicyReportOnly]: skip,
    [builtin_header_names_1.default.xWebkitCsp]: skip,
    // NOTE: Even if we are not able to be authorized, we should prevent showing the native credentials window.
    [builtin_header_names_1.default.wwwAuthenticate]: headers_1.addAuthenticatePrefix,
    [builtin_header_names_1.default.proxyAuthenticate]: headers_1.addAuthenticatePrefix,
    [builtin_header_names_1.default.accessControlAllowOrigin]: (_src, ctx) => ctx.isSameOriginPolicyFailed ? void 0 : ctx.getProxyOrigin(!!ctx.dest.reqOrigin),
    // NOTE: Change the transform type if we have an iframe with an image as src,
    // because it was transformed to HTML with the image tag.
    [builtin_header_names_1.default.contentType]: (src, ctx) => ctx.contentInfo.isIframeWithImageSrc || ctx.contentInfo.isTextPage ? 'text/html' : src,
    [builtin_header_names_1.default.contentLength]: (src, ctx) => ctx.contentInfo.requireProcessing ? ctx.destResBody.length.toString() : src,
    // NOTE: We should skip an invalid trailer header (GH-2692).
    [builtin_header_names_1.default.trailer]: (src, ctx) => ctx.destRes.headers[builtin_header_names_1.default.transferEncoding] === 'chunked' ? src : void 0,
    [builtin_header_names_1.default.location]: (src, ctx) => {
        // NOTE: The RFC 1945 standard requires location URLs to be absolute. However, most popular browsers
        // accept relative URLs. We transform relative URLs to absolute to correctly handle this situation.
        if (ctx.contentInfo.isRedirect)
            return resolveAndGetProxyUrl(src, ctx);
        return src;
    },
    [builtin_header_names_1.default.xFrameOptions]: (src, ctx) => {
        const cspHeader = ctx.destRes.headers[builtin_header_names_1.default.contentSecurityPolicy];
        if (cspHeader && cspHeader.includes('frame-ancestors '))
            return void 0;
        if (!src.includes('ALLOW-FROM'))
            return src;
        src = src.replace('ALLOW-FROM', '').trim();
        const isCrossDomain = ctx.isIframe && !urlUtils.sameOriginCheck(ctx.dest.url, src);
        const proxiedUrl = ctx.toProxyUrl(src, isCrossDomain, ctx.contentInfo.contentTypeUrlToken);
        return 'ALLOW-FROM ' + proxiedUrl;
    },
    [builtin_header_names_1.default.sourceMap]: skip,
    [builtin_header_names_1.default.referrerPolicy]: () => 'unsafe-url',
    [builtin_header_names_1.default.refresh]: (src, ctx) => transformRefreshHeader(src, ctx),
    [builtin_header_names_1.default.link]: (src) => {
        if (/[;\s]rel=\s*prefetch/i.test(src))
            return void 0;
        return src;
    },
};
exports.forcedResponseTransforms = {
    [builtin_header_names_1.default.setCookie]: processSetCookieHeader,
    [builtin_header_names_1.default.serviceWorkerAllowed]: (_src, ctx) => ctx.dest.isServiceWorker ? '/' : void 0,
    [builtin_header_names_1.default.contentDisposition]: (_src, ctx) => transformContentDispositionHeader(_src, ctx),
};
