"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const generate_unique_id_1 = __importDefault(require("../../../utils/generate-unique-id"));
const stringify_1 = __importDefault(require("./stringify"));
const is_predicate_1 = __importDefault(require("../is-predicate"));
const DEFAULT_OPTIONS = {
    url: void 0,
    method: void 0,
    isAjax: void 0,
};
const MATCH_ANY_REQUEST_REG_EX = /.*/;
// NOTE: RequestFilterRule is a data transfer object
// It should contain only initialization and creation logic
class RequestFilterRule {
    constructor(init) {
        this.options = this._initializeOptions(init);
        this.id = this._initializeId(init, this.options);
        this.isPredicate = is_predicate_1.default(this.options);
    }
    _initializeOptions(init) {
        let tmpOptions = Object.assign({}, DEFAULT_OPTIONS);
        const optionType = typeof init;
        if (optionType === 'string' || lodash_1.isRegExp(init))
            tmpOptions.url = init;
        else if (optionType === 'function')
            tmpOptions = init;
        else if (optionType === 'object') {
            if ('options' in init)
                return this._initializeOptions(init['options']);
            tmpOptions = Object.assign(tmpOptions, init);
        }
        else
            throw new TypeError('Wrong options have been passed to a request filter rule constructor.');
        this._ensureLowerCasedMethod(tmpOptions);
        return tmpOptions;
    }
    _ensureLowerCasedMethod(opts) {
        if (typeof opts.method === 'string')
            opts.method = opts.method.toLowerCase();
    }
    _initializeId(originInit, preparedInit) {
        const originId = originInit['id'];
        if (lodash_1.isString(originId))
            return originId;
        let id = generate_unique_id_1.default();
        if (lodash_1.isObject(preparedInit) && lodash_1.isString(preparedInit['id'])) {
            id = preparedInit['id'];
            delete preparedInit['id'];
        }
        return id;
    }
    static _ensureRule(rule) {
        if (rule instanceof RequestFilterRule)
            return rule;
        return new RequestFilterRule(rule);
    }
    static get ANY() {
        return new RequestFilterRule(MATCH_ANY_REQUEST_REG_EX);
    }
    static isANY(instance) {
        return !!(instance &&
            instance.options &&
            instance.options.url === MATCH_ANY_REQUEST_REG_EX);
    }
    static from(rule) {
        if (!rule)
            return null;
        return this._ensureRule(rule);
    }
    static fromArray(rules) {
        if (!rules)
            return [];
        const ruleArr = lodash_1.castArray(rules);
        return ruleArr.map(rule => this._ensureRule(rule));
    }
    toString() {
        return stringify_1.default(this);
    }
}
exports.default = RequestFilterRule;module.exports = exports.default;

