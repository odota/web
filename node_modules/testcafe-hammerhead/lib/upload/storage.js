"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const mime_1 = __importDefault(require("mime"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const promisified_functions_1 = require("../utils/promisified-functions");
class UploadStorage {
    constructor(uploadRoots) {
        this.uploadRoots = (0, lodash_1.chain)(uploadRoots).castArray().uniq().value();
    }
    static async _getFilesToCopy(files) {
        const filesToCopy = [];
        const errs = [];
        for (const file of files) {
            try {
                const stats = await (0, promisified_functions_1.stat)(file.path);
                if (stats.isFile())
                    filesToCopy.push(file);
            }
            catch (err) {
                errs.push({ path: file.path, err });
            }
        }
        return { filesToCopy, errs };
    }
    static _generateName(existingNames, fileName) {
        const extName = path_1.default.extname(fileName);
        const template = path_1.default.basename(fileName, extName) + ' %s' + extName;
        let index = 0;
        while (existingNames.includes(fileName))
            fileName = (0, util_1.format)(template, ++index);
        return fileName;
    }
    static async _getExistingFiles(uploadsRoot) {
        try {
            return await (0, promisified_functions_1.readDir)(uploadsRoot);
        }
        catch (e) {
            return [];
        }
    }
    async store(fileNames, data) {
        const storedFiles = [];
        const mainUploadRoot = this.uploadRoots[0];
        const err = await UploadStorage.ensureUploadsRoot(mainUploadRoot);
        if (err)
            return [{ err: err.toString(), path: mainUploadRoot }];
        const existingFiles = await UploadStorage._getExistingFiles(mainUploadRoot);
        for (const fileName of fileNames) {
            const storedFileName = UploadStorage._generateName(existingFiles, fileName);
            const storedFilePath = path_1.default.join(mainUploadRoot, storedFileName);
            try {
                await (0, promisified_functions_1.writeFile)(storedFilePath, data[storedFiles.length], { encoding: 'base64' });
                existingFiles.push(storedFileName);
                storedFiles.push({ path: storedFilePath, file: storedFileName });
            }
            catch (e) {
                storedFiles.push({ err: e.toString(), path: storedFilePath, file: fileName });
            }
        }
        return storedFiles;
    }
    async _resolvePath(filePath, result) {
        let resolvedPath = null;
        if (path_1.default.isAbsolute(filePath))
            resolvedPath = filePath;
        else {
            const nonExistingPaths = [];
            for (const uploadRoot of this.uploadRoots) {
                resolvedPath = path_1.default.resolve(uploadRoot, filePath);
                if (await (0, promisified_functions_1.fsObjectExists)(resolvedPath))
                    break;
                nonExistingPaths.push(resolvedPath);
                resolvedPath = null;
            }
            if (resolvedPath === null) {
                result.push({
                    err: `Cannot find the ${filePath}. None path of these exists: ${nonExistingPaths.join(', ')}.`,
                    path: filePath,
                    resolvedPaths: nonExistingPaths,
                });
            }
        }
        return resolvedPath;
    }
    async get(filePathList) {
        const result = [];
        for (const filePath of filePathList) {
            const resolvedPath = await this._resolvePath(filePath, result);
            if (resolvedPath === null)
                continue;
            try {
                const fileContent = await (0, promisified_functions_1.readFile)(resolvedPath);
                const fileStats = await (0, promisified_functions_1.stat)(resolvedPath);
                result.push({
                    data: fileContent.toString('base64'),
                    info: {
                        lastModifiedDate: fileStats.mtime,
                        lastModified: fileStats.mtimeMs,
                        name: path_1.default.basename(resolvedPath),
                        type: mime_1.default.lookup(resolvedPath),
                    },
                });
            }
            catch (e) {
                result.push({ err: e.toString(), path: filePath, resolvedPath });
            }
        }
        return result;
    }
    static async copy(uploadsRoot, files) {
        const { filesToCopy, errs } = await UploadStorage._getFilesToCopy(files);
        const copiedFiles = [];
        if (!filesToCopy.length)
            return { copiedFiles, errs };
        const existingFiles = await UploadStorage._getExistingFiles(uploadsRoot);
        for (const file of filesToCopy) {
            const copiedFileName = UploadStorage._generateName(existingFiles, file.name);
            const copiedFilePath = path_1.default.join(uploadsRoot, copiedFileName);
            try {
                await (0, promisified_functions_1.writeFile)(copiedFilePath, await (0, promisified_functions_1.readFile)(file.path, null));
                existingFiles.push(copiedFileName);
                copiedFiles.push(copiedFilePath);
            }
            catch (err) {
                errs.push({ path: file.path, err });
            }
        }
        return { copiedFiles, errs };
    }
    static async ensureUploadsRoot(uploadsRoot) {
        try {
            if (!await (0, promisified_functions_1.fsObjectExists)(uploadsRoot))
                await (0, promisified_functions_1.makeDir)(uploadsRoot);
            return null;
        }
        catch (err) {
            return err;
        }
    }
}
exports.default = UploadStorage;module.exports = exports.default;

