import * as C from 'fp-ts/es6/Const';
import { flow, identity } from 'fp-ts/es6/function';
import { pipe } from 'fp-ts/es6/pipeable';
import * as RA from 'fp-ts/es6/ReadonlyArray';
import * as _ from './internal';
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.3.8
 */
export var traversal = _.traversal;
/**
 * @category constructors
 * @since 2.3.0
 */
export var id = function () { return traversal(function (_) { return function (f) { return f; }; }); };
/**
 * Create a `Traversal` from a `Traversable`.
 *
 * @category constructor
 * @since 2.3.0
 */
export var fromTraversable = _.fromTraversable;
// -------------------------------------------------------------------------------------
// compositions
// -------------------------------------------------------------------------------------
/**
 * Compose a `Traversal` with a `Traversal`.
 *
 * @category compositions
 * @since 2.3.0
 */
export var compose = _.traversalComposeTraversal;
/**
 * Alias of `compose`.
 *
 * @category compositions
 * @since 2.3.8
 */
export var composeTraversal = compose;
/**
 * Compose a `Traversal` with a `Iso`.
 *
 * @category compositions
 * @since 2.3.8
 */
export var composeIso = 
/*#__PURE__*/
flow(_.isoAsTraversal, compose);
/**
 * Compose a `Traversal` with a `Lens`.
 *
 * @category compositions
 * @since 2.3.8
 */
export var composeLens = 
/*#__PURE__*/
flow(_.lensAsTraversal, _.traversalComposeTraversal);
/**
 * Compose a `Traversal` with a `Prism`.
 *
 * @category compositions
 * @since 2.3.8
 */
export var composePrism = 
/*#__PURE__*/
flow(_.prismAsTraversal, _.traversalComposeTraversal);
/**
 * Compose a `Traversal` with a `Optional`.
 *
 * @category compositions
 * @since 2.3.8
 */
export var composeOptional = 
/*#__PURE__*/
flow(_.optionalAsTraversal, _.traversalComposeTraversal);
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * @category combinators
 * @since 2.3.0
 */
export var modify = function (f) { return function (sa) {
    return sa.modifyF(_.ApplicativeIdentity)(f);
}; };
/**
 * @category combinators
 * @since 2.3.0
 */
export var set = function (a) { return modify(function () { return a; }); };
/**
 * Return a `Traversal` from a `Traversal` focused on a nullable value.
 *
 * @category combinators
 * @since 2.3.0
 */
export var fromNullable = function (sa) {
    return composePrism(_.prismFromNullable())(sa);
};
export function filter(predicate) {
    return compose(_.prismAsTraversal(_.prismFromPredicate(predicate)));
}
/**
 * Return a `Traversal` from a `Traversal` and a prop.
 *
 * @category combinators
 * @since 2.3.0
 */
export var prop = function (prop) {
    return compose(pipe(_.lensId(), _.lensProp(prop), _.lensAsTraversal));
};
/**
 * Return a `Traversal` from a `Traversal` and a list of props.
 *
 * @category combinators
 * @since 2.3.0
 */
export var props = function () {
    var props = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        props[_i] = arguments[_i];
    }
    return compose(pipe(_.lensId(), _.lensProps.apply(_, props), _.lensAsTraversal));
};
/**
 * Return a `Traversal` from a `Traversal` focused on a component of a tuple.
 *
 * @category combinators
 * @since 2.3.0
 */
export var component = function (prop) {
    return compose(pipe(_.lensId(), _.lensComponent(prop), _.lensAsTraversal));
};
/**
 * Return a `Traversal` from a `Traversal` focused on an index of a `ReadonlyArray`.
 *
 * @category combinators
 * @since 2.3.0
 */
export var index = function (i) { return function (sa) {
    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyArray().index(i))));
}; };
/**
 * @category combinators
 * @since 2.3.8
 */
export var indexNonEmpty = function (i) { return function (sa) {
    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyNonEmptyArray().index(i))));
}; };
/**
 * Return a `Traversal` from a `Traversal` focused on a key of a `ReadonlyRecord`.
 *
 * @category combinators
 * @since 2.3.0
 */
export var key = function (key) { return function (sa) {
    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyRecord().index(key))));
}; };
/**
 * Return a `Traversal` from a `Traversal` focused on a required key of a `ReadonlyRecord`.
 *
 * @category combinators
 * @since 2.3.0
 */
export var atKey = function (key) { return function (sa) {
    return pipe(sa, compose(_.lensAsTraversal(_.atReadonlyRecord().at(key))));
}; };
/**
 * Return a `Traversal` from a `Traversal` focused on the `Some` of a `Option` type.
 *
 * @category combinators
 * @since 2.3.0
 */
export var some = 
/*#__PURE__*/
compose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismSome()));
/**
 * Return a `Traversal` from a `Traversal` focused on the `Right` of a `Either` type.
 *
 * @category combinators
 * @since 2.3.0
 */
export var right = 
/*#__PURE__*/
compose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismRight()));
/**
 * Return a `Traversal` from a `Traversal` focused on the `Left` of a `Either` type.
 *
 * @category combinators
 * @since 2.3.0
 */
export var left = 
/*#__PURE__*/
compose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismLeft()));
/**
 * Return a `Traversal` from a `Traversal` focused on a `Traversable`.
 *
 * @category combinators
 * @since 2.3.0
 */
export var traverse = _.traversalTraverse;
export function findFirst(predicate) {
    return composeOptional(_.optionalFindFirst(predicate));
}
export function findFirstNonEmpty(predicate) {
    return composeOptional(_.optionalFindFirstNonEmpty(predicate));
}
/**
 * Map each target to a `Monoid` and combine the results.
 *
 * @category combinators
 * @since 2.3.0
 */
export var foldMap = function (M) { return function (f) { return function (sa) {
    return sa.modifyF(C.getApplicative(M))(function (a) { return C.make(f(a)); });
}; }; };
/**
 * Map each target to a `Monoid` and combine the results.
 *
 * @category combinators
 * @since 2.3.0
 */
export var fold = function (M) { return foldMap(M)(identity); };
/**
 * Get all the targets of a `Traversal`.
 *
 * @category combinators
 * @since 2.3.0
 */
export var getAll = function (s) { return function (sa) {
    return foldMap(RA.getMonoid())(RA.of)(sa)(s);
}; };
// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @category instances
 * @since 2.3.0
 */
export var URI = 'monocle-ts/Traversal';
/**
 * @category instances
 * @since 2.3.8
 */
export var Semigroupoid = {
    URI: URI,
    compose: function (ab, ea) { return compose(ab)(ea); }
};
/**
 * @category instances
 * @since 2.3.0
 */
export var Category = {
    URI: URI,
    compose: Semigroupoid.compose,
    id: id
};
