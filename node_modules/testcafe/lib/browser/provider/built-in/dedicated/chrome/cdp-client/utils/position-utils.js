"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.offsetToClientCoords = exports.getWindowPosition = exports.getClientDimensions = exports.getElementRectangle = exports.getElementFromPoint = exports.getIframePointRelativeToParentFrame = exports.getIframeClientCoordinates = exports.containsOffset = exports.getOffsetPosition = exports.getClientPosition = void 0;
const axis_values_1 = __importDefault(require("../../../../../../../shared/utils/values/axis-values"));
const boundary_values_1 = __importDefault(require("../../../../../../../shared/utils/values/boundary-values"));
const dom_utils_1 = require("./dom-utils");
const clientsManager = __importStar(require("../clients-manager"));
const _1 = require("./");
const style_utils_1 = require("./style-utils");
async function getClientPosition(node) {
    const boxModel = await style_utils_1.getBoxModel(node);
    return new axis_values_1.default(boxModel.border[0], boxModel.border[1]);
}
exports.getClientPosition = getClientPosition;
async function getOffsetPosition(node) {
    const dimensions = await getClientDimensions(node);
    const { left, top } = await style_utils_1.getDocumentScroll(node);
    return { left: dimensions.left + left, top: dimensions.top + top };
}
exports.getOffsetPosition = getOffsetPosition;
async function containsOffset(node, offsetX, offsetY) {
    const dimensions = await getClientDimensions(node);
    const properties = await style_utils_1.getProperties(node, 'scrollWidth', 'scrollHeight');
    const width = Math.max(Number(properties.scrollWidth), dimensions.width);
    const height = Math.max(Number(properties.scrollHeight), dimensions.height);
    const maxX = dimensions.scrollbar.right + dimensions.border.left + dimensions.border.right + width;
    const maxY = dimensions.scrollbar.bottom + dimensions.border.top + dimensions.border.bottom + height;
    return (typeof offsetX === 'undefined' || offsetX >= 0 && maxX >= offsetX) &&
        (typeof offsetY === 'undefined' || offsetY >= 0 && maxY >= offsetY);
}
exports.containsOffset = containsOffset;
async function getIframeClientCoordinates(node) {
    const dimensions = await getClientDimensions(node);
    const [left, top, right, bottom] = [
        dimensions.left + dimensions.border.left + dimensions.paddings.left,
        dimensions.top + dimensions.border.top + dimensions.paddings.left,
        dimensions.right - dimensions.border.right - dimensions.paddings.right,
        dimensions.bottom - dimensions.border.bottom - dimensions.paddings.bottom,
    ];
    return new boundary_values_1.default(top, right, bottom, left);
}
exports.getIframeClientCoordinates = getIframeClientCoordinates;
async function getIframePointRelativeToParentFrame(iframePoint, context) {
    const iframe = await dom_utils_1.findIframeByWindow(context);
    if (!iframe)
        return null;
    const dimensions = await getClientDimensions(iframe);
    const paddings = await style_utils_1.getElementPadding(iframe);
    const left = dimensions.left + dimensions.border.left + paddings.left + iframePoint.x;
    const top = dimensions.top + dimensions.border.top + paddings.top + iframePoint.y;
    return new axis_values_1.default(left, top);
}
exports.getIframePointRelativeToParentFrame = getIframePointRelativeToParentFrame;
async function getElementFromPoint(point) {
    const { DOM } = clientsManager.getClient();
    try {
        const { backendNodeId } = await DOM.getNodeForLocation({ x: point.x, y: point.y });
        const result = await DOM.resolveNode({ backendNodeId });
        if (result === null || result === void 0 ? void 0 : result.object.objectId)
            return _1.describeNode(DOM, result.object.objectId.toString());
    }
    catch (_a) {
        // NOTE: TODO: for some reason this methods throws error for correct `point` values
        // always throws error for negative values
    }
    return null;
}
exports.getElementFromPoint = getElementFromPoint;
async function getElementRectangle(node) {
    const dimensions = await style_utils_1.getElementDimensions(node);
    return {
        height: dimensions.height,
        left: dimensions.left,
        top: dimensions.top,
        width: dimensions.width,
    };
}
exports.getElementRectangle = getElementRectangle;
async function getClientDimensions(node) {
    const elementDimensions = await style_utils_1.getElementDimensions(node);
    const parentFrame = await dom_utils_1.getIframeByElement(node);
    if (parentFrame) {
        const frameBoxModel = await style_utils_1.getBoxModel(parentFrame);
        elementDimensions.left -= frameBoxModel.content[0];
        elementDimensions.top -= frameBoxModel.content[1];
        elementDimensions.bottom -= frameBoxModel.content[1];
        elementDimensions.right -= frameBoxModel.content[0];
    }
    return elementDimensions;
}
exports.getClientDimensions = getClientDimensions;
async function getWindowPosition() {
    const { Runtime } = clientsManager.getClient();
    const args = {
        expression: `({
            x: window.screenLeft || window.screenX,
            y: window.screenTop || window.screenY
        })`,
        returnByValue: true,
    };
    const { result } = await Runtime.evaluate(args);
    return result.value;
}
exports.getWindowPosition = getWindowPosition;
// TODO: implement
async function offsetToClientCoords(point) {
    return point;
}
exports.offsetToClientCoords = offsetToClientCoords;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9zaXRpb24tdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvYnJvd3Nlci9wcm92aWRlci9idWlsdC1pbi9kZWRpY2F0ZWQvY2hyb21lL2NkcC1jbGllbnQvdXRpbHMvcG9zaXRpb24tdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLHVHQUFpSDtBQUNqSCwrR0FBOEc7QUFDOUcsMkNBQXFFO0FBQ3JFLG1FQUFxRDtBQUVyRCx5QkFBa0M7QUFFbEMsK0NBTXVCO0FBS2hCLEtBQUssVUFBVSxpQkFBaUIsQ0FBRSxJQUFnQjtJQUNyRCxNQUFNLFFBQVEsR0FBRyxNQUFNLHlCQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFekMsT0FBTyxJQUFJLHFCQUFVLENBQVMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUUsQ0FBQztBQUpELDhDQUlDO0FBRU0sS0FBSyxVQUFVLGlCQUFpQixDQUFFLElBQWdCO0lBQ3JELE1BQU0sVUFBVSxHQUFNLE1BQU0sbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEQsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxNQUFNLCtCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXBELE9BQU8sRUFBRSxJQUFJLEVBQUUsVUFBVSxDQUFDLElBQUksR0FBRyxJQUFJLEVBQUUsR0FBRyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDdkUsQ0FBQztBQUxELDhDQUtDO0FBRU0sS0FBSyxVQUFVLGNBQWMsQ0FBRSxJQUFnQixFQUFFLE9BQWdCLEVBQUUsT0FBZ0I7SUFDdEYsTUFBTSxVQUFVLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJ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VyxHQUFTLE1BQU0sOEJBQWtCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFekQsSUFBSSxXQUFXLEVBQUU7UUFDYixNQUFNLGFBQWEsR0FBRyxNQUFNLHlCQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFckQsaUJBQWlCLENBQUMsSUFBSSxJQUFNLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckQsaUJBQWlCLENBQUMsR0FBRyxJQUFPLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckQsaUJBQWlCLENBQUMsTUFBTSxJQUFJLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckQsaUJBQWlCLENBQUMsS0FBSyxJQUFLLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDeEQ7SUFFRCxPQUFPLGlCQUFpQixDQUFDO0FBQzdCLENBQUM7QUFkRCxrREFjQztBQUVNLEtBQUssVUFBVSxpQkFBaUI7SUFDbkMsTUFBTSxFQUFFLE9BQU8sRUFBRSxHQUFHLGNBQWMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUUvQyxNQUFNLElBQUksR0FBcUM7UUFDM0MsVUFBVSxFQUFFOzs7V0FHVDtRQUNILGFBQWEsRUFBRSxJQUFJO0tBQ3RCLENBQUM7SUFFRixNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsTUFBTSxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRWhELE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQztBQUN4QixDQUFDO0FBZEQsOENBY0M7QUFFRCxrQkFBa0I7QUFDWCxLQUFLLFVBQVUsb0JBQW9CLENBQUUsS0FBeUI7SUFDakUsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQUZELG9EQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFByb3RvY29sIGZyb20gJ2RldnRvb2xzLXByb3RvY29sL3R5cGVzL3Byb3RvY29sJztcbmltcG9ydCBFeGVjdXRpb25Db250ZXh0IGZyb20gJy4uL2V4ZWN1dGlvbi1jb250ZXh0JztcbmltcG9ydCBBeGlzVmFsdWVzLCB7IEF4aXNWYWx1ZXNEYXRhLCBMZWZ0VG9wVmFsdWVzIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vLi4vc2hhcmVkL3V0aWxzL3ZhbHVlcy9heGlzLXZhbHVlcyc7XG5pbXBvcnQgQm91bmRhcnlWYWx1ZXMsIHsgQm91bmRhcnlWYWx1ZXNEYXRhIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vLi4vc2hhcmVkL3V0aWxzL3ZhbHVlcy9ib3VuZGFyeS12YWx1ZXMnO1xuaW1wb3J0IHsgZmluZElmcmFtZUJ5V2luZG93LCBnZXRJZnJhbWVCeUVsZW1lbnQgfSBmcm9tICcuL2RvbS11dGlscyc7XG5pbXBvcnQgKiBhcyBjbGllbnRzTWFuYWdlciBmcm9tICcuLi9jbGllbnRzLW1hbmFnZXInO1xuaW1wb3J0IHsgUG9zaXRpb25EaW1lbnNpb25zLCBTZXJ2ZXJOb2RlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZGVzY3JpYmVOb2RlIH0gZnJvbSAnLi8nO1xuXG5pbXBvcnQge1xuICAgIGdldEJveE1vZGVsLFxuICAgIGdldERvY3VtZW50U2Nyb2xsLFxuICAgIGdldEVsZW1lbnRQYWRkaW5nLFxuICAgIGdldEVsZW1lbnREaW1lbnNpb25zLFxuICAgIGdldFByb3BlcnRpZXMsXG59IGZyb20gJy4vc3R5bGUtdXRpbHMnO1xuXG5pbXBvcnQgeyBFbGVtZW50UmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vLi4vY2xpZW50L2NvcmUvdXRpbHMvc2hhcmVkL3R5cGVzJztcblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2xpZW50UG9zaXRpb24gKG5vZGU6IFNlcnZlck5vZGUpOiBQcm9taXNlPEF4aXNWYWx1ZXM8bnVtYmVyPj4ge1xuICAgIGNvbnN0IGJveE1vZGVsID0gYXdhaXQgZ2V0Qm94TW9kZWwobm9kZSk7XG5cbiAgICByZXR1cm4gbmV3IEF4aXNWYWx1ZXM8bnVtYmVyPihib3hNb2RlbC5ib3JkZXJbMF0sIGJveE1vZGVsLmJvcmRlclsxXSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPZmZzZXRQb3NpdGlvbiAobm9kZTogU2VydmVyTm9kZSk6IFByb21pc2U8TGVmdFRvcFZhbHVlczxudW1iZXI+PiB7XG4gICAgY29uc3QgZGltZW5zaW9ucyAgICA9IGF3YWl0IGdldENsaWVudERpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3QgeyBsZWZ0LCB0b3AgfSA9IGF3YWl0IGdldERvY3VtZW50U2Nyb2xsKG5vZGUpO1xuXG4gICAgcmV0dXJuIHsgbGVmdDogZGltZW5zaW9ucy5sZWZ0ICsgbGVmdCwgdG9wOiBkaW1lbnNpb25zLnRvcCArIHRvcCB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29udGFpbnNPZmZzZXQgKG5vZGU6IFNlcnZlck5vZGUsIG9mZnNldFg/OiBudW1iZXIsIG9mZnNldFk/OiBudW1iZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBkaW1lbnNpb25zID0gYXdhaXQgZ2V0Q2xpZW50RGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gYXdhaXQgZ2V0UHJvcGVydGllcyhub2RlLCAnc2Nyb2xsV2lkdGgnLCAnc2Nyb2xsSGVpZ2h0Jyk7XG5cbiAgICBjb25zdCB3aWR0aCAgPSBNYXRoLm1heChOdW1iZXIocHJvcGVydGllcy5zY3JvbGxXaWR0aCksIGRpbWVuc2lvbnMud2lkdGgpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KE51bWJlcihwcm9wZXJ0aWVzLnNjcm9sbEhlaWdodCksIGRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICBjb25zdCBtYXhYICAgPSBkaW1lbnNpb25zLnNjcm9sbGJhci5yaWdodCArIGRpbWVuc2lvbnMuYm9yZGVyLmxlZnQgKyBkaW1lbnNpb25zLmJvcmRlci5yaWdodCArIHdpZHRoO1xuICAgIGNvbnN0IG1heFkgICA9IGRpbWVuc2lvbnMuc2Nyb2xsYmFyLmJvdHRvbSArIGRpbWVuc2lvbnMuYm9yZGVyLnRvcCArIGRpbWVuc2lvbnMuYm9yZGVyLmJvdHRvbSArIGhlaWdodDtcblxuICAgIHJldHVybiAodHlwZW9mIG9mZnNldFggPT09ICd1bmRlZmluZWQnIHx8IG9mZnNldFggPj0gMCAmJiBtYXhYID49IG9mZnNldFgpICYmXG4gICAgICAgICh0eXBlb2Ygb2Zmc2V0WSA9PT0gJ3VuZGVmaW5lZCcgfHwgb2Zmc2V0WSA+PSAwICYmIG1heFkgPj0gb2Zmc2V0WSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRJZnJhbWVDbGllbnRDb29yZGluYXRlcyAobm9kZTogU2VydmVyTm9kZSk6IFByb21pc2U8Qm91bmRhcnlWYWx1ZXNEYXRhPiB7XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IGF3YWl0IGdldENsaWVudERpbWVuc2lvbnMobm9kZSk7XG5cbiAgICBjb25zdCBbIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSBdID0gW1xuICAgICAgICBkaW1lbnNpb25zLmxlZnQgKyBkaW1lbnNpb25zLmJvcmRlci5sZWZ0ICsgZGltZW5zaW9ucy5wYWRkaW5ncy5sZWZ0LFxuICAgICAgICBkaW1lbnNpb25zLnRvcCArIGRpbWVuc2lvbnMuYm9yZGVyLnRvcCArIGRpbWVuc2lvbnMucGFkZGluZ3MubGVmdCxcbiAgICAgICAgZGltZW5zaW9ucy5yaWdodCAtIGRpbWVuc2lvbnMuYm9yZGVyLnJpZ2h0IC0gZGltZW5zaW9ucy5wYWRkaW5ncy5yaWdodCxcbiAgICAgICAgZGltZW5zaW9ucy5ib3R0b20gLSBkaW1lbnNpb25zLmJvcmRlci5ib3R0b20gLSBkaW1lbnNpb25zLnBhZGRpbmdzLmJvdHRvbSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIG5ldyBCb3VuZGFyeVZhbHVlcyh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SWZyYW1lUG9pbnRSZWxhdGl2ZVRvUGFyZW50RnJhbWUgKGlmcmFtZVBvaW50OiBBeGlzVmFsdWVzPG51bWJlcj4sIGNvbnRleHQ6IEV4ZWN1dGlvbkNvbnRleHQpOiBQcm9taXNlPEF4aXNWYWx1ZXM8bnVtYmVyPiB8IG51bGw+IHtcbiAgICBjb25zdCBpZnJhbWUgPSBhd2FpdCBmaW5kSWZyYW1lQnlXaW5kb3coY29udGV4dCk7XG5cbiAgICBpZiAoIWlmcmFtZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBkaW1lbnNpb25zID0gYXdhaXQgZ2V0Q2xpZW50RGltZW5zaW9ucyhpZnJhbWUpO1xuICAgIGNvbnN0IHBhZGRpbmdzICAgPSBhd2FpdCBnZXRFbGVtZW50UGFkZGluZyhpZnJhbWUpO1xuXG4gICAgY29uc3QgbGVmdCA9IGRpbWVuc2lvbnMubGVmdCArIGRpbWVuc2lvbnMuYm9yZGVyLmxlZnQgKyBwYWRkaW5ncy5sZWZ0ICsgaWZyYW1lUG9pbnQueDtcbiAgICBjb25zdCB0b3AgID0gZGltZW5zaW9ucy50b3AgKyBkaW1lbnNpb25zLmJvcmRlci50b3AgKyBwYWRkaW5ncy50b3AgKyBpZnJhbWVQb2ludC55O1xuXG4gICAgcmV0dXJuIG5ldyBBeGlzVmFsdWVzPG51bWJlcj4obGVmdCwgdG9wKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVsZW1lbnRGcm9tUG9pbnQgKHBvaW50OiBBeGlzVmFsdWVzRGF0YTxudW1iZXI+KTogUHJvbWlzZTxTZXJ2ZXJOb2RlIHwgbnVsbD4ge1xuICAgIGNvbnN0IHsgRE9NIH0gPSBjbGllbnRzTWFuYWdlci5nZXRDbGllbnQoKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgYmFja2VuZE5vZGVJZCB9ID0gYXdhaXQgRE9NLmdldE5vZGVGb3JMb2NhdGlvbih7IHg6IHBvaW50LngsIHk6IHBvaW50LnkgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgRE9NLnJlc29sdmVOb2RlKHsgYmFja2VuZE5vZGVJZCB9KTtcblxuICAgICAgICBpZiAocmVzdWx0Py5vYmplY3Qub2JqZWN0SWQpXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOb2RlKERPTSwgcmVzdWx0Lm9iamVjdC5vYmplY3RJZC50b1N0cmluZygpKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICAvLyBOT1RFOiBUT0RPOiBmb3Igc29tZSByZWFzb24gdGhpcyBtZXRob2RzIHRocm93cyBlcnJvciBmb3IgY29ycmVjdCBgcG9pbnRgIHZhbHVlc1xuICAgICAgICAvLyBhbHdheXMgdGhyb3dzIGVycm9yIGZvciBuZWdhdGl2ZSB2YWx1ZXNcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVsZW1lbnRSZWN0YW5nbGUgKG5vZGU6IFNlcnZlck5vZGUpOiBQcm9taXNlPEVsZW1lbnRSZWN0YW5nbGU+IHtcbiAgICBjb25zdCBkaW1lbnNpb25zID0gYXdhaXQgZ2V0RWxlbWVudERpbWVuc2lvbnMobm9kZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IGRpbWVuc2lvbnMuaGVpZ2h0LFxuICAgICAgICBsZWZ0OiAgIGRpbWVuc2lvbnMubGVmdCxcbiAgICAgICAgdG9wOiAgICBkaW1lbnNpb25zLnRvcCxcbiAgICAgICAgd2lkdGg6ICBkaW1lbnNpb25zLndpZHRoLFxuICAgIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDbGllbnREaW1lbnNpb25zIChub2RlOiBTZXJ2ZXJOb2RlKTogUHJvbWlzZTxQb3NpdGlvbkRpbWVuc2lvbnM+IHtcbiAgICBjb25zdCBlbGVtZW50RGltZW5zaW9ucyA9IGF3YWl0IGdldEVsZW1lbnREaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IHBhcmVudEZyYW1lICAgICAgID0gYXdhaXQgZ2V0SWZyYW1lQnlFbGVtZW50KG5vZGUpO1xuXG4gICAgaWYgKHBhcmVudEZyYW1lKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lQm94TW9kZWwgPSBhd2FpdCBnZXRCb3hNb2RlbChwYXJlbnRGcmFtZSk7XG5cbiAgICAgICAgZWxlbWVudERpbWVuc2lvbnMubGVmdCAgIC09IGZyYW1lQm94TW9kZWwuY29udGVudFswXTtcbiAgICAgICAgZWxlbWVudERpbWVuc2lvbnMudG9wICAgIC09IGZyYW1lQm94TW9kZWwuY29udGVudFsxXTtcbiAgICAgICAgZWxlbWVudERpbWVuc2lvbnMuYm90dG9tIC09IGZyYW1lQm94TW9kZWwuY29udGVudFsxXTtcbiAgICAgICAgZWxlbWVudERpbWVuc2lvbnMucmlnaHQgIC09IGZyYW1lQm94TW9kZWwuY29udGVudFswXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudERpbWVuc2lvbnM7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRXaW5kb3dQb3NpdGlvbiAoKTogUHJvbWlzZTxBeGlzVmFsdWVzPG51bWJlcj4+IHtcbiAgICBjb25zdCB7IFJ1bnRpbWUgfSA9IGNsaWVudHNNYW5hZ2VyLmdldENsaWVudCgpO1xuXG4gICAgY29uc3QgYXJnczogUHJvdG9jb2wuUnVudGltZS5FdmFsdWF0ZVJlcXVlc3QgPSB7XG4gICAgICAgIGV4cHJlc3Npb246IGAoe1xuICAgICAgICAgICAgeDogd2luZG93LnNjcmVlbkxlZnQgfHwgd2luZG93LnNjcmVlblgsXG4gICAgICAgICAgICB5OiB3aW5kb3cuc2NyZWVuVG9wIHx8IHdpbmRvdy5zY3JlZW5ZXG4gICAgICAgIH0pYCxcbiAgICAgICAgcmV0dXJuQnlWYWx1ZTogdHJ1ZSxcbiAgICB9O1xuXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IFJ1bnRpbWUuZXZhbHVhdGUoYXJncyk7XG5cbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufVxuXG4vLyBUT0RPOiBpbXBsZW1lbnRcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvZmZzZXRUb0NsaWVudENvb3JkcyAocG9pbnQ6IEF4aXNWYWx1ZXM8bnVtYmVyPik6IFByb21pc2U8QXhpc1ZhbHVlczxudW1iZXI+PiB7XG4gICAgcmV0dXJuIHBvaW50O1xufVxuIl19