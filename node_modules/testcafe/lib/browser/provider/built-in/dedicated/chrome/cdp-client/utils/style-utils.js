"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDocumentScroll = exports.getWindowDimensions = exports.hasScroll = exports.getElementScroll = exports.getElementPadding = exports.getBordersWidth = exports.getElementDimensions = exports.getBoxModel = exports.getScroll = exports.getProperties = exports.getStyleProperties = void 0;
const boundary_values_1 = __importDefault(require("../../../../../../../shared/utils/values/boundary-values"));
const dom_utils_1 = require("./dom-utils");
const clientsManager = __importStar(require("../clients-manager"));
async function getPadding(node) {
    const client = clientsManager.getClient();
    const { nodeId } = await client.DOM.requestNode(node);
    const style = await getStyleProperties(nodeId, 'padding-right', 'padding-bottom', 'padding-left', 'padding-top');
    const right = parseInt(style['padding-right'], 10);
    const bottom = parseInt(style['padding-bottom'], 10);
    const left = parseInt(style['padding-left'], 10);
    const top = parseInt(style['padding-top'], 10);
    return new boundary_values_1.default(top, right, bottom, left);
}
async function getStyleProperties(nodeId, ...names) {
    const { CSS } = clientsManager.getClient();
    const properties = {};
    const style = await CSS.getComputedStyleForNode({ nodeId });
    style.computedStyle.filter(property => names.includes(property.name))
        .forEach(property => {
        properties[property.name] = property.value;
    });
    return properties;
}
exports.getStyleProperties = getStyleProperties;
async function getProperties(node, ...names) {
    const { Runtime } = clientsManager.getClient();
    const properties = {};
    const { result } = await Runtime.getProperties(node);
    result.filter(property => names.includes(property.name))
        .forEach(property => {
        var _a;
        properties[property.name] = (_a = property.value) === null || _a === void 0 ? void 0 : _a.value;
    });
    return properties;
}
exports.getProperties = getProperties;
async function getScroll(node) {
    const { scrollLeft, scrollTop } = await getProperties(node, 'scrollLeft', 'scrollTop');
    return { left: Number(scrollLeft), top: Number(scrollTop) };
}
exports.getScroll = getScroll;
async function getBoxModel(node) {
    const { DOM } = clientsManager.getClient();
    const boxModel = await DOM.getBoxModel({ objectId: node.objectId });
    return boxModel.model;
}
exports.getBoxModel = getBoxModel;
async function getElementDimensions(node) {
    // NOTE: for some reason this method call is required for CSS.getComputedStyleForNode
    // TODO: remove this line after the problem is clear
    await clientsManager.getClient().DOM.getDocument({});
    const boxModel = await getBoxModel(node);
    const scroll = await getScroll(node);
    const paddings = await getPadding(node);
    const { width, height, border, padding, content } = boxModel;
    const left = Math.round(border[0]);
    const top = border[1];
    const bottom = top + height;
    const right = left + width;
    const borders = {
        top: padding[1] - border[1],
        right: border[4] - padding[4],
        bottom: border[5] - padding[5],
        left: padding[0] - border[0],
    };
    const scrollbar = {
        right: Math.round(padding[2] - content[2] - paddings.right),
        bottom: Math.round(padding[7] - content[7] - paddings.bottom),
    };
    return {
        border: borders,
        bottom,
        height,
        left,
        right,
        scroll: {
            left: Math.round(Number(scroll.left)),
            top: Math.round(Number(scroll.top)),
        },
        scrollbar,
        paddings,
        top,
        width,
    };
}
exports.getElementDimensions = getElementDimensions;
async function getBordersWidth(node) {
    const dimensions = await getElementDimensions(node);
    return dimensions.border;
}
exports.getBordersWidth = getBordersWidth;
async function getElementPadding(node) {
    return getPadding(node);
}
exports.getElementPadding = getElementPadding;
async function getElementScroll(node) {
    return getScroll(node);
}
exports.getElementScroll = getElementScroll;
async function hasScroll(node) {
    const scroll = await getElementScroll(node);
    return scroll.left > 0 || scroll.top > 0;
}
exports.hasScroll = hasScroll;
async function getWindowDimensions(executionContext) {
    const { Runtime } = clientsManager.getClient();
    const args = {
        expression: `({
            width: document.documentElement.clientWidth,
            height: document.documentElement.clientHeight
        })`,
        returnByValue: true,
    };
    if (executionContext)
        args.contextId = executionContext.ctxId;
    const { result } = await Runtime.evaluate(args);
    const { width, height } = result.value;
    return new boundary_values_1.default(0, width, height, 0);
}
exports.getWindowDimensions = getWindowDimensions;
async function getDocumentScroll(node) {
    const document = await dom_utils_1.getScrollingElement(node);
    return getElementScroll(document);
}
exports.getDocumentScroll = getDocumentScroll;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3R5bGUtdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvYnJvd3Nlci9wcm92aWRlci9idWlsdC1pbi9kZWRpY2F0ZWQvY2hyb21lL2NkcC1jbGllbnQvdXRpbHMvc3R5bGUtdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLCtHQUE4RztBQUc5RywyQ0FBa0Q7QUFFbEQsbUVBQXFEO0FBR3JELEtBQUssVUFBVSxVQUFVLENBQUUsSUFBZ0I7SUFDdkMsTUFBTSxNQUFNLEdBQU8sY0FBYyxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQzlDLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxNQUFNLE1BQU0sQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3RELE1BQU0sS0FBSyxHQUFRLE1BQU0sa0JBQWtCLENBQUMsTUFBTSxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxjQUFjLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFFdEgsTUFBTSxLQUFLLEdBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNwRCxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDckQsTUFBTSxJQUFJLEdBQUssUUFBUSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNuRCxNQUFNLEdBQUcsR0FBTSxRQUFRLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRWxELE9BQU8sSUFBSSx5QkFBYyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3hELENBQUM7QUFFTSxLQUFLLFVBQVUsa0JBQWtC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QU0sQ0FBQyxLQUFLLENBQUM7SUFFdkMsT0FBTyxJQUFJLHlCQUFjLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDbkQsQ0FBQztBQWxCRCxrREFrQkM7QUFFTSxLQUFLLFVBQVUsaUJBQWlCLENBQUUsSUFBZ0I7SUFDckQsTUFBTSxRQUFRLEdBQUcsTUFBTSwrQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUVqRCxPQUFPLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3RDLENBQUM7QUFKRCw4Q0FJQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExlZnRUb3BWYWx1ZXMgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi8uLi9zaGFyZWQvdXRpbHMvdmFsdWVzL2F4aXMtdmFsdWVzJztcbmltcG9ydCBCb3VuZGFyeVZhbHVlcywgeyBCb3VuZGFyeVZhbHVlc0RhdGEgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi8uLi9zaGFyZWQvdXRpbHMvdmFsdWVzL2JvdW5kYXJ5LXZhbHVlcyc7XG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vLi4vY29uZmlndXJhdGlvbi9pbnRlcmZhY2VzJztcbmltcG9ydCBQcm90b2NvbCBmcm9tICdkZXZ0b29scy1wcm90b2NvbC90eXBlcy9wcm90b2NvbCc7XG5pbXBvcnQgeyBnZXRTY3JvbGxpbmdFbGVtZW50IH0gZnJvbSAnLi9kb20tdXRpbHMnO1xuaW1wb3J0IEV4ZWN1dGlvbkNvbnRleHQgZnJvbSAnLi4vZXhlY3V0aW9uLWNvbnRleHQnO1xuaW1wb3J0ICogYXMgY2xpZW50c01hbmFnZXIgZnJvbSAnLi4vY2xpZW50cy1tYW5hZ2VyJztcbmltcG9ydCB7IFNlcnZlck5vZGUsIFBvc2l0aW9uRGltZW5zaW9ucyB9IGZyb20gJy4uL3R5cGVzJztcblxuYXN5bmMgZnVuY3Rpb24gZ2V0UGFkZGluZyAobm9kZTogU2VydmVyTm9kZSk6IFByb21pc2U8Qm91bmRhcnlWYWx1ZXNEYXRhPiB7XG4gICAgY29uc3QgY2xpZW50ICAgICA9IGNsaWVudHNNYW5hZ2VyLmdldENsaWVudCgpO1xuICAgIGNvbnN0IHsgbm9kZUlkIH0gPSBhd2FpdCBjbGllbnQuRE9NLnJlcXVlc3ROb2RlKG5vZGUpO1xuICAgIGNvbnN0IHN0eWxlICAgICAgPSBhd2FpdCBnZXRTdHlsZVByb3BlcnRpZXMobm9kZUlkLCAncGFkZGluZy1yaWdodCcsICdwYWRkaW5nLWJvdHRvbScsICdwYWRkaW5nLWxlZnQnLCAncGFkZGluZy10b3AnKTtcblxuICAgIGNvbnN0IHJpZ2h0ICA9IHBhcnNlSW50KHN0eWxlWydwYWRkaW5nLXJpZ2h0J10sIDEwKTtcbiAgICBjb25zdCBib3R0b20gPSBwYXJzZUludChzdHlsZVsncGFkZGluZy1ib3R0b20nXSwgMTApO1xuICAgIGNvbnN0IGxlZnQgICA9IHBhcnNlSW50KHN0eWxlWydwYWRkaW5nLWxlZnQnXSwgMTApO1xuICAgIGNvbnN0IHRvcCAgICA9IHBhcnNlSW50KHN0eWxlWydwYWRkaW5nLXRvcCddLCAxMCk7XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kYXJ5VmFsdWVzKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdHlsZVByb3BlcnRpZXMgKG5vZGVJZDogbnVtYmVyLCAuLi5uYW1lczogc3RyaW5nW10pOiBQcm9taXNlPERpY3Rpb25hcnk8c3RyaW5nPj4ge1xuICAgIGNvbnN0IHsgQ1NTIH0gPSBjbGllbnRzTWFuYWdlci5nZXRDbGllbnQoKTtcblxuICAgIGNvbnN0IHByb3BlcnRpZXM6IERpY3Rpb25hcnk8c3RyaW5nPiA9IHsgfTtcbiAgICBjb25zdCBzdHlsZSAgICAgICAgICAgICAgICAgICAgICAgICAgPSBhd2FpdCBDU1MuZ2V0Q29tcHV0ZWRTdHlsZUZvck5vZGUoeyBub2RlSWQgfSk7XG5cbiAgICBzdHlsZS5jb21wdXRlZFN0eWxlLmZpbHRlcihwcm9wZXJ0eSA9PiBuYW1lcy5pbmNsdWRlcyhwcm9wZXJ0eS5uYW1lKSlcbiAgICAgICAgLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgICAgICAgICAgcHJvcGVydGllc1twcm9wZXJ0eS5uYW1lXSA9IHByb3BlcnR5LnZhbHVlO1xuICAgICAgICB9KTtcblxuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvcGVydGllcyAobm9kZTogU2VydmVyTm9kZSwgLi4ubmFtZXM6IHN0cmluZ1tdKTogUHJvbWlzZTxEaWN0aW9uYXJ5PHN0cmluZz4+IHtcbiAgICBjb25zdCB7IFJ1bnRpbWUgfSA9IGNsaWVudHNNYW5hZ2VyLmdldENsaWVudCgpO1xuXG4gICAgY29uc3QgcHJvcGVydGllczogRGljdGlvbmFyeTxzdHJpbmc+ID0geyB9O1xuICAgIGNvbnN0IHsgcmVzdWx0IH0gICAgICAgICAgICAgICAgICAgICA9IGF3YWl0IFJ1bnRpbWUuZ2V0UHJvcGVydGllcyhub2RlKTtcblxuICAgIHJlc3VsdC5maWx0ZXIocHJvcGVydHkgPT4gbmFtZXMuaW5jbHVkZXMocHJvcGVydHkubmFtZSkpXG4gICAgICAgIC5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICAgICAgICAgIHByb3BlcnRpZXNbcHJvcGVydHkubmFtZV0gPSBwcm9wZXJ0eS52YWx1ZT8udmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTY3JvbGwgKG5vZGU6IFNlcnZlck5vZGUpOiBQcm9taXNlPExlZnRUb3BWYWx1ZXM8bnVtYmVyPj4ge1xuICAgIGNvbnN0IHsgc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wIH0gPSBhd2FpdCBnZXRQcm9wZXJ0aWVzKG5vZGUsICdzY3JvbGxMZWZ0JywgJ3Njcm9sbFRvcCcpO1xuXG4gICAgcmV0dXJuIHsgbGVmdDogTnVtYmVyKHNjcm9sbExlZnQpLCB0b3A6IE51bWJlcihzY3JvbGxUb3ApIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCb3hNb2RlbCAobm9kZTogU2VydmVyTm9kZSk6IFByb21pc2U8UHJvdG9jb2wuRE9NLkJveE1vZGVsPiB7XG4gICAgY29uc3QgeyBET00gfSAgPSBjbGllbnRzTWFuYWdlci5nZXRDbGllbnQoKTtcbiAgICBjb25zdCBib3hNb2RlbCA9IGF3YWl0IERPTS5nZXRCb3hNb2RlbCh7IG9iamVjdElkOiBub2RlLm9iamVjdElkIH0pO1xuXG4gICAgcmV0dXJuIGJveE1vZGVsLm1vZGVsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RWxlbWVudERpbWVuc2lvbnMgKG5vZGU6IFNlcnZlck5vZGUpOiBQcm9taXNlPFBvc2l0aW9uRGltZW5zaW9ucz4ge1xuICAgIC8vIE5PVEU6IGZvciBzb21lIHJlYXNvbiB0aGlzIG1ldGhvZCBjYWxsIGlzIHJlcXVpcmVkIGZvciBDU1MuZ2V0Q29tcHV0ZWRTdHlsZUZvck5vZGVcbiAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBsaW5lIGFmdGVyIHRoZSBwcm9ibGVtIGlzIGNsZWFyXG4gICAgYXdhaXQgY2xpZW50c01hbmFnZXIuZ2V0Q2xpZW50KCkuRE9NLmdldERvY3VtZW50KHsgfSk7XG5cbiAgICBjb25zdCBib3hNb2RlbCA9IGF3YWl0IGdldEJveE1vZGVsKG5vZGUpO1xuICAgIGNvbnN0IHNjcm9sbCAgID0gYXdhaXQgZ2V0U2Nyb2xsKG5vZGUpO1xuICAgIGNvbnN0IHBhZGRpbmdzID0gYXdhaXQgZ2V0UGFkZGluZyhub2RlKTtcblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgYm9yZGVyLCBwYWRkaW5nLCBjb250ZW50IH0gPSBib3hNb2RlbDtcblxuICAgIGNvbnN0IGxlZnQgICA9IE1hdGgucm91bmQoYm9yZGVyWzBdKTtcbiAgICBjb25zdCB0b3AgICAgPSBib3JkZXJbMV07XG4gICAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICAgIGNvbnN0IHJpZ2h0ICA9IGxlZnQgKyB3aWR0aDtcblxuICAgIGNvbnN0IGJvcmRlcnMgPSB7XG4gICAgICAgIHRvcDogICAgcGFkZGluZ1sxXSAtIGJvcmRlclsxXSxcbiAgICAgICAgcmlnaHQ6ICBib3JkZXJbNF0gLSBwYWRkaW5nWzRdLFxuICAgICAgICBib3R0b206IGJvcmRlcls1XSAtIHBhZGRpbmdbNV0sXG4gICAgICAgIGxlZnQ6ICAgcGFkZGluZ1swXSAtIGJvcmRlclswXSxcbiAgICB9O1xuXG4gICAgY29uc3Qgc2Nyb2xsYmFyID0ge1xuICAgICAgICByaWdodDogIE1hdGgucm91bmQocGFkZGluZ1syXSAtIGNvbnRlbnRbMl0gLSBwYWRkaW5ncy5yaWdodCksXG4gICAgICAgIGJvdHRvbTogTWF0aC5yb3VuZChwYWRkaW5nWzddIC0gY29udGVudFs3XSAtIHBhZGRpbmdzLmJvdHRvbSksXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGJvcmRlcjogYm9yZGVycyxcbiAgICAgICAgYm90dG9tLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0LFxuICAgICAgICBzY3JvbGw6IHtcbiAgICAgICAgICAgIGxlZnQ6IE1hdGgucm91bmQoTnVtYmVyKHNjcm9sbC5sZWZ0KSksXG4gICAgICAgICAgICB0b3A6ICBNYXRoLnJvdW5kKE51bWJlcihzY3JvbGwudG9wKSksXG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbGJhcixcbiAgICAgICAgcGFkZGluZ3MsXG4gICAgICAgIHRvcCxcbiAgICAgICAgd2lkdGgsXG4gICAgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJvcmRlcnNXaWR0aCAobm9kZTogU2VydmVyTm9kZSk6IFByb21pc2U8Qm91bmRhcnlWYWx1ZXNEYXRhPiB7XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IGF3YWl0IGdldEVsZW1lbnREaW1lbnNpb25zKG5vZGUpO1xuXG4gICAgcmV0dXJuIGRpbWVuc2lvbnMuYm9yZGVyO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RWxlbWVudFBhZGRpbmcgKG5vZGU6IFNlcnZlck5vZGUpOiBQcm9taXNlPEJvdW5kYXJ5VmFsdWVzRGF0YT4ge1xuICAgIHJldHVybiBnZXRQYWRkaW5nKG5vZGUpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RWxlbWVudFNjcm9sbCAobm9kZTogU2VydmVyTm9kZSk6IFByb21pc2U8TGVmdFRvcFZhbHVlczxudW1iZXI+PiB7XG4gICAgcmV0dXJuIGdldFNjcm9sbChub2RlKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhc1Njcm9sbCAobm9kZTogU2VydmVyTm9kZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHNjcm9sbCA9IGF3YWl0IGdldEVsZW1lbnRTY3JvbGwobm9kZSk7XG5cbiAgICByZXR1cm4gc2Nyb2xsLmxlZnQgPiAwIHx8IHNjcm9sbC50b3AgPiAwO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0V2luZG93RGltZW5zaW9ucyAoZXhlY3V0aW9uQ29udGV4dD86IEV4ZWN1dGlvbkNvbnRleHQpOiBQcm9taXNlPEJvdW5kYXJ5VmFsdWVzPiB7XG4gICAgY29uc3QgeyBSdW50aW1lIH0gPSBjbGllbnRzTWFuYWdlci5nZXRDbGllbnQoKTtcblxuICAgIGNvbnN0IGFyZ3M6IFByb3RvY29sLlJ1bnRpbWUuRXZhbHVhdGVSZXF1ZXN0ID0ge1xuICAgICAgICBleHByZXNzaW9uOiBgKHtcbiAgICAgICAgICAgIHdpZHRoOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgfSlgLFxuICAgICAgICByZXR1cm5CeVZhbHVlOiB0cnVlLFxuICAgIH07XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dClcbiAgICAgICAgYXJncy5jb250ZXh0SWQgPSBleGVjdXRpb25Db250ZXh0LmN0eElkO1xuXG4gICAgY29uc3QgeyByZXN1bHQgfSAgICAgICAgPSBhd2FpdCBSdW50aW1lLmV2YWx1YXRlKGFyZ3MpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmVzdWx0LnZhbHVlO1xuXG4gICAgcmV0dXJuIG5ldyBCb3VuZGFyeVZhbHVlcygwLCB3aWR0aCwgaGVpZ2h0LCAwKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERvY3VtZW50U2Nyb2xsIChub2RlOiBTZXJ2ZXJOb2RlKTogUHJvbWlzZTxMZWZ0VG9wVmFsdWVzPG51bWJlcj4+IHtcbiAgICBjb25zdCBkb2N1bWVudCA9IGF3YWl0IGdldFNjcm9sbGluZ0VsZW1lbnQobm9kZSk7XG5cbiAgICByZXR1cm4gZ2V0RWxlbWVudFNjcm9sbChkb2N1bWVudCk7XG59XG4iXX0=