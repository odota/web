"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestFileParserBase = exports.Test = exports.Fixture = void 0;
const promisified_functions_1 = require("../../utils/promisified-functions");
const util_1 = require("util");
const runtime_1 = require("../../errors/runtime");
const types_1 = require("../../errors/types");
const METHODS_SPECIFYING_NAME = ['only', 'skip'];
const COMPUTED_NAME_TEXT_TMP = '<computed name>(line: %s)';
const SKIP_PROPERTY_NAME = 'skip';
function getLoc(loc) {
    // NOTE: Don't modify the Babel's parser data structure
    const locCopy = Object.assign({}, loc);
    // NOTE: 'fileName' and 'identifierName' fields with 'undefined' values added in the SourceLocation class constructor.
    // https://github.com/babel/babel/blob/d51aa6d76177b544590cdfe3868f9f4d33d8813d/packages/babel-parser/src/util/location.js#L22
    // Since this is useless information, we remove it.
    delete locCopy.filename;
    delete locCopy.identifierName;
    delete locCopy.start.index;
    delete locCopy.end.index;
    return locCopy;
}
class Fixture {
    constructor(name, start, end, loc, meta, isSkipped) {
        this.name = name;
        this.loc = getLoc(loc);
        this.start = start;
        this.end = end;
        this.meta = meta;
        this.tests = [];
        this.isSkipped = !!isSkipped;
    }
}
exports.Fixture = Fixture;
class Test {
    constructor(name, start, end, loc, meta, isSkipped) {
        this.name = name;
        this.loc = getLoc(loc);
        this.start = start;
        this.end = end;
        this.meta = meta;
        this.isSkipped = !!isSkipped;
    }
}
exports.Test = Test;
class TestFileParserBase {
    constructor(tokenType) {
        this.tokenType = tokenType;
    }
    static formatComputedName(line) {
        return util_1.format(COMPUTED_NAME_TEXT_TMP, line);
    }
    isAsyncFn( /* token */) {
        throw new Error('Not implemented');
    }
    getRValue( /* token */) {
        throw new Error('Not implemented');
    }
    getFunctionBody( /* token */) {
        throw new Error('Not implemented');
    }
    formatFnData( /* name, value, token */) {
        throw new Error('Not implemented');
    }
    analyzeMemberExp( /* token */) {
        throw new Error('Not implemented');
    }
    formatFnArg( /* arg */) {
        throw new Error('Not implemented');
    }
    getFnCall( /* token */) {
        throw new Error('Not implemented');
    }
    getTaggedTemplateExp( /* token */) {
        throw new Error('Not implemented');
    }
    analyzeFnCall( /* token */) {
        throw new Error('Not implemented');
    }
    parse( /* filePath, code */) {
        throw new Error('Not implemented');
    }
    getTokenType( /* token */) {
        throw new Error('Not implemented');
    }
    getCalleeToken( /* token */) {
        throw new Error('Not implemented');
    }
    getMemberFnName() {
        throw new Error('Not implemented');
    }
    getKeyValue() {
        throw new Error('Not implemented');
    }
    getStringValue() {
        throw new Error('Not implemented');
    }
    isApiFn(fn) {
        return fn === 'fixture' || fn === 'test';
    }
    serializeObjExp(token) {
        if (this.getTokenType(token) !== this.tokenType.ObjectLiteralExpression)
            return {};
        return token.properties.reduce((obj, prop) => {
            const { key, value } = this.getKeyValue(prop);
            if (typeof value !== 'string')
                return {};
            obj[key] = value;
            return obj;
        }, {});
    }
    processMetaArgs(token) {
        if (this.getTokenType(token) !== this.tokenType.CallExpression)
            return null;
        const args = token.arguments;
        let meta = {};
        if (args.length === 2) {
            const value = this.getStringValue(args[1]);
            if (typeof value !== 'string')
                return {};
            meta = { [this.formatFnArg(args[0])]: value };
        }
        else if (args.length === 1)
            meta = this.serializeObjExp(args[0]);
        return meta;
    }
    getMetaInfo(callStack) {
        return callStack.reduce((metaCalls, exp) => {
            if (this.getTokenType(exp) !== this.tokenType.CallExpression)
                return metaCalls;
            const callee = this.getCalleeToken(exp);
            const calleeType = this.getTokenType(callee);
            const isCalleeMemberExp = calleeType === this.tokenType.PropertyAccessExpression;
            if (isCalleeMemberExp && this.getMemberFnName(exp) === 'meta')
                return [this.processMetaArgs(exp)].concat(metaCalls);
            return metaCalls;
        }, []);
    }
    static isSkipped(originalToken, token = originalToken) {
        var _a, _b;
        const needSkip = ((_a = token === null || token === void 0 ? void 0 : token.property) === null || _a === void 0 ? void 0 : _a.name) === SKIP_PROPERTY_NAME || ((_b = token === null || token === void 0 ? void 0 : token.name) === null || _b === void 0 ? void 0 : _b.text) === SKIP_PROPERTY_NAME;
        if (!needSkip) {
            token = token.callee || token.tag || token.object || token.expression;
            return token ? TestFileParserBase.isSkipped(originalToken, token) : false;
        }
        return true;
    }
    checkExpDefineTargetName(type, apiFn) {
        //NOTE: fixture('fixtureName').chainFn or test('testName').chainFn
        const isDirectCall = type === this.tokenType.Identifier;
        //NOTE: fixture.skip('fixtureName'), test.only('testName') etc.
        const isMemberCall = type === this.tokenType.PropertyAccessExpression &&
            METHODS_SPECIFYING_NAME.indexOf(apiFn) > -1;
        //NOTE: fixture.before().after()('fixtureName'), test.before()`testName`.after() etc.
        const isTailCall = type === this.tokenType.CallExpression;
        return isDirectCall || isMemberCall || isTailCall;
    }
    analyzeToken(token) {
        const tokenType = this.tokenType;
        const currTokenType = this.getTokenType(token);
        switch (currTokenType) {
            case tokenType.ExpressionStatement:
            case tokenType.TypeAssertionExpression:
                return this.analyzeToken(token.expression);
            case tokenType.FunctionDeclaration:
            case tokenType.FunctionExpression:
                if (this.isAsyncFn(token))
                    return null;
                return this.getFunctionBody(token).map(this.analyzeToken, this);
            case tokenType.VariableDeclaration:
            case tokenType.VariableStatement: {
                const variableValue = this.getRValue(token); // Skip variable declarations like `var foo;`
                return variableValue ? this.analyzeToken(variableValue) : null;
            }
            case tokenType.CallExpression:
            case tokenType.PropertyAccessExpression:
            case tokenType.TaggedTemplateExpression:
                return this.analyzeFnCall(token);
            case tokenType.ReturnStatement:
                return token.argument ? this.analyzeToken(token.argument) : null;
        }
        return null;
    }
    collectTestCafeCalls(astBody) {
        let calls = [];
        astBody.forEach(token => {
            const callExps = this.analyzeToken(token);
            if (callExps)
                calls = calls.concat(callExps);
        });
        return calls;
    }
    analyze(astBody) {
        const fixtures = [];
        const testCafeAPICalls = this.collectTestCafeCalls(astBody);
        testCafeAPICalls.forEach(call => {
            if (!call || typeof call.value !== 'string')
                return;
            if (call.fnName === 'fixture') {
                fixtures.push(new Fixture(call.value, call.start, call.end, call.loc, call.meta, call.isSkipped));
                return;
            }
            if (!fixtures.length)
                return;
            // NOTE: If the fixture is skipped, mark all the tests in the fixture skipped, otherwise, use the current test identifier
            const currentFixture = fixtures[fixtures.length - 1];
            const testIsSkipped = currentFixture.isSkipped || call.isSkipped;
            const test = new Test(call.value, call.start, call.end, call.loc, call.meta, testIsSkipped);
            currentFixture.tests.push(test);
        });
        return fixtures;
    }
    async readFile(filePath) {
        let fileContent = '';
        try {
            fileContent = await promisified_functions_1.readFile(filePath, 'utf8');
        }
        catch (err) {
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.cannotFindSpecifiedTestSource, filePath);
        }
        return fileContent;
    }
    async getTestList(filePath) {
        const fileContent = await this.readFile(filePath);
        return this.parse(fileContent);
    }
    getTestListFromCode(code) {
        return this.parse(code);
    }
}
exports.TestFileParserBase = TestFileParserBase;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC1maWxlLXBhcnNlci1iYXNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBpbGVyL3Rlc3QtZmlsZS90ZXN0LWZpbGUtcGFyc2VyLWJhc2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkVBQTZEO0FBQzdELCtCQUE4QjtBQUM5QixrREFBb0Q7QUFDcEQsOENBQW9EO0FBRXBELE1BQU0sdUJBQXVCLEdBQUcsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDakQsTUFBTSxzQkFBc0IsR0FBSSwyQkFBMkIsQ0FBQztBQUM1RCxNQUFNLGtCQUFrQixHQUFRLE1BQU0sQ0FBQztBQUV2QyxTQUFTLE1BQU0sQ0FBRSxHQUFHO0lBQ2hCLHVEQUF1RDtJQUN2RCxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUV2QyxzSEFBc0g7SUFDdEgsOEhBQThIO0lBQzlILG1EQUFtRDtJQUNuRCxPQUFPLE9BQU8sQ0FBQyxRQUFRLENBQUM7SUFDeEIsT0FBTyxPQUFPLENBQUMsY0FBYyxDQUFDO0lBQzlCLE9BQU8sT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7SUFDM0IsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztJQUV6QixPQUFPLE9BQU8sQ0FBQztBQUNuQixDQUFDO0FBRUQsTUFBYSxPQUFPO0lBQ2hCLFlBQWEsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxTQUFTO1FBQy9DLElBQUksQ0FBQyxJQUFJLEdBQVEsSUFBSSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxHQUFHLEdBQVMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLElBQUksQ0FBQyxLQUFLLEdBQU8sS0FBSyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxHQUFHLEdBQVMsR0FBRyxDQUFDO1FBQ3JCLElB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QyxJQUFJLENBQUMsQ0FBQztRQUNwQyxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sUUFBUSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxLQUFLLENBQUMsUUFBUSxDQUFFLFFBQVE7UUFDcEIsSUFBSSxXQUFXLEdBQUcsRUFBRSxDQUFDO1FBRXJCLElBQUk7WUFDQSxXQUFXLEdBQUcsTUFBTSxnQ0FBUSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztTQUNsRDtRQUVELE9BQU8sR0FBRyxFQUFFO1lBQ1IsTUFBTSxJQUFJLHNCQUFZLENBQUMsc0JBQWMsQ0FBQyw2QkFBNkIsRUFBRSxRQUFRLENBQUMsQ0FBQztTQUNsRjtRQUVELE9BQU8sV0FBVyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxLQUFLLENBQUMsV0FBVyxDQUFFLFFBQVE7UUFDdkIsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRWxELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRUQsbUJBQW1CLENBQUUsSUFBSTtRQUNyQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDNUIsQ0FBQztDQUNKO0FBeFBELGdEQXdQQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlYWRGaWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcHJvbWlzaWZpZWQtZnVuY3Rpb25zJztcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgR2VuZXJhbEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzL3J1bnRpbWUnO1xuaW1wb3J0IHsgUlVOVElNRV9FUlJPUlMgfSBmcm9tICcuLi8uLi9lcnJvcnMvdHlwZXMnO1xuXG5jb25zdCBNRVRIT0RTX1NQRUNJRllJTkdfTkFNRSA9IFsnb25seScsICdza2lwJ107XG5jb25zdCBDT01QVVRFRF9OQU1FX1RFWFRfVE1QICA9ICc8Y29tcHV0ZWQgbmFtZT4obGluZTogJXMpJztcbmNvbnN0IFNLSVBfUFJPUEVSVFlfTkFNRSAgICAgID0gJ3NraXAnO1xuXG5mdW5jdGlvbiBnZXRMb2MgKGxvYykge1xuICAgIC8vIE5PVEU6IERvbid0IG1vZGlmeSB0aGUgQmFiZWwncyBwYXJzZXIgZGF0YSBzdHJ1Y3R1cmVcbiAgICBjb25zdCBsb2NDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgbG9jKTtcblxuICAgIC8vIE5PVEU6ICdmaWxlTmFtZScgYW5kICdpZGVudGlmaWVyTmFtZScgZmllbGRzIHdpdGggJ3VuZGVmaW5lZCcgdmFsdWVzIGFkZGVkIGluIHRoZSBTb3VyY2VMb2NhdGlvbiBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvYmxvYi9kNTFhYTZkNzYxNzdiNTQ0NTkwY2RmZTM4NjhmOWY0ZDMzZDg4MTNkL3BhY2thZ2VzL2JhYmVsLXBhcnNlci9zcmMvdXRpbC9sb2NhdGlvbi5qcyNMMjJcbiAgICAvLyBTaW5jZSB0aGlzIGlzIHVzZWxlc3MgaW5mb3JtYXRpb24sIHdlIHJlbW92ZSBpdC5cbiAgICBkZWxldGUgbG9jQ29weS5maWxlbmFtZTtcbiAgICBkZWxldGUgbG9jQ29weS5pZGVudGlmaWVyTmFtZTtcbiAgICBkZWxldGUgbG9jQ29weS5zdGFydC5pbmRleDtcbiAgICBkZWxldGUgbG9jQ29weS5lbmQuaW5kZXg7XG5cbiAgICByZXR1cm4gbG9jQ29weTtcbn1cblxuZXhwb3J0IGNsYXNzIEZpeHR1cmUge1xuICAgIGNvbnN0cnVjdG9yIChuYW1lLCBzdGFydCwgZW5kLCBsb2MsIG1ldGEsIGlzU2tpcHBlZCkge1xuICAgICAgICB0aGlzLm5hbWUgICAgICA9IG5hbWU7XG4gICAgICAgIHRoaXMubG9jICAgICAgID0gZ2V0TG9jKGxvYyk7XG4gICAgICAgIHRoaXMuc3RhcnQgICAgID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kICAgICAgID0gZW5kO1xuICAgICAgICB0aGlzLm1ldGEgICAgICA9IG1ldGE7XG4gICAgICAgIHRoaXMudGVzdHMgICAgID0gW107XG4gICAgICAgIHRoaXMuaXNTa2lwcGVkID0gISFpc1NraXBwZWQ7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGVzdCB7XG4gICAgY29uc3RydWN0b3IgKG5hbWUsIHN0YXJ0LCBlbmQsIGxvYywgbWV0YSwgaXNTa2lwcGVkKSB7XG4gICAgICAgIHRoaXMubmFtZSAgICAgID0gbmFtZTtcbiAgICAgICAgdGhpcy5sb2MgICAgICAgPSBnZXRMb2MobG9jKTtcbiAgICAgICAgdGhpcy5zdGFydCAgICAgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgICAgICAgPSBlbmQ7XG4gICAgICAgIHRoaXMubWV0YSAgICAgID0gbWV0YTtcbiAgICAgICAgdGhpcy5pc1NraXBwZWQgPSAhIWlzU2tpcHBlZDtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUZXN0RmlsZVBhcnNlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICh0b2tlblR5cGUpIHtcbiAgICAgICAgdGhpcy50b2tlblR5cGUgPSB0b2tlblR5cGU7XG4gICAgfVxuXG4gICAgc3RhdGljIGZvcm1hdENvbXB1dGVkTmFtZSAobGluZSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0KENPTVBVVEVEX05BTUVfVEVYVF9UTVAsIGxpbmUpO1xuICAgIH1cblxuICAgIGlzQXN5bmNGbiAoLyogdG9rZW4gKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG5cbiAgICBnZXRSVmFsdWUgKC8qIHRva2VuICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuXG4gICAgZ2V0RnVuY3Rpb25Cb2R5ICgvKiB0b2tlbiAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIGZvcm1hdEZuRGF0YSAoLyogbmFtZSwgdmFsdWUsIHRva2VuICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuXG4gICAgYW5hbHl6ZU1lbWJlckV4cCAoLyogdG9rZW4gKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG5cbiAgICBmb3JtYXRGbkFyZyAoLyogYXJnICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuXG4gICAgZ2V0Rm5DYWxsICgvKiB0b2tlbiAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIGdldFRhZ2dlZFRlbXBsYXRlRXhwICgvKiB0b2tlbiAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIGFuYWx5emVGbkNhbGwgKC8qIHRva2VuICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuXG4gICAgcGFyc2UgKC8qIGZpbGVQYXRoLCBjb2RlICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuXG4gICAgZ2V0VG9rZW5UeXBlICgvKiB0b2tlbiAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIGdldENhbGxlZVRva2VuICgvKiB0b2tlbiAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIGdldE1lbWJlckZuTmFtZSAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuXG4gICAgZ2V0S2V5VmFsdWUgKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIGdldFN0cmluZ1ZhbHVlICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG5cbiAgICBpc0FwaUZuIChmbikge1xuICAgICAgICByZXR1cm4gZm4gPT09ICdmaXh0dXJlJyB8fCBmbiA9PT0gJ3Rlc3QnO1xuICAgIH1cblxuICAgIHNlcmlhbGl6ZU9iakV4cCAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VG9rZW5UeXBlKHRva2VuKSAhPT0gdGhpcy50b2tlblR5cGUuT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24pXG4gICAgICAgICAgICByZXR1cm4ge307XG5cbiAgICAgICAgcmV0dXJuIHRva2VuLnByb3BlcnRpZXMucmVkdWNlKChvYmosIHByb3ApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gdGhpcy5nZXRLZXlWYWx1ZShwcm9wKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHJldHVybiB7fTtcblxuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSwge30pO1xuICAgIH1cblxuICAgIHByb2Nlc3NNZXRhQXJncyAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VG9rZW5UeXBlKHRva2VuKSAhPT0gdGhpcy50b2tlblR5cGUuQ2FsbEV4cHJlc3Npb24pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCBhcmdzID0gdG9rZW4uYXJndW1lbnRzO1xuXG4gICAgICAgIGxldCBtZXRhID0ge307XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0U3RyaW5nVmFsdWUoYXJnc1sxXSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSByZXR1cm4ge307XG5cbiAgICAgICAgICAgIG1ldGEgPSB7IFt0aGlzLmZvcm1hdEZuQXJnKGFyZ3NbMF0pXTogdmFsdWUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgbWV0YSA9IHRoaXMuc2VyaWFsaXplT2JqRXhwKGFyZ3NbMF0pO1xuXG4gICAgICAgIHJldHVybiBtZXRhO1xuICAgIH1cblxuICAgIGdldE1ldGFJbmZvIChjYWxsU3RhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxTdGFjay5yZWR1Y2UoKG1ldGFDYWxscywgZXhwKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRUb2tlblR5cGUoZXhwKSAhPT0gdGhpcy50b2tlblR5cGUuQ2FsbEV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFDYWxscztcblxuICAgICAgICAgICAgY29uc3QgY2FsbGVlICAgICAgICAgICAgPSB0aGlzLmdldENhbGxlZVRva2VuKGV4cCk7XG4gICAgICAgICAgICBjb25zdCBjYWxsZWVUeXBlICAgICAgICA9IHRoaXMuZ2V0VG9rZW5UeXBlKGNhbGxlZSk7XG4gICAgICAgICAgICBjb25zdCBpc0NhbGxlZU1lbWJlckV4cCA9IGNhbGxlZVR5cGUgPT09IHRoaXMudG9rZW5UeXBlLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbjtcblxuICAgICAgICAgICAgaWYgKGlzQ2FsbGVlTWVtYmVyRXhwICYmIHRoaXMuZ2V0TWVtYmVyRm5OYW1lKGV4cCkgPT09ICdtZXRhJylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMucHJvY2Vzc01ldGFBcmdzKGV4cCldLmNvbmNhdChtZXRhQ2FsbHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWV0YUNhbGxzO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzU2tpcHBlZCAob3JpZ2luYWxUb2tlbiwgdG9rZW4gPSBvcmlnaW5hbFRva2VuKSB7XG4gICAgICAgIGNvbnN0IG5lZWRTa2lwID0gdG9rZW4/LnByb3BlcnR5Py5uYW1lID09PSBTS0lQX1BST1BFUlRZX05BTUUgfHwgdG9rZW4/Lm5hbWU/LnRleHQgPT09IFNLSVBfUFJPUEVSVFlfTkFNRTtcblxuICAgICAgICBpZiAoIW5lZWRTa2lwKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLmNhbGxlZSB8fCB0b2tlbi50YWcgfHwgdG9rZW4ub2JqZWN0IHx8IHRva2VuLmV4cHJlc3Npb247XG5cbiAgICAgICAgICAgIHJldHVybiB0b2tlbiA/IFRlc3RGaWxlUGFyc2VyQmFzZS5pc1NraXBwZWQob3JpZ2luYWxUb2tlbiwgdG9rZW4pIDogZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjaGVja0V4cERlZmluZVRhcmdldE5hbWUgKHR5cGUsIGFwaUZuKSB7XG4gICAgICAgIC8vTk9URTogZml4dHVyZSgnZml4dHVyZU5hbWUnKS5jaGFpbkZuIG9yIHRlc3QoJ3Rlc3ROYW1lJykuY2hhaW5GblxuICAgICAgICBjb25zdCBpc0RpcmVjdENhbGwgPSB0eXBlID09PSB0aGlzLnRva2VuVHlwZS5JZGVudGlmaWVyO1xuXG4gICAgICAgIC8vTk9URTogZml4dHVyZS5za2lwKCdmaXh0dXJlTmFtZScpLCB0ZXN0Lm9ubHkoJ3Rlc3ROYW1lJykgZXRjLlxuICAgICAgICBjb25zdCBpc01lbWJlckNhbGwgPSB0eXBlID09PSB0aGlzLnRva2VuVHlwZS5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTUVUSE9EU19TUEVDSUZZSU5HX05BTUUuaW5kZXhPZihhcGlGbikgPiAtMTtcblxuICAgICAgICAvL05PVEU6IGZpeHR1cmUuYmVmb3JlKCkuYWZ0ZXIoKSgnZml4dHVyZU5hbWUnKSwgdGVzdC5iZWZvcmUoKWB0ZXN0TmFtZWAuYWZ0ZXIoKSBldGMuXG4gICAgICAgIGNvbnN0IGlzVGFpbENhbGwgPSB0eXBlID09PSB0aGlzLnRva2VuVHlwZS5DYWxsRXhwcmVzc2lvbjtcblxuICAgICAgICByZXR1cm4gaXNEaXJlY3RDYWxsIHx8IGlzTWVtYmVyQ2FsbCB8fCBpc1RhaWxDYWxsO1xuICAgIH1cblxuICAgIGFuYWx5emVUb2tlbiAodG9rZW4pIHtcbiAgICAgICAgY29uc3QgdG9rZW5UeXBlICAgICA9IHRoaXMudG9rZW5UeXBlO1xuICAgICAgICBjb25zdCBjdXJyVG9rZW5UeXBlID0gdGhpcy5nZXRUb2tlblR5cGUodG9rZW4pO1xuXG4gICAgICAgIHN3aXRjaCAoY3VyclRva2VuVHlwZSkge1xuICAgICAgICAgICAgY2FzZSB0b2tlblR5cGUuRXhwcmVzc2lvblN0YXRlbWVudDpcbiAgICAgICAgICAgIGNhc2UgdG9rZW5UeXBlLlR5cGVBc3NlcnRpb25FeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFuYWx5emVUb2tlbih0b2tlbi5leHByZXNzaW9uKTtcblxuICAgICAgICAgICAgY2FzZSB0b2tlblR5cGUuRnVuY3Rpb25EZWNsYXJhdGlvbjpcbiAgICAgICAgICAgIGNhc2UgdG9rZW5UeXBlLkZ1bmN0aW9uRXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FzeW5jRm4odG9rZW4pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZ1bmN0aW9uQm9keSh0b2tlbikubWFwKHRoaXMuYW5hbHl6ZVRva2VuLCB0aGlzKTtcblxuICAgICAgICAgICAgY2FzZSB0b2tlblR5cGUuVmFyaWFibGVEZWNsYXJhdGlvbjpcbiAgICAgICAgICAgIGNhc2UgdG9rZW5UeXBlLlZhcmlhYmxlU3RhdGVtZW50OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGVWYWx1ZSA9IHRoaXMuZ2V0UlZhbHVlKHRva2VuKTsgLy8gU2tpcCB2YXJpYWJsZSBkZWNsYXJhdGlvbnMgbGlrZSBgdmFyIGZvbztgXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFibGVWYWx1ZSA/IHRoaXMuYW5hbHl6ZVRva2VuKHZhcmlhYmxlVmFsdWUpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgdG9rZW5UeXBlLkNhbGxFeHByZXNzaW9uOlxuICAgICAgICAgICAgY2FzZSB0b2tlblR5cGUuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uOlxuICAgICAgICAgICAgY2FzZSB0b2tlblR5cGUuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFuYWx5emVGbkNhbGwodG9rZW4pO1xuXG4gICAgICAgICAgICBjYXNlIHRva2VuVHlwZS5SZXR1cm5TdGF0ZW1lbnQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLmFyZ3VtZW50ID8gdGhpcy5hbmFseXplVG9rZW4odG9rZW4uYXJndW1lbnQpIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbGxlY3RUZXN0Q2FmZUNhbGxzIChhc3RCb2R5KSB7XG4gICAgICAgIGxldCBjYWxscyA9IFtdO1xuXG4gICAgICAgIGFzdEJvZHkuZm9yRWFjaCh0b2tlbiA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYWxsRXhwcyA9IHRoaXMuYW5hbHl6ZVRva2VuKHRva2VuKTtcblxuICAgICAgICAgICAgaWYgKGNhbGxFeHBzKVxuICAgICAgICAgICAgICAgIGNhbGxzID0gY2FsbHMuY29uY2F0KGNhbGxFeHBzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNhbGxzO1xuICAgIH1cblxuICAgIGFuYWx5emUgKGFzdEJvZHkpIHtcbiAgICAgICAgY29uc3QgZml4dHVyZXMgICAgICAgICA9IFtdO1xuICAgICAgICBjb25zdCB0ZXN0Q2FmZUFQSUNhbGxzID0gdGhpcy5jb2xsZWN0VGVzdENhZmVDYWxscyhhc3RCb2R5KTtcblxuICAgICAgICB0ZXN0Q2FmZUFQSUNhbGxzLmZvckVhY2goY2FsbCA9PiB7XG4gICAgICAgICAgICBpZiAoIWNhbGwgfHwgdHlwZW9mIGNhbGwudmFsdWUgIT09ICdzdHJpbmcnKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChjYWxsLmZuTmFtZSA9PT0gJ2ZpeHR1cmUnKSB7XG4gICAgICAgICAgICAgICAgZml4dHVyZXMucHVzaChuZXcgRml4dHVyZShjYWxsLnZhbHVlLCBjYWxsLnN0YXJ0LCBjYWxsLmVuZCwgY2FsbC5sb2MsIGNhbGwubWV0YSwgY2FsbC5pc1NraXBwZWQpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmaXh0dXJlcy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gTk9URTogSWYgdGhlIGZpeHR1cmUgaXMgc2tpcHBlZCwgbWFyayBhbGwgdGhlIHRlc3RzIGluIHRoZSBmaXh0dXJlIHNraXBwZWQsIG90aGVyd2lzZSwgdXNlIHRoZSBjdXJyZW50IHRlc3QgaWRlbnRpZmllclxuICAgICAgICAgICAgY29uc3QgY3VycmVudEZpeHR1cmUgPSBmaXh0dXJlc1tmaXh0dXJlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RJc1NraXBwZWQgID0gY3VycmVudEZpeHR1cmUuaXNTa2lwcGVkIHx8IGNhbGwuaXNTa2lwcGVkO1xuICAgICAgICAgICAgY29uc3QgdGVzdCAgICAgICAgICAgPSBuZXcgVGVzdChjYWxsLnZhbHVlLCBjYWxsLnN0YXJ0LCBjYWxsLmVuZCwgY2FsbC5sb2MsIGNhbGwubWV0YSwgdGVzdElzU2tpcHBlZCk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRGaXh0dXJlLnRlc3RzLnB1c2godGVzdCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmaXh0dXJlcztcbiAgICB9XG5cbiAgICBhc3luYyByZWFkRmlsZSAoZmlsZVBhdGgpIHtcbiAgICAgICAgbGV0IGZpbGVDb250ZW50ID0gJyc7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbGVDb250ZW50ID0gYXdhaXQgcmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR2VuZXJhbEVycm9yKFJVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRTcGVjaWZpZWRUZXN0U291cmNlLCBmaWxlUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsZUNvbnRlbnQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0VGVzdExpc3QgKGZpbGVQYXRoKSB7XG4gICAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgdGhpcy5yZWFkRmlsZShmaWxlUGF0aCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoZmlsZUNvbnRlbnQpO1xuICAgIH1cblxuICAgIGdldFRlc3RMaXN0RnJvbUNvZGUgKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoY29kZSk7XG4gICAgfVxufVxuIl19