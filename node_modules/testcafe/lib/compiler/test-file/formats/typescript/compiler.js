"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const lodash_1 = require("lodash");
const os_family_1 = __importDefault(require("os-family"));
const api_based_1 = __importDefault(require("../../api-based"));
const compiler_1 = __importDefault(require("../es-next/compiler"));
const typescript_configuration_1 = __importDefault(require("../../../../configuration/typescript-configuration"));
const runtime_1 = require("../../../../errors/runtime");
const types_1 = require("../../../../errors/types");
const debug_1 = __importDefault(require("debug"));
const test_page_url_1 = require("../../../../api/test-page-url");
const exportble_lib_path_1 = __importDefault(require("../../exportble-lib-path"));
const disable_v8_optimization_note_1 = __importDefault(require("../../disable-v8-optimization-note"));
// NOTE: For type definitions only
const typescript_1 = require("typescript");
function testcafeImportPathReplacer() {
    return context => {
        const visit = (node) => {
            var _a;
            // @ts-ignore
            if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.kind) === typescript_1.SyntaxKind.ImportDeclaration && node.kind === typescript_1.SyntaxKind.StringLiteral && node.text === 'testcafe')
                return typescript_1.createStringLiteral(exportble_lib_path_1.default);
            return typescript_1.visitEachChild(node, child => visit(child), context);
        };
        return node => typescript_1.visitNode(node, visit);
    };
}
function disableV8OptimizationCodeAppender() {
    return () => {
        const visit = (node) => {
            const evalStatement = typescript_1.createExpressionStatement(typescript_1.createCall(typescript_1.createIdentifier('eval'), void 0, [typescript_1.createStringLiteral('')]));
            const evalStatementWithComment = typescript_1.addSyntheticLeadingComment(evalStatement, typescript_1.SyntaxKind.MultiLineCommentTrivia, disable_v8_optimization_note_1.default, true);
            // @ts-ignore
            return typescript_1.updateSourceFileNode(node, [...node.statements, evalStatementWithComment]);
        };
        return node => typescript_1.visitNode(node, visit);
    };
}
const DEBUG_LOGGER = debug_1.default('testcafe:compiler:typescript');
const RENAMED_DEPENDENCIES_MAP = new Map([['testcafe', exportble_lib_path_1.default]]);
const DEFAULT_TYPESCRIPT_COMPILER_PATH = 'typescript';
class TypeScriptTestFileCompiler extends api_based_1.default {
    constructor(compilerOptions, isCompilerServiceMode) {
        super(isCompilerServiceMode);
        // NOTE: At present, it's necessary create an instance TypeScriptTestFileCompiler
        // to collect a list of supported test file extensions.
        // So all compilers creates 2 times: first time - for collecting all supported file extensions,
        // second one - for compiling tests.
        // In future, need to rewrite 'getSupportedExtension' method as static.
        const configPath = compilerOptions && compilerOptions.configPath || null;
        this._customCompilerOptions = compilerOptions && compilerOptions.options;
        this._tsConfig = new typescript_configuration_1.default(configPath, isCompilerServiceMode);
        this._compilerPath = TypeScriptTestFileCompiler._getCompilerPath(compilerOptions);
    }
    static _getCompilerPath(compilerOptions) {
        let compilerPath = compilerOptions && compilerOptions.customCompilerModulePath;
        if (!compilerPath || compilerPath === DEFAULT_TYPESCRIPT_COMPILER_PATH)
            return DEFAULT_TYPESCRIPT_COMPILER_PATH;
        // NOTE: if the relative path to custom TypeScript compiler module is specified
        // then we will resolve the path from the root of the 'testcafe' module
        if (test_page_url_1.isRelative(compilerPath)) {
            const testcafeRootFolder = path_1.default.resolve(__dirname, '../../../../../');
            compilerPath = path_1.default.resolve(testcafeRootFolder, compilerPath);
        }
        return compilerPath;
    }
    _loadTypeScriptCompiler() {
        try {
            return require(this._compilerPath);
        }
        catch (err) {
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.typeScriptCompilerLoadingError, err.message);
        }
    }
    static _normalizeFilename(filename) {
        filename = path_1.default.resolve(filename);
        if (os_family_1.default.win)
            filename = filename.toLowerCase();
        return filename;
    }
    static _getTSDefsPath() {
        return TypeScriptTestFileCompiler._normalizeFilename(path_1.default.resolve(__dirname, '../../../../../ts-defs/index.d.ts'));
    }
    _reportErrors(diagnostics) {
        // NOTE: lazy load the compiler
        const ts = this._loadTypeScriptCompiler();
        let errMsg = 'TypeScript compilation failed.\n';
        diagnostics.forEach(d => {
            const message = ts.flattenDiagnosticMessageText(d.messageText, '\n');
            const file = d.file;
            if (file && d.start !== void 0) {
                const { line, character } = file.getLineAndCharacterOfPosition(d.start);
                errMsg += `${file.fileName} (${line + 1}, ${character + 1}): `;
            }
            errMsg += `${message}\n`;
        });
        throw new Error(errMsg);
    }
    _compileCodeForTestFiles(testFilesInfo) {
        return this._tsConfig.init(this._customCompilerOptions)
            .then(() => {
            return super._compileCodeForTestFiles(testFilesInfo);
        });
    }
    _compileFilesToCache(ts, filenames) {
        const opts = this._tsConfig.getOptions();
        const program = ts.createProgram([TypeScriptTestFileCompiler.tsDefsPath, ...filenames], opts);
        DEBUG_LOGGER('version: %s', ts.version);
        DEBUG_LOGGER('options: %O', opts);
        program.getSourceFiles().forEach(sourceFile => {
            // @ts-ignore A hack to allow import globally installed TestCafe in tests
            sourceFile.renamedDependencies = RENAMED_DEPENDENCIES_MAP;
        });
        const diagnostics = ts.getPreEmitDiagnostics(program);
        if (diagnostics.length)
            this._reportErrors(diagnostics);
        // NOTE: The first argument of emit() is a source file to be compiled. If it's undefined, all files in
        // <program> will be compiled. <program> contains a file specified in createProgram() plus all its dependencies.
        // This mode is much faster than compiling files one-by-one, and it is used in the tsc CLI compiler.
        program.emit(void 0, (outputName, result, writeBOM, onError, sources) => {
            if (!sources)
                return;
            const sourcePath = TypeScriptTestFileCompiler._normalizeFilename(sources[0].fileName);
            this.cache[sourcePath] = result;
        }, void 0, void 0, {
            before: this._getTypescriptTransformers(),
        });
    }
    _getTypescriptTransformers() {
        const transformers = [testcafeImportPathReplacer()];
        if (this.isCompilerServiceMode)
            transformers.push(disableV8OptimizationCodeAppender());
        return transformers;
    }
    _precompileCode(testFilesInfo) {
        DEBUG_LOGGER('path: "%s"', this._compilerPath);
        // NOTE: lazy load the compiler
        const ts = this._loadTypeScriptCompiler();
        const filenames = testFilesInfo.map(({ filename }) => filename);
        const normalizedFilenames = filenames.map(filename => TypeScriptTestFileCompiler._normalizeFilename(filename));
        const normalizedFilenamesMap = lodash_1.zipObject(normalizedFilenames, filenames);
        const uncachedFiles = normalizedFilenames
            .filter(filename => filename !== TypeScriptTestFileCompiler.tsDefsPath && !this.cache[filename])
            .map(filename => normalizedFilenamesMap[filename]);
        if (uncachedFiles.length)
            this._compileFilesToCache(ts, uncachedFiles);
        return normalizedFilenames.map(filename => this.cache[filename]);
    }
    _getRequireCompilers() {
        return {
            '.ts': (code, filename) => this._compileCode(code, filename),
            '.tsx': (code, filename) => this._compileCode(code, filename),
            '.js': (code, filename) => compiler_1.default.prototype._compileCode.call(this, code, filename),
            '.jsx': (code, filename) => compiler_1.default.prototype._compileCode.call(this, code, filename),
        };
    }
    get canPrecompile() {
        return true;
    }
    getSupportedExtension() {
        return ['.ts', '.tsx'];
    }
}
exports.default = TypeScriptTestFileCompiler;
TypeScriptTestFileCompiler.tsDefsPath = TypeScriptTestFileCompiler._getTSDefsPath();
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcGlsZXIvdGVzdC1maWxlL2Zvcm1hdHMvdHlwZXNjcmlwdC9jb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdEQUF3QjtBQUN4QixtQ0FBbUM7QUFDbkMsMERBQTJCO0FBQzNCLGdFQUEyRDtBQUMzRCxtRUFBeUQ7QUFDekQsa0hBQXlGO0FBQ3pGLHdEQUEwRDtBQUMxRCxvREFBMEQ7QUFDMUQsa0RBQTBCO0FBQzFCLGlFQUEyRDtBQUMzRCxrRkFBMkQ7QUFDM0Qsc0dBQThFO0FBRTlFLGtDQUFrQztBQUNsQywyQ0FnQm9CO0FBa0JwQixTQUFTLDBCQUEwQjtJQUMvQixPQUFPLE9BQU8sQ0FBQyxFQUFFO1FBQ2IsTUFBTSxLQUFLLEdBQVksQ0FBQyxJQUFJLEVBQXFCLEVBQUU7O1lBQy9DLGFBQWE7WUFDYixJQUFJLE9BQUEsSUFBSSxDQUFDLE1BQU0sMENBQUUsSUFBSSxNQUFLLHVCQUFVLENBQUMsaUJBQWlCLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyx1QkFBVSxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFVBQVU7Z0JBQ3hILE9BQU8sZ0NBQW1CLENBQUMsNEJBQW1CLENBQUMsQ0FBQztZQUVwRCxPQUFPLDJCQUFjLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2hFLENBQUMsQ0FBQztRQUVGLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxzQkFBUyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztJQUMxQyxDQUFDLENBQUM7QUFDTixDQUFDO0FBRUQsU0FBUyxpQ0FBaUM7SUFDdEMsT0FBTyxHQUFHLEVBQUU7UUFDUixNQUFNLEtBQUssR0FBWSxDQUFDLElBQUksRUFBcUIsRUFBRTtZQUMv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QztRQUVqRCxPQUFPLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRU0sb0JBQW9CO1FBQ3ZCLE9BQU87WUFDSCxLQUFLLEVBQUcsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUM7WUFDN0QsTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDO1lBQzdELEtBQUssRUFBRyxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsRUFBRSxDQUFDLGtCQUFzQixDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDO1lBQ3BHLE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsRUFBRSxDQUFDLGtCQUFzQixDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDO1NBQ3ZHLENBQUM7SUFDTixDQUFDO0lBRUQsSUFBVyxhQUFhO1FBQ3BCLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxxQkFBcUI7UUFDeEIsT0FBTyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztJQUMzQixDQUFDOztBQXJLTCw2Q0FzS0M7QUFyS2tCLHFDQUFVLEdBQUcsMEJBQTBCLENBQUMsY0FBYyxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHppcE9iamVjdCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgT1MgZnJvbSAnb3MtZmFtaWx5JztcbmltcG9ydCBBUElCYXNlZFRlc3RGaWxlQ29tcGlsZXJCYXNlIGZyb20gJy4uLy4uL2FwaS1iYXNlZCc7XG5pbXBvcnQgRVNOZXh0VGVzdEZpbGVDb21waWxlciBmcm9tICcuLi9lcy1uZXh0L2NvbXBpbGVyJztcbmltcG9ydCBUeXBlc2NyaXB0Q29uZmlndXJhdGlvbiBmcm9tICcuLi8uLi8uLi8uLi9jb25maWd1cmF0aW9uL3R5cGVzY3JpcHQtY29uZmlndXJhdGlvbic7XG5pbXBvcnQgeyBHZW5lcmFsRXJyb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9lcnJvcnMvcnVudGltZSc7XG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uLy4uLy4uLy4uL2Vycm9ycy90eXBlcyc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgaXNSZWxhdGl2ZSB9IGZyb20gJy4uLy4uLy4uLy4uL2FwaS90ZXN0LXBhZ2UtdXJsJztcbmltcG9ydCBFWFBPUlRBQkxFX0xJQl9QQVRIIGZyb20gJy4uLy4uL2V4cG9ydGJsZS1saWItcGF0aCc7XG5pbXBvcnQgRElTQUJMRV9WOF9PUFRJTUlaQVRJT05fTk9URSBmcm9tICcuLi8uLi9kaXNhYmxlLXY4LW9wdGltaXphdGlvbi1ub3RlJztcblxuLy8gTk9URTogRm9yIHR5cGUgZGVmaW5pdGlvbnMgb25seVxuaW1wb3J0IFR5cGVTY3JpcHQsIHtcbiAgICBDb21waWxlck9wdGlvbnNWYWx1ZSxcbiAgICBTeW50YXhLaW5kLFxuICAgIFZpc2l0UmVzdWx0LFxuICAgIFZpc2l0b3IsXG4gICAgTm9kZSxcbiAgICBjcmVhdGVTdHJpbmdMaXRlcmFsLFxuICAgIHZpc2l0RWFjaENoaWxkLFxuICAgIHZpc2l0Tm9kZSxcbiAgICBUcmFuc2Zvcm1lckZhY3RvcnksXG4gICAgY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICBjcmVhdGVDYWxsLFxuICAgIGNyZWF0ZUlkZW50aWZpZXIsXG4gICAgdXBkYXRlU291cmNlRmlsZU5vZGUsXG4gICAgU291cmNlRmlsZSxcbiAgICBhZGRTeW50aGV0aWNMZWFkaW5nQ29tbWVudCxcbn0gZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7IERpY3Rpb25hcnksIFR5cGVTY3JpcHRDb21waWxlck9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25maWd1cmF0aW9uL2ludGVyZmFjZXMnO1xuXG5kZWNsYXJlIHR5cGUgVHlwZVNjcmlwdEluc3RhbmNlID0gdHlwZW9mIFR5cGVTY3JpcHQ7XG5cbmludGVyZmFjZSBUZXN0RmlsZUluZm8ge1xuICAgIGZpbGVuYW1lOiBzdHJpbmc7XG59XG5cbmRlY2xhcmUgaW50ZXJmYWNlIFJlcXVpcmVDb21waWxlckZ1bmN0aW9uIHtcbiAgICAoY29kZTogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVxdWlyZUNvbXBpbGVycyB7XG4gICAgW2V4dGVuc2lvbjogc3RyaW5nXTogUmVxdWlyZUNvbXBpbGVyRnVuY3Rpb247XG59XG5cbmZ1bmN0aW9uIHRlc3RjYWZlSW1wb3J0UGF0aFJlcGxhY2VyPFQgZXh0ZW5kcyBOb2RlPiAoKTogVHJhbnNmb3JtZXJGYWN0b3J5PFQ+IHtcbiAgICByZXR1cm4gY29udGV4dCA9PiB7XG4gICAgICAgIGNvbnN0IHZpc2l0OiBWaXNpdG9yID0gKG5vZGUpOiBWaXNpdFJlc3VsdDxOb2RlPiA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQ/LmtpbmQgPT09IFN5bnRheEtpbmQuSW1wb3J0RGVjbGFyYXRpb24gJiYgbm9kZS5raW5kID09PSBTeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwgJiYgbm9kZS50ZXh0ID09PSAndGVzdGNhZmUnKVxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVTdHJpbmdMaXRlcmFsKEVYUE9SVEFCTEVfTElCX1BBVEgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdmlzaXRFYWNoQ2hpbGQobm9kZSwgY2hpbGQgPT4gdmlzaXQoY2hpbGQpLCBjb250ZXh0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbm9kZSA9PiB2aXNpdE5vZGUobm9kZSwgdmlzaXQpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGRpc2FibGVWOE9wdGltaXphdGlvbkNvZGVBcHBlbmRlcjxUIGV4dGVuZHMgTm9kZT4gKCk6IFRyYW5zZm9ybWVyRmFjdG9yeTxUPiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3QgdmlzaXQ6IFZpc2l0b3IgPSAobm9kZSk6IFZpc2l0UmVzdWx0PE5vZGU+ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV2YWxTdGF0ZW1lbnQgPSBjcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KGNyZWF0ZUNhbGwoXG4gICAgICAgICAgICAgICAgY3JlYXRlSWRlbnRpZmllcignZXZhbCcpLFxuICAgICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgICBbY3JlYXRlU3RyaW5nTGl0ZXJhbCgnJyldXG4gICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgY29uc3QgZXZhbFN0YXRlbWVudFdpdGhDb21tZW50ID0gYWRkU3ludGhldGljTGVhZGluZ0NvbW1lbnQoZXZhbFN0YXRlbWVudCwgU3ludGF4S2luZC5NdWx0aUxpbmVDb21tZW50VHJpdmlhLCBESVNBQkxFX1Y4X09QVElNSVpBVElPTl9OT1RFLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVNvdXJjZUZpbGVOb2RlKG5vZGUsIFsuLi5ub2RlLnN0YXRlbWVudHMsIGV2YWxTdGF0ZW1lbnRXaXRoQ29tbWVudF0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBub2RlID0+IHZpc2l0Tm9kZShub2RlLCB2aXNpdCk7XG4gICAgfTtcbn1cblxuXG5jb25zdCBERUJVR19MT0dHRVIgPSBkZWJ1ZygndGVzdGNhZmU6Y29tcGlsZXI6dHlwZXNjcmlwdCcpO1xuXG5jb25zdCBSRU5BTUVEX0RFUEVOREVOQ0lFU19NQVAgPSBuZXcgTWFwKFtbJ3Rlc3RjYWZlJywgRVhQT1JUQUJMRV9MSUJfUEFUSF1dKTtcblxuY29uc3QgREVGQVVMVF9UWVBFU0NSSVBUX0NPTVBJTEVSX1BBVEggPSAndHlwZXNjcmlwdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyIGV4dGVuZHMgQVBJQmFzZWRUZXN0RmlsZUNvbXBpbGVyQmFzZSB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgdHNEZWZzUGF0aCA9IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9nZXRUU0RlZnNQYXRoKCk7XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IF90c0NvbmZpZzogVHlwZXNjcmlwdENvbmZpZ3VyYXRpb247XG4gICAgcHJpdmF0ZSByZWFkb25seSBfY29tcGlsZXJQYXRoOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfY3VzdG9tQ29tcGlsZXJPcHRpb25zPzogb2JqZWN0O1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yIChjb21waWxlck9wdGlvbnM/OiBUeXBlU2NyaXB0Q29tcGlsZXJPcHRpb25zLCBpc0NvbXBpbGVyU2VydmljZU1vZGU/OiBib29sZWFuKSB7XG4gICAgICAgIHN1cGVyKGlzQ29tcGlsZXJTZXJ2aWNlTW9kZSk7XG5cbiAgICAgICAgLy8gTk9URTogQXQgcHJlc2VudCwgaXQncyBuZWNlc3NhcnkgY3JlYXRlIGFuIGluc3RhbmNlIFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyXG4gICAgICAgIC8vIHRvIGNvbGxlY3QgYSBsaXN0IG9mIHN1cHBvcnRlZCB0ZXN0IGZpbGUgZXh0ZW5zaW9ucy5cbiAgICAgICAgLy8gU28gYWxsIGNvbXBpbGVycyBjcmVhdGVzIDIgdGltZXM6IGZpcnN0IHRpbWUgLSBmb3IgY29sbGVjdGluZyBhbGwgc3VwcG9ydGVkIGZpbGUgZXh0ZW5zaW9ucyxcbiAgICAgICAgLy8gc2Vjb25kIG9uZSAtIGZvciBjb21waWxpbmcgdGVzdHMuXG4gICAgICAgIC8vIEluIGZ1dHVyZSwgbmVlZCB0byByZXdyaXRlICdnZXRTdXBwb3J0ZWRFeHRlbnNpb24nIG1ldGhvZCBhcyBzdGF0aWMuXG5cbiAgICAgICAgY29uc3QgY29uZmlnUGF0aCA9IGNvbXBpbGVyT3B0aW9ucyAmJiBjb21waWxlck9wdGlvbnMuY29uZmlnUGF0aCB8fCBudWxsO1xuXG4gICAgICAgIHRoaXMuX2N1c3RvbUNvbXBpbGVyT3B0aW9ucyA9IGNvbXBpbGVyT3B0aW9ucyAmJiBjb21waWxlck9wdGlvbnMub3B0aW9ucztcbiAgICAgICAgdGhpcy5fdHNDb25maWcgICAgICAgICAgICAgID0gbmV3IFR5cGVzY3JpcHRDb25maWd1cmF0aW9uKGNvbmZpZ1BhdGgsIGlzQ29tcGlsZXJTZXJ2aWNlTW9kZSk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVyUGF0aCAgICAgICAgICA9IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9nZXRDb21waWxlclBhdGgoY29tcGlsZXJPcHRpb25zKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBfZ2V0Q29tcGlsZXJQYXRoIChjb21waWxlck9wdGlvbnM/OiBUeXBlU2NyaXB0Q29tcGlsZXJPcHRpb25zKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IGNvbXBpbGVyUGF0aCA9IGNvbXBpbGVyT3B0aW9ucyAmJiBjb21waWxlck9wdGlvbnMuY3VzdG9tQ29tcGlsZXJNb2R1bGVQYXRoO1xuXG4gICAgICAgIGlmICghY29tcGlsZXJQYXRoIHx8IGNvbXBpbGVyUGF0aCA9PT0gREVGQVVMVF9UWVBFU0NSSVBUX0NPTVBJTEVSX1BBVEgpXG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9UWVBFU0NSSVBUX0NPTVBJTEVSX1BBVEg7XG5cbiAgICAgICAgLy8gTk9URTogaWYgdGhlIHJlbGF0aXZlIHBhdGggdG8gY3VzdG9tIFR5cGVTY3JpcHQgY29tcGlsZXIgbW9kdWxlIGlzIHNwZWNpZmllZFxuICAgICAgICAvLyB0aGVuIHdlIHdpbGwgcmVzb2x2ZSB0aGUgcGF0aCBmcm9tIHRoZSByb290IG9mIHRoZSAndGVzdGNhZmUnIG1vZHVsZVxuICAgICAgICBpZiAoaXNSZWxhdGl2ZShjb21waWxlclBhdGgpKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0Y2FmZVJvb3RGb2xkZXIgPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4vLi4vLi4vLi4vLi4vJyk7XG5cbiAgICAgICAgICAgIGNvbXBpbGVyUGF0aCA9IHBhdGgucmVzb2x2ZSh0ZXN0Y2FmZVJvb3RGb2xkZXIsIGNvbXBpbGVyUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcGlsZXJQYXRoO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2xvYWRUeXBlU2NyaXB0Q29tcGlsZXIgKCk6IFR5cGVTY3JpcHRJbnN0YW5jZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZSh0aGlzLl9jb21waWxlclBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMudHlwZVNjcmlwdENvbXBpbGVyTG9hZGluZ0Vycm9yLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBfbm9ybWFsaXplRmlsZW5hbWUgKGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBmaWxlbmFtZSA9IHBhdGgucmVzb2x2ZShmaWxlbmFtZSk7XG5cbiAgICAgICAgaWYgKE9TLndpbilcbiAgICAgICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2dldFRTRGVmc1BhdGggKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci5fbm9ybWFsaXplRmlsZW5hbWUocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uLy4uLy4uLy4uLy4uL3RzLWRlZnMvaW5kZXguZC50cycpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9yZXBvcnRFcnJvcnMgKGRpYWdub3N0aWNzOiBSZWFkb25seTxUeXBlU2NyaXB0LkRpYWdub3N0aWNbXT4pOiB2b2lkIHtcbiAgICAgICAgLy8gTk9URTogbGF6eSBsb2FkIHRoZSBjb21waWxlclxuICAgICAgICBjb25zdCB0czogVHlwZVNjcmlwdEluc3RhbmNlID0gdGhpcy5fbG9hZFR5cGVTY3JpcHRDb21waWxlcigpO1xuICAgICAgICBsZXQgZXJyTXNnID0gJ1R5cGVTY3JpcHQgY29tcGlsYXRpb24gZmFpbGVkLlxcbic7XG5cbiAgICAgICAgZGlhZ25vc3RpY3MuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0cy5mbGF0dGVuRGlhZ25vc3RpY01lc3NhZ2VUZXh0KGQubWVzc2FnZVRleHQsICdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgICAgPSBkLmZpbGU7XG5cbiAgICAgICAgICAgIGlmIChmaWxlICYmIGQuc3RhcnQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGluZSwgY2hhcmFjdGVyIH0gPSBmaWxlLmdldExpbmVBbmRDaGFyYWN0ZXJPZlBvc2l0aW9uKGQuc3RhcnQpO1xuXG4gICAgICAgICAgICAgICAgZXJyTXNnICs9IGAke2ZpbGUuZmlsZU5hbWV9ICgke2xpbmUgKyAxfSwgJHtjaGFyYWN0ZXIgKyAxfSk6IGA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVyck1zZyArPSBgJHttZXNzYWdlfVxcbmA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgIH1cblxuICAgIHB1YmxpYyBfY29tcGlsZUNvZGVGb3JUZXN0RmlsZXMgKHRlc3RGaWxlc0luZm86IFRlc3RGaWxlSW5mb1tdKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHNDb25maWcuaW5pdCh0aGlzLl9jdXN0b21Db21waWxlck9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLl9jb21waWxlQ29kZUZvclRlc3RGaWxlcyh0ZXN0RmlsZXNJbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NvbXBpbGVGaWxlc1RvQ2FjaGUgKHRzOiBUeXBlU2NyaXB0SW5zdGFuY2UsIGZpbGVuYW1lczogc3RyaW5nW10pOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgb3B0cyAgICA9IHRoaXMuX3RzQ29uZmlnLmdldE9wdGlvbnMoKSBhcyBEaWN0aW9uYXJ5PENvbXBpbGVyT3B0aW9uc1ZhbHVlPjtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHRzLmNyZWF0ZVByb2dyYW0oW1R5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLnRzRGVmc1BhdGgsIC4uLmZpbGVuYW1lc10sIG9wdHMpO1xuXG4gICAgICAgIERFQlVHX0xPR0dFUigndmVyc2lvbjogJXMnLCB0cy52ZXJzaW9uKTtcbiAgICAgICAgREVCVUdfTE9HR0VSKCdvcHRpb25zOiAlTycsIG9wdHMpO1xuXG4gICAgICAgIHByb2dyYW0uZ2V0U291cmNlRmlsZXMoKS5mb3JFYWNoKHNvdXJjZUZpbGUgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBBIGhhY2sgdG8gYWxsb3cgaW1wb3J0IGdsb2JhbGx5IGluc3RhbGxlZCBUZXN0Q2FmZSBpbiB0ZXN0c1xuICAgICAgICAgICAgc291cmNlRmlsZS5yZW5hbWVkRGVwZW5kZW5jaWVzID0gUkVOQU1FRF9ERVBFTkRFTkNJRVNfTUFQO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBkaWFnbm9zdGljcyA9IHRzLmdldFByZUVtaXREaWFnbm9zdGljcyhwcm9ncmFtKTtcblxuICAgICAgICBpZiAoZGlhZ25vc3RpY3MubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3JzKGRpYWdub3N0aWNzKTtcblxuICAgICAgICAvLyBOT1RFOiBUaGUgZmlyc3QgYXJndW1lbnQgb2YgZW1pdCgpIGlzIGEgc291cmNlIGZpbGUgdG8gYmUgY29tcGlsZWQuIElmIGl0J3MgdW5kZWZpbmVkLCBhbGwgZmlsZXMgaW5cbiAgICAgICAgLy8gPHByb2dyYW0+IHdpbGwgYmUgY29tcGlsZWQuIDxwcm9ncmFtPiBjb250YWlucyBhIGZpbGUgc3BlY2lmaWVkIGluIGNyZWF0ZVByb2dyYW0oKSBwbHVzIGFsbCBpdHMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAvLyBUaGlzIG1vZGUgaXMgbXVjaCBmYXN0ZXIgdGhhbiBjb21waWxpbmcgZmlsZXMgb25lLWJ5LW9uZSwgYW5kIGl0IGlzIHVzZWQgaW4gdGhlIHRzYyBDTEkgY29tcGlsZXIuXG4gICAgICAgIHByb2dyYW0uZW1pdCh2b2lkIDAsIChvdXRwdXROYW1lLCByZXN1bHQsIHdyaXRlQk9NLCBvbkVycm9yLCBzb3VyY2VzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQYXRoID0gVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIuX25vcm1hbGl6ZUZpbGVuYW1lKHNvdXJjZXNbMF0uZmlsZU5hbWUpO1xuXG4gICAgICAgICAgICB0aGlzLmNhY2hlW3NvdXJjZVBhdGhdID0gcmVzdWx0O1xuICAgICAgICB9LCB2b2lkIDAsIHZvaWQgMCwge1xuICAgICAgICAgICAgYmVmb3JlOiB0aGlzLl9nZXRUeXBlc2NyaXB0VHJhbnNmb3JtZXJzKCksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2dldFR5cGVzY3JpcHRUcmFuc2Zvcm1lcnMgKCk6IFRyYW5zZm9ybWVyRmFjdG9yeTxTb3VyY2VGaWxlPltdIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZXJzOiBUcmFuc2Zvcm1lckZhY3Rvcnk8U291cmNlRmlsZT5bXSA9IFt0ZXN0Y2FmZUltcG9ydFBhdGhSZXBsYWNlcigpXTtcblxuICAgICAgICBpZiAodGhpcy5pc0NvbXBpbGVyU2VydmljZU1vZGUpXG4gICAgICAgICAgICB0cmFuc2Zvcm1lcnMucHVzaChkaXNhYmxlVjhPcHRpbWl6YXRpb25Db2RlQXBwZW5kZXIoKSk7XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVycztcbiAgICB9XG5cbiAgICBwdWJsaWMgX3ByZWNvbXBpbGVDb2RlICh0ZXN0RmlsZXNJbmZvOiBUZXN0RmlsZUluZm9bXSk6IHN0cmluZ1tdIHtcbiAgICAgICAgREVCVUdfTE9HR0VSKCdwYXRoOiBcIiVzXCInLCB0aGlzLl9jb21waWxlclBhdGgpO1xuXG4gICAgICAgIC8vIE5PVEU6IGxhenkgbG9hZCB0aGUgY29tcGlsZXJcbiAgICAgICAgY29uc3QgdHM6IFR5cGVTY3JpcHRJbnN0YW5jZSA9IHRoaXMuX2xvYWRUeXBlU2NyaXB0Q29tcGlsZXIoKTtcbiAgICAgICAgY29uc3QgZmlsZW5hbWVzICAgICAgICAgICAgICA9IHRlc3RGaWxlc0luZm8ubWFwKCh7IGZpbGVuYW1lIH0pID0+IGZpbGVuYW1lKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEZpbGVuYW1lcyAgICA9IGZpbGVuYW1lcy5tYXAoZmlsZW5hbWUgPT4gVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIuX25vcm1hbGl6ZUZpbGVuYW1lKGZpbGVuYW1lKSk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGaWxlbmFtZXNNYXAgPSB6aXBPYmplY3Qobm9ybWFsaXplZEZpbGVuYW1lcywgZmlsZW5hbWVzKTtcblxuICAgICAgICBjb25zdCB1bmNhY2hlZEZpbGVzID0gbm9ybWFsaXplZEZpbGVuYW1lc1xuICAgICAgICAgICAgLmZpbHRlcihmaWxlbmFtZSA9PiBmaWxlbmFtZSAhPT0gVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIudHNEZWZzUGF0aCAmJiAhdGhpcy5jYWNoZVtmaWxlbmFtZV0pXG4gICAgICAgICAgICAubWFwKGZpbGVuYW1lID0+IG5vcm1hbGl6ZWRGaWxlbmFtZXNNYXBbZmlsZW5hbWVdKTtcblxuICAgICAgICBpZiAodW5jYWNoZWRGaWxlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLl9jb21waWxlRmlsZXNUb0NhY2hlKHRzLCB1bmNhY2hlZEZpbGVzKTtcblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZEZpbGVuYW1lcy5tYXAoZmlsZW5hbWUgPT4gdGhpcy5jYWNoZVtmaWxlbmFtZV0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBfZ2V0UmVxdWlyZUNvbXBpbGVycyAoKTogUmVxdWlyZUNvbXBpbGVycyB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnLnRzJzogIChjb2RlLCBmaWxlbmFtZSkgPT4gdGhpcy5fY29tcGlsZUNvZGUoY29kZSwgZmlsZW5hbWUpLFxuICAgICAgICAgICAgJy50c3gnOiAoY29kZSwgZmlsZW5hbWUpID0+IHRoaXMuX2NvbXBpbGVDb2RlKGNvZGUsIGZpbGVuYW1lKSxcbiAgICAgICAgICAgICcuanMnOiAgKGNvZGUsIGZpbGVuYW1lKSA9PiBFU05leHRUZXN0RmlsZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvZGUuY2FsbCh0aGlzLCBjb2RlLCBmaWxlbmFtZSksXG4gICAgICAgICAgICAnLmpzeCc6IChjb2RlLCBmaWxlbmFtZSkgPT4gRVNOZXh0VGVzdEZpbGVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb2RlLmNhbGwodGhpcywgY29kZSwgZmlsZW5hbWUpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgY2FuUHJlY29tcGlsZSAoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRTdXBwb3J0ZWRFeHRlbnNpb24gKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIFsnLnRzJywgJy50c3gnXTtcbiAgICB9XG59XG4iXX0=