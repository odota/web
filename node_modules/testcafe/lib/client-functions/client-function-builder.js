"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const test_run_tracker_1 = __importDefault(require("../api/test-run-tracker"));
const builder_symbol_1 = __importDefault(require("./builder-symbol"));
const replicator_1 = require("./replicator");
const observation_1 = require("../test-run/commands/observation");
const compile_client_function_1 = __importDefault(require("../compiler/compile-client-function"));
const runtime_1 = require("../errors/runtime");
const type_assertions_1 = require("../errors/runtime/type-assertions");
const types_1 = require("../errors/types");
const get_callsite_1 = require("../errors/get-callsite");
const re_executable_promise_1 = __importDefault(require("../utils/re-executable-promise"));
const marker_symbol_1 = __importDefault(require("../test-run/marker-symbol"));
const selector_api_execution_mode_1 = __importDefault(require("./selector-api-execution-mode"));
const check_element_delay_1 = __importDefault(require("../client/driver/command-executors/client-functions/selector-executor/check-element-delay"));
const templates_1 = __importDefault(require("../errors/test-run/templates"));
const dedent_1 = __importDefault(require("dedent"));
const DEFAULT_EXECUTION_CALLSITE_NAME = '__$$clientFunction$$';
class ClientFunctionBuilder {
    constructor(fn, options, callsiteNames = {}) {
        this.callsiteNames = {
            instantiation: callsiteNames.instantiation,
            execution: callsiteNames.execution || DEFAULT_EXECUTION_CALLSITE_NAME,
        };
        if (lodash_1.isNil(options))
            options = {};
        this._validateOptions(options);
        this.fn = fn;
        this.options = options;
        this.compiledFnCode = this._getCompiledFnCode();
        if (!this.compiledFnCode)
            throw this._createInvalidFnTypeError();
        this.replicator = replicator_1.createReplicator(this._getReplicatorTransforms());
    }
    _renderError(error) {
        // The rendered template is shown in the Watch panel of browser dev tools or IDE.
        // Viewport size is unlimited there.
        const viewportWidth = Number.MIN_SAFE_INTEGER;
        const renderedMessage = templates_1.default[error.code](error, viewportWidth);
        return dedent_1.default(renderedMessage);
    }
    _decorateFunction(clientFn) {
        clientFn[builder_symbol_1.default] = this;
        clientFn.with = options => {
            return this._getClientFnWithOverriddenOptions(options);
        };
    }
    _getClientFnWithOverriddenOptions(options) {
        if (typeof options === 'object')
            options = lodash_1.assign({}, this.options, options);
        const builder = new this.constructor(this.fn, options, {
            instantiation: 'with',
            execution: this.callsiteNames.execution,
        });
        return builder.getFunction();
    }
    getBoundTestRun() {
        // NOTE: `boundTestRun` can be either TestController or TestRun instance.
        if (this.options.boundTestRun)
            return this.options.boundTestRun.testRun || this.options.boundTestRun;
        return null;
    }
    _getTestRun() {
        return this.getBoundTestRun() || test_run_tracker_1.default.resolveContextTestRun();
    }
    _getObservedCallsites() {
        var _a;
        return ((_a = this._getTestRun()) === null || _a === void 0 ? void 0 : _a.observedCallsites) || null;
    }
    getFunction() {
        const builder = this;
        const clientFn = function __$$clientFunction$$() {
            const testRun = builder._getTestRun();
            const callsite = get_callsite_1.getCallsiteForMethod(builder.callsiteNames.execution);
            const args = [];
            // OPTIMIZATION: don't leak `arguments` object.
            for (let i = 0; i < arguments.length; i++)
                args.push(arguments[i]);
            if (selector_api_execution_mode_1.default.isSync)
                return builder._executeCommandSync(args, testRun, callsite);
            return builder._executeCommand(args, testRun, callsite);
        };
        this._decorateFunction(clientFn);
        return clientFn;
    }
    getCommand(args) {
        const encodedArgs = this.replicator.encode(args);
        const encodedDependencies = this.replicator.encode(this.getFunctionDependencies());
        return this._createTestRunCommand(encodedArgs, encodedDependencies);
    }
    // Overridable methods
    getFunctionDependencies() {
        return this.options.dependencies || {};
    }
    _createTestRunCommand(encodedArgs, encodedDependencies) {
        return new observation_1.ExecuteClientFunctionCommand({
            instantiationCallsiteName: this.callsiteNames.instantiation,
            fnCode: this.compiledFnCode,
            args: encodedArgs,
            dependencies: encodedDependencies,
        }, this._getTestRun());
    }
    _getCompiledFnCode() {
        if (typeof this.fn === 'function')
            return compile_client_function_1.default(this.fn.toString(), this.options.dependencies, this.callsiteNames.instantiation, this.callsiteNames.instantiation);
        return null;
    }
    _createInvalidFnTypeError() {
        return new runtime_1.ClientFunctionAPIError(this.callsiteNames.instantiation, this.callsiteNames.instantiation, types_1.RUNTIME_ERRORS.clientFunctionCodeIsNotAFunction, typeof this.fn);
    }
    _executeCommand(args, testRun, callsite) {
        // NOTE: should be kept outside of lazy promise to preserve
        // correct callsite in case of replicator error.
        const command = this.getCommand(args);
        return re_executable_promise_1.default.fromFn(async () => {
            if (!testRun) {
                const err = new runtime_1.ClientFunctionAPIError(this.callsiteNames.execution, this.callsiteNames.instantiation, types_1.RUNTIME_ERRORS.clientFunctionCannotResolveTestRun);
                // NOTE: force callsite here, because more likely it will
                // be impossible to resolve it by method name from a lazy promise.
                err.callsite = callsite;
                throw err;
            }
            const result = await testRun.executeCommand(command, callsite);
            return this._processResult(result, args);
        });
    }
    _executeCommandSync(args, testRun, callsite) {
        // NOTE: should be kept outside of lazy promise to preserve
        // correct callsite in case of replicator error.
        const command = this.getCommand(args);
        if (!testRun) {
            const err = new runtime_1.ClientFunctionAPIError(this.callsiteNames.execution, this.callsiteNames.instantiation, types_1.RUNTIME_ERRORS.clientFunctionCannotResolveTestRun);
            // NOTE: force callsite here, because more likely it will
            // be impossible to resolve it by method name from a lazy promise.
            err.callsite = callsite;
            throw err;
        }
        // NOTE: reset the command timeout to minimal check interval to
        // ensure the find element loop will execute only one time.
        if (typeof command.timeout !== 'number')
            command.timeout = check_element_delay_1.default;
        try {
            const result = testRun.executeCommandSync(command, callsite);
            return this._processResult(result, args);
        }
        catch (err) {
            throw this._renderError(err);
        }
    }
    _processResult(result) {
        return this.replicator.decode(result);
    }
    _validateOptions(options) {
        type_assertions_1.assertType(type_assertions_1.is.nonNullObject, this.callsiteNames.instantiation, 'The "options" argument', options);
        if (!lodash_1.isNil(options.boundTestRun)) {
            // NOTE: `boundTestRun` can be either TestController or TestRun instance.
            const boundTestRun = options.boundTestRun.testRun || options.boundTestRun;
            if (!boundTestRun[marker_symbol_1.default])
                throw new runtime_1.APIError(this.callsiteNames.instantiation, types_1.RUNTIME_ERRORS.invalidClientFunctionTestRunBinding);
        }
        if (!lodash_1.isNil(options.dependencies))
            type_assertions_1.assertType(type_assertions_1.is.nonNullObject, this.callsiteNames.instantiation, 'The "dependencies" option', options.dependencies);
    }
    _getReplicatorTransforms() {
        return [
            new replicator_1.FunctionTransform(this.callsiteNames),
        ];
    }
}
exports.default = ClientFunctionBuilder;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpZW50LWZ1bmN0aW9uLWJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY2xpZW50LWZ1bmN0aW9ucy9jbGllbnQtZnVuY3Rpb24tYnVpbGRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLG1DQUE0RDtBQUM1RCwrRUFBcUQ7QUFDckQsc0VBQXFEO0FBQ3JELDZDQUFtRTtBQUNuRSxrRUFBZ0Y7QUFDaEYsa0dBQXdFO0FBQ3hFLCtDQUFxRTtBQUNyRSx1RUFBbUU7QUFDbkUsMkNBQWlEO0FBQ2pELHlEQUE4RDtBQUM5RCwyRkFBaUU7QUFDakUsOEVBQXNEO0FBQ3RELGdHQUFxRTtBQUNyRSxvSkFBNEg7QUFDNUgsNkVBQXFEO0FBQ3JELG9EQUE0QjtBQUU1QixNQUFNLCtCQUErQixHQUFHLHNCQUFzQixDQUFDO0FBRS9ELE1BQXFCLHFCQUFxQjtJQUN0QyxZQUFhLEVBQUUsRUFBRSxPQUFPLEVBQUUsYUFBYSxHQUFHLEVBQUU7UUFDeEMsSUFBSSxDQUFDLGFBQWEsR0FBRztZQUNqQixhQUFhLEVBQUUsYUFBYSxDQUFDLGFBQWE7WUFDMUMsU0FBUyxFQUFNLGFBQWEsQ0FBQyxTQUFTLElBQUksK0JBQStCO1NBQzVFLENBQUM7UUFFRixJQUFJLGNBQWlCLENBQUMsT0FBTyxDQUFDO1lBQzFCLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFFakIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRS9CLElBQUksQ0FBQyxFQUFFLEdBQWUsRUFBRSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxPQUFPLEdBQVUsT0FBTyxDQUFDO1FBQzlCLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFFaEQsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjO1lBQ3BCLE1BQU0sSUFBSSxDQUFDLHlCQUF5QixFQUFFLENBQUM7UUFFM0MsSUFBSSxDQUFDLFVBQVUsR0FBRyw2QkFBZ0IsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRCxZQUFZLENBQUUsS0FBSztRQUNmLGlGQUFpRjtRQUNqRixvQ0FBb0M7UUFDcEMsTUFBTSxhQUFhLEdBQUssTUFBTSxDQUFDLGdCQUFnQixDQUFDO1FBQ2hELE1BQU0sZUFBZSxHQUFHLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRSxhQUFhLENBQUMsQ0FBQztRQUVwRSxPQUFPLGdCQUFNLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVELGlCQUFpQixDQUFFLFFBQVE7UUFDdkIsUUFBUSxDQUFDLHdCQUFxQixDQUFDLEdBQUcsSUFBSSxDQUFDO1FBRXZDLFFBQVEsQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLEVBQUU7WUFDdEIsT0FBTyxJQUFJLENBQUMsaUNBQWlDLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDM0QsQ0FBQyxDQUFDO0lBQ04sQ0FBQztJQUVELGlDQUFpQyxDQUFFLE9BQU87UUFDdEMsSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRO1lBQzNCLE9BQU8sR0FBRyxlQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFFaEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFO1lBQ25ELGFBQWEsRUFBRSxNQUFNO1lBQ3JCLFNBQVMsRUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVM7U0FDOUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDakMsQ0FBQztJQUVELGVBQWU7UUFDWCx5RUFBeUU7UUFDekUsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVk7WUFDekIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUM7UUFFMUUsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELFdBQVc7UUFDUCxPQUFPLElBQUksQ0FBQyxlQUFlLEVBQUUsSUFBSSwwQkFBYyxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFDNUUsQ0FBQztJQUVELHFCQUFxQjs7UUFDakIsT0FBTyxPQUFBLElBQUksQ0FBQyxXQUFXLEVBQUUsMENBQUUsaUJBQWlCLEtBQUksSUFBSSxDQUFDO0lBQ3pELENBQUM7SUFFRCxXQUFXO1FBQ1AsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBRXJCLE1BQU0sUUFBUSxHQUFHLFNBQVMsb0JBQW9CO1lBQzFDLE1BQU0sT0FBTyxHQUFJLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUN2QyxNQUFNLFFBQVEsR0FBRyxtQ0FBb0IsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3ZFLE1BQU0sSUFBSSxHQUFPLEVBQUUsQ0FBQztZQUVwQiwrQ0FBK0M7WUFDL0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFO2dCQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRTVCLElBQUkscUNBQXdCLENBQUMsTUFBTTtnQkFDL0IsT0FBTyxPQUFPLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztZQUVoRSxPQUFPLE9BQU8sQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztRQUM1RCxDQUFDLENBQUM7UUFFRixJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFakMsT0FBTyxRQUFRLENBQUM7SUFDcEIsQ0FBQztJQUVELFVBQVUsQ0FBRSxJQUFJO1FBQ1osTUFBTSxXQUFXLEdBQVcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekQsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQyxDQUFDO1FBRW5GLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFHRCxzQkFBc0I7SUFDdEIsdUJBQXVCO1FBQ25CLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLElBQUksRUFBRSxDQUFDO0lBQzNDLENBQUM7SUFFRCxxQkFBcUIsQ0FBRSxXQUFXLEVBQUUsbUJBQW1CO1FBQ25ELE9BQU8sSUFBSSwwQ0FBNEIsQ0FBQztZQUNwQyx5QkFBeUIsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWE7WUFDM0QsTUFBTSxFQUFxQixJQUFJLENBQUMsY0FBYztZQUM5QyxJQUFJLEVBQXVCLFdBQVc7WUFDdEMsWUFBWSxFQUFlLG1CQUFtQjtTQUNqRCxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRCxrQkFBa0I7UUFDZCxJQUFJLE9BQU8sSUFBSSxDQUFDLEVBQUUsS0FBSyxVQUFVO1lBQzdCLE9BQU8saUNBQXFCLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRXBKLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCx5QkFBeUI7UUFDckIsT0FBTyxJQUFJLGdDQUFzQixDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxFQUFFLHNCQUFjLENBQUMsZ0NBQWdDLEVBQUUsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDM0ssQ0FBQztJQUVELGVBQWUsQ0FBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLFFBQVE7UUFDcEMsMkRBQTJEO1FBQzNELGdEQUFnRDtRQUNoRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXRDLE9BQU8sK0JBQW1CLENBQUMsTUFBTSxDQUFDLEtBQUssSUFBSSxFQUFFO1lBQ3pDLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ1YsTUFBTSxHQUFHLEdBQUcsSUFBSSxnQ0FBc0IsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsRUFBRSxzQkFBYyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7Z0JBRTFKLHlEQUF5RDtnQkFDekQsa0VBQWtFO2dCQUNsRSxHQUFHLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztnQkFFeEIsTUFBTSxHQUFHLENBQUM7YUFDYjtZQUVELE1BQU0sTUFBTSxHQUFHLE1BQU0sT0FBTyxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFFL0QsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM3QyxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRCxtQkFBbUIsQ0FBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLFFBQVE7UUFDeEMsMkRBQTJEO1FBQzNELGdEQUFnRDtRQUNoRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXRDLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDVixNQUFNLEdBQUcsR0FBRyxJQUFJLGdDQUFzQixDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxFQUFFLHNCQUFjLENBQUMsa0NBQWtDLENBQUMsQ0FBQztZQUUxSix5REFBeUQ7WUFDekQsa0VBQWtFO1lBQ2xFLEdBQUcsQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1lBRXhCLE1BQU0sR0FBRyxDQUFDO1NBQ2I7UUFFRCwrREFBK0Q7UUFDL0QsMkRBQTJEO1FBQzNELElBQUksT0FBTyxPQUFPLENBQUMsT0FBTyxLQUFLLFFBQVE7WUFDbkMsT0FBTyxDQUFDLE9BQU8sR0FBRyw2QkFBbUIsQ0FBQztRQUUxQyxJQUFJO1lBQ0EsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztZQUU3RCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzVDO1FBQ0QsT0FBTyxHQUFHLEVBQUU7WUFDUixNQUFNLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDaEM7SUFDTCxDQUFDO0lBRUQsY0FBYyxDQUFFLE1BQU07UUFDbEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQsZ0JBQWdCLENBQUUsT0FBTztRQUNyQiw0QkFBVSxDQUFDLG9CQUFFLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxFQUFFLHdCQUF3QixFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRWxHLElBQUksQ0FBQyxjQUFpQixDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsRUFBRTtZQUMxQyx5RUFBeUU7WUFDekUsTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLFlBQVksQ0FBQztZQUUxRSxJQUFJLENBQUMsWUFBWSxDQUFDLHVCQUFhLENBQUM7Z0JBQzVCLE1BQU0sSUFBSSxrQkFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxFQUFFLHNCQUFjLENBQUMsbUNBQW1DLENBQUMsQ0FBQztTQUNoSDtRQUVELElBQUksQ0FBQyxjQUFpQixDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUM7WUFDeEMsNEJBQVUsQ0FBQyxvQkFBRSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsRUFBRSwyQkFBMkIsRUFBRSxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDMUgsQ0FBQztJQUVELHdCQUF3QjtRQUNwQixPQUFPO1lBQ0gsSUFBSSw4QkFBaUIsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDO1NBQzVDLENBQUM7SUFDTixDQUFDO0NBQ0o7QUF2TUQsd0NBdU1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNOaWwgYXMgaXNOdWxsT3JVbmRlZmluZWQsIGFzc2lnbiB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgdGVzdFJ1blRyYWNrZXIgZnJvbSAnLi4vYXBpL3Rlc3QtcnVuLXRyYWNrZXInO1xuaW1wb3J0IGZ1bmN0aW9uQnVpbGRlclN5bWJvbCBmcm9tICcuL2J1aWxkZXItc3ltYm9sJztcbmltcG9ydCB7IGNyZWF0ZVJlcGxpY2F0b3IsIEZ1bmN0aW9uVHJhbnNmb3JtIH0gZnJvbSAnLi9yZXBsaWNhdG9yJztcbmltcG9ydCB7IEV4ZWN1dGVDbGllbnRGdW5jdGlvbkNvbW1hbmQgfSBmcm9tICcuLi90ZXN0LXJ1bi9jb21tYW5kcy9vYnNlcnZhdGlvbic7XG5pbXBvcnQgY29tcGlsZUNsaWVudEZ1bmN0aW9uIGZyb20gJy4uL2NvbXBpbGVyL2NvbXBpbGUtY2xpZW50LWZ1bmN0aW9uJztcbmltcG9ydCB7IEFQSUVycm9yLCBDbGllbnRGdW5jdGlvbkFQSUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3J1bnRpbWUnO1xuaW1wb3J0IHsgYXNzZXJ0VHlwZSwgaXMgfSBmcm9tICcuLi9lcnJvcnMvcnVudGltZS90eXBlLWFzc2VydGlvbnMnO1xuaW1wb3J0IHsgUlVOVElNRV9FUlJPUlMgfSBmcm9tICcuLi9lcnJvcnMvdHlwZXMnO1xuaW1wb3J0IHsgZ2V0Q2FsbHNpdGVGb3JNZXRob2QgfSBmcm9tICcuLi9lcnJvcnMvZ2V0LWNhbGxzaXRlJztcbmltcG9ydCBSZUV4ZWN1dGFibGVQcm9taXNlIGZyb20gJy4uL3V0aWxzL3JlLWV4ZWN1dGFibGUtcHJvbWlzZSc7XG5pbXBvcnQgdGVzdFJ1bk1hcmtlciBmcm9tICcuLi90ZXN0LXJ1bi9tYXJrZXItc3ltYm9sJztcbmltcG9ydCBzZWxlY3RvckFwaUV4ZWN1dGlvbk1vZGUgZnJvbSAnLi9zZWxlY3Rvci1hcGktZXhlY3V0aW9uLW1vZGUnO1xuaW1wb3J0IENIRUNLX0VMRU1FTlRfREVMQVkgZnJvbSAnLi4vY2xpZW50L2RyaXZlci9jb21tYW5kLWV4ZWN1dG9ycy9jbGllbnQtZnVuY3Rpb25zL3NlbGVjdG9yLWV4ZWN1dG9yL2NoZWNrLWVsZW1lbnQtZGVsYXknO1xuaW1wb3J0IFRFTVBMQVRFUyBmcm9tICcuLi9lcnJvcnMvdGVzdC1ydW4vdGVtcGxhdGVzJztcbmltcG9ydCBkZWRlbnQgZnJvbSAnZGVkZW50JztcblxuY29uc3QgREVGQVVMVF9FWEVDVVRJT05fQ0FMTFNJVEVfTkFNRSA9ICdfXyQkY2xpZW50RnVuY3Rpb24kJCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsaWVudEZ1bmN0aW9uQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IgKGZuLCBvcHRpb25zLCBjYWxsc2l0ZU5hbWVzID0ge30pIHtcbiAgICAgICAgdGhpcy5jYWxsc2l0ZU5hbWVzID0ge1xuICAgICAgICAgICAgaW5zdGFudGlhdGlvbjogY2FsbHNpdGVOYW1lcy5pbnN0YW50aWF0aW9uLFxuICAgICAgICAgICAgZXhlY3V0aW9uOiAgICAgY2FsbHNpdGVOYW1lcy5leGVjdXRpb24gfHwgREVGQVVMVF9FWEVDVVRJT05fQ0FMTFNJVEVfTkFNRSxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQob3B0aW9ucykpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG5cbiAgICAgICAgdGhpcy5fdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuZm4gICAgICAgICAgICAgPSBmbjtcbiAgICAgICAgdGhpcy5vcHRpb25zICAgICAgICA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29tcGlsZWRGbkNvZGUgPSB0aGlzLl9nZXRDb21waWxlZEZuQ29kZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5jb21waWxlZEZuQ29kZSlcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUludmFsaWRGblR5cGVFcnJvcigpO1xuXG4gICAgICAgIHRoaXMucmVwbGljYXRvciA9IGNyZWF0ZVJlcGxpY2F0b3IodGhpcy5fZ2V0UmVwbGljYXRvclRyYW5zZm9ybXMoKSk7XG4gICAgfVxuXG4gICAgX3JlbmRlckVycm9yIChlcnJvcikge1xuICAgICAgICAvLyBUaGUgcmVuZGVyZWQgdGVtcGxhdGUgaXMgc2hvd24gaW4gdGhlIFdhdGNoIHBhbmVsIG9mIGJyb3dzZXIgZGV2IHRvb2xzIG9yIElERS5cbiAgICAgICAgLy8gVmlld3BvcnQgc2l6ZSBpcyB1bmxpbWl0ZWQgdGhlcmUuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0V2lkdGggICA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICBjb25zdCByZW5kZXJlZE1lc3NhZ2UgPSBURU1QTEFURVNbZXJyb3IuY29kZV0oZXJyb3IsIHZpZXdwb3J0V2lkdGgpO1xuXG4gICAgICAgIHJldHVybiBkZWRlbnQocmVuZGVyZWRNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBfZGVjb3JhdGVGdW5jdGlvbiAoY2xpZW50Rm4pIHtcbiAgICAgICAgY2xpZW50Rm5bZnVuY3Rpb25CdWlsZGVyU3ltYm9sXSA9IHRoaXM7XG5cbiAgICAgICAgY2xpZW50Rm4ud2l0aCA9IG9wdGlvbnMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENsaWVudEZuV2l0aE92ZXJyaWRkZW5PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9nZXRDbGllbnRGbldpdGhPdmVycmlkZGVuT3B0aW9ucyAob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgb3B0aW9ucyA9IGFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICBjb25zdCBidWlsZGVyID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5mbiwgb3B0aW9ucywge1xuICAgICAgICAgICAgaW5zdGFudGlhdGlvbjogJ3dpdGgnLFxuICAgICAgICAgICAgZXhlY3V0aW9uOiAgICAgdGhpcy5jYWxsc2l0ZU5hbWVzLmV4ZWN1dGlvbixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZ2V0RnVuY3Rpb24oKTtcbiAgICB9XG5cbiAgICBnZXRCb3VuZFRlc3RSdW4gKCkge1xuICAgICAgICAvLyBOT1RFOiBgYm91bmRUZXN0UnVuYCBjYW4gYmUgZWl0aGVyIFRlc3RDb250cm9sbGVyIG9yIFRlc3RSdW4gaW5zdGFuY2UuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRUZXN0UnVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib3VuZFRlc3RSdW4udGVzdFJ1biB8fCB0aGlzLm9wdGlvbnMuYm91bmRUZXN0UnVuO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9nZXRUZXN0UnVuICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRUZXN0UnVuKCkgfHwgdGVzdFJ1blRyYWNrZXIucmVzb2x2ZUNvbnRleHRUZXN0UnVuKCk7XG4gICAgfVxuXG4gICAgX2dldE9ic2VydmVkQ2FsbHNpdGVzICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRlc3RSdW4oKT8ub2JzZXJ2ZWRDYWxsc2l0ZXMgfHwgbnVsbDtcbiAgICB9XG5cbiAgICBnZXRGdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IGNsaWVudEZuID0gZnVuY3Rpb24gX18kJGNsaWVudEZ1bmN0aW9uJCQgKCkge1xuICAgICAgICAgICAgY29uc3QgdGVzdFJ1biAgPSBidWlsZGVyLl9nZXRUZXN0UnVuKCk7XG4gICAgICAgICAgICBjb25zdCBjYWxsc2l0ZSA9IGdldENhbGxzaXRlRm9yTWV0aG9kKGJ1aWxkZXIuY2FsbHNpdGVOYW1lcy5leGVjdXRpb24pO1xuICAgICAgICAgICAgY29uc3QgYXJncyAgICAgPSBbXTtcblxuICAgICAgICAgICAgLy8gT1BUSU1JWkFUSU9OOiBkb24ndCBsZWFrIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3JBcGlFeGVjdXRpb25Nb2RlLmlzU3luYylcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRlci5fZXhlY3V0ZUNvbW1hbmRTeW5jKGFyZ3MsIHRlc3RSdW4sIGNhbGxzaXRlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXIuX2V4ZWN1dGVDb21tYW5kKGFyZ3MsIHRlc3RSdW4sIGNhbGxzaXRlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9kZWNvcmF0ZUZ1bmN0aW9uKGNsaWVudEZuKTtcblxuICAgICAgICByZXR1cm4gY2xpZW50Rm47XG4gICAgfVxuXG4gICAgZ2V0Q29tbWFuZCAoYXJncykge1xuICAgICAgICBjb25zdCBlbmNvZGVkQXJncyAgICAgICAgID0gdGhpcy5yZXBsaWNhdG9yLmVuY29kZShhcmdzKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZERlcGVuZGVuY2llcyA9IHRoaXMucmVwbGljYXRvci5lbmNvZGUodGhpcy5nZXRGdW5jdGlvbkRlcGVuZGVuY2llcygpKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlVGVzdFJ1bkNvbW1hbmQoZW5jb2RlZEFyZ3MsIGVuY29kZWREZXBlbmRlbmNpZXMpO1xuICAgIH1cblxuXG4gICAgLy8gT3ZlcnJpZGFibGUgbWV0aG9kc1xuICAgIGdldEZ1bmN0aW9uRGVwZW5kZW5jaWVzICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kZXBlbmRlbmNpZXMgfHwge307XG4gICAgfVxuXG4gICAgX2NyZWF0ZVRlc3RSdW5Db21tYW5kIChlbmNvZGVkQXJncywgZW5jb2RlZERlcGVuZGVuY2llcykge1xuICAgICAgICByZXR1cm4gbmV3IEV4ZWN1dGVDbGllbnRGdW5jdGlvbkNvbW1hbmQoe1xuICAgICAgICAgICAgaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZTogdGhpcy5jYWxsc2l0ZU5hbWVzLmluc3RhbnRpYXRpb24sXG4gICAgICAgICAgICBmbkNvZGU6ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVkRm5Db2RlLFxuICAgICAgICAgICAgYXJnczogICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZEFyZ3MsXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXM6ICAgICAgICAgICAgICBlbmNvZGVkRGVwZW5kZW5jaWVzLFxuICAgICAgICB9LCB0aGlzLl9nZXRUZXN0UnVuKCkpO1xuICAgIH1cblxuICAgIF9nZXRDb21waWxlZEZuQ29kZSAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5mbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiBjb21waWxlQ2xpZW50RnVuY3Rpb24odGhpcy5mbi50b1N0cmluZygpLCB0aGlzLm9wdGlvbnMuZGVwZW5kZW5jaWVzLCB0aGlzLmNhbGxzaXRlTmFtZXMuaW5zdGFudGlhdGlvbiwgdGhpcy5jYWxsc2l0ZU5hbWVzLmluc3RhbnRpYXRpb24pO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9jcmVhdGVJbnZhbGlkRm5UeXBlRXJyb3IgKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsaWVudEZ1bmN0aW9uQVBJRXJyb3IodGhpcy5jYWxsc2l0ZU5hbWVzLmluc3RhbnRpYXRpb24sIHRoaXMuY2FsbHNpdGVOYW1lcy5pbnN0YW50aWF0aW9uLCBSVU5USU1FX0VSUk9SUy5jbGllbnRGdW5jdGlvbkNvZGVJc05vdEFGdW5jdGlvbiwgdHlwZW9mIHRoaXMuZm4pO1xuICAgIH1cblxuICAgIF9leGVjdXRlQ29tbWFuZCAoYXJncywgdGVzdFJ1biwgY2FsbHNpdGUpIHtcbiAgICAgICAgLy8gTk9URTogc2hvdWxkIGJlIGtlcHQgb3V0c2lkZSBvZiBsYXp5IHByb21pc2UgdG8gcHJlc2VydmVcbiAgICAgICAgLy8gY29ycmVjdCBjYWxsc2l0ZSBpbiBjYXNlIG9mIHJlcGxpY2F0b3IgZXJyb3IuXG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSB0aGlzLmdldENvbW1hbmQoYXJncyk7XG5cbiAgICAgICAgcmV0dXJuIFJlRXhlY3V0YWJsZVByb21pc2UuZnJvbUZuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGVzdFJ1bikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBDbGllbnRGdW5jdGlvbkFQSUVycm9yKHRoaXMuY2FsbHNpdGVOYW1lcy5leGVjdXRpb24sIHRoaXMuY2FsbHNpdGVOYW1lcy5pbnN0YW50aWF0aW9uLCBSVU5USU1FX0VSUk9SUy5jbGllbnRGdW5jdGlvbkNhbm5vdFJlc29sdmVUZXN0UnVuKTtcblxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGZvcmNlIGNhbGxzaXRlIGhlcmUsIGJlY2F1c2UgbW9yZSBsaWtlbHkgaXQgd2lsbFxuICAgICAgICAgICAgICAgIC8vIGJlIGltcG9zc2libGUgdG8gcmVzb2x2ZSBpdCBieSBtZXRob2QgbmFtZSBmcm9tIGEgbGF6eSBwcm9taXNlLlxuICAgICAgICAgICAgICAgIGVyci5jYWxsc2l0ZSA9IGNhbGxzaXRlO1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZXN0UnVuLmV4ZWN1dGVDb21tYW5kKGNvbW1hbmQsIGNhbGxzaXRlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NSZXN1bHQocmVzdWx0LCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2V4ZWN1dGVDb21tYW5kU3luYyAoYXJncywgdGVzdFJ1biwgY2FsbHNpdGUpIHtcbiAgICAgICAgLy8gTk9URTogc2hvdWxkIGJlIGtlcHQgb3V0c2lkZSBvZiBsYXp5IHByb21pc2UgdG8gcHJlc2VydmVcbiAgICAgICAgLy8gY29ycmVjdCBjYWxsc2l0ZSBpbiBjYXNlIG9mIHJlcGxpY2F0b3IgZXJyb3IuXG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSB0aGlzLmdldENvbW1hbmQoYXJncyk7XG5cbiAgICAgICAgaWYgKCF0ZXN0UnVuKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgQ2xpZW50RnVuY3Rpb25BUElFcnJvcih0aGlzLmNhbGxzaXRlTmFtZXMuZXhlY3V0aW9uLCB0aGlzLmNhbGxzaXRlTmFtZXMuaW5zdGFudGlhdGlvbiwgUlVOVElNRV9FUlJPUlMuY2xpZW50RnVuY3Rpb25DYW5ub3RSZXNvbHZlVGVzdFJ1bik7XG5cbiAgICAgICAgICAgIC8vIE5PVEU6IGZvcmNlIGNhbGxzaXRlIGhlcmUsIGJlY2F1c2UgbW9yZSBsaWtlbHkgaXQgd2lsbFxuICAgICAgICAgICAgLy8gYmUgaW1wb3NzaWJsZSB0byByZXNvbHZlIGl0IGJ5IG1ldGhvZCBuYW1lIGZyb20gYSBsYXp5IHByb21pc2UuXG4gICAgICAgICAgICBlcnIuY2FsbHNpdGUgPSBjYWxsc2l0ZTtcblxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTk9URTogcmVzZXQgdGhlIGNvbW1hbmQgdGltZW91dCB0byBtaW5pbWFsIGNoZWNrIGludGVydmFsIHRvXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgZmluZCBlbGVtZW50IGxvb3Agd2lsbCBleGVjdXRlIG9ubHkgb25lIHRpbWUuXG4gICAgICAgIGlmICh0eXBlb2YgY29tbWFuZC50aW1lb3V0ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIGNvbW1hbmQudGltZW91dCA9IENIRUNLX0VMRU1FTlRfREVMQVk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRlc3RSdW4uZXhlY3V0ZUNvbW1hbmRTeW5jKGNvbW1hbmQsIGNhbGxzaXRlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NSZXN1bHQocmVzdWx0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9yZW5kZXJFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3Byb2Nlc3NSZXN1bHQgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsaWNhdG9yLmRlY29kZShyZXN1bHQpO1xuICAgIH1cblxuICAgIF92YWxpZGF0ZU9wdGlvbnMgKG9wdGlvbnMpIHtcbiAgICAgICAgYXNzZXJ0VHlwZShpcy5ub25OdWxsT2JqZWN0LCB0aGlzLmNhbGxzaXRlTmFtZXMuaW5zdGFudGlhdGlvbiwgJ1RoZSBcIm9wdGlvbnNcIiBhcmd1bWVudCcsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQob3B0aW9ucy5ib3VuZFRlc3RSdW4pKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBgYm91bmRUZXN0UnVuYCBjYW4gYmUgZWl0aGVyIFRlc3RDb250cm9sbGVyIG9yIFRlc3RSdW4gaW5zdGFuY2UuXG4gICAgICAgICAgICBjb25zdCBib3VuZFRlc3RSdW4gPSBvcHRpb25zLmJvdW5kVGVzdFJ1bi50ZXN0UnVuIHx8IG9wdGlvbnMuYm91bmRUZXN0UnVuO1xuXG4gICAgICAgICAgICBpZiAoIWJvdW5kVGVzdFJ1blt0ZXN0UnVuTWFya2VyXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQVBJRXJyb3IodGhpcy5jYWxsc2l0ZU5hbWVzLmluc3RhbnRpYXRpb24sIFJVTlRJTUVfRVJST1JTLmludmFsaWRDbGllbnRGdW5jdGlvblRlc3RSdW5CaW5kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQob3B0aW9ucy5kZXBlbmRlbmNpZXMpKVxuICAgICAgICAgICAgYXNzZXJ0VHlwZShpcy5ub25OdWxsT2JqZWN0LCB0aGlzLmNhbGxzaXRlTmFtZXMuaW5zdGFudGlhdGlvbiwgJ1RoZSBcImRlcGVuZGVuY2llc1wiIG9wdGlvbicsIG9wdGlvbnMuZGVwZW5kZW5jaWVzKTtcbiAgICB9XG5cbiAgICBfZ2V0UmVwbGljYXRvclRyYW5zZm9ybXMgKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IEZ1bmN0aW9uVHJhbnNmb3JtKHRoaXMuY2FsbHNpdGVOYW1lcyksXG4gICAgICAgIF07XG4gICAgfVxufVxuIl19