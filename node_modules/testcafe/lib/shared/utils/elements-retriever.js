"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const adapter_1 = require("../adapter");
const node_type_descriptions_1 = __importDefault(require("../utils/node-type-descriptions"));
const errors_1 = require("../../shared/errors");
class ElementsRetriever {
    constructor(globalSelectorTimeout, executeSelectorFn) {
        this._globalSelectorTimeout = globalSelectorTimeout;
        this._ensureElementsStartTime = adapter_1.adapter.nativeMethods.dateNow();
        this._ensureElementsPromise = adapter_1.adapter.PromiseCtor.resolve();
        this._executeSelectorFn = executeSelectorFn;
        this._elements = [];
    }
    push(selector, elementName) {
        this._ensureElementsPromise = this._ensureElementsPromise
            .then(() => {
            return this._executeSelectorFn(selector, {
                invisible: !elementName ? 'ActionElementIsInvisibleError' : {
                    name: 'ActionAdditionalElementIsInvisibleError',
                    firstArg: elementName,
                },
                notFound: !elementName ? 'ActionElementNotFoundError' : {
                    name: 'ActionAdditionalElementNotFoundError',
                    firstArg: elementName,
                },
            }, this._ensureElementsStartTime);
        })
            .then(el => {
            if (!adapter_1.adapter.dom.isDomElement(el)) {
                const nodeType = el.nodeType;
                const nodeTypeStr = node_type_descriptions_1.default[nodeType];
                if (!elementName)
                    throw new errors_1.ActionSelectorMatchesWrongNodeTypeError(nodeTypeStr);
                else
                    throw new errors_1.ActionAdditionalSelectorMatchesWrongNodeTypeError(elementName, nodeTypeStr);
            }
            this._elements.push(el);
        });
    }
    getElements() {
        return this._ensureElementsPromise.then(() => this._elements);
    }
}
exports.default = ElementsRetriever;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxlbWVudHMtcmV0cmlldmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3NoYXJlZC91dGlscy9lbGVtZW50cy1yZXRyaWV2ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSx3Q0FBcUM7QUFHckMsNkZBQXFFO0FBQ3JFLGdEQUc2QjtBQUc3QixNQUFxQixpQkFBaUI7SUFPbEMsWUFBb0IscUJBQTZCLEVBQUUsaUJBQXVDO1FBQ3RGLElBQUksQ0FBQyxzQkFBc0IsR0FBSyxxQkFBcUIsQ0FBQztRQUN0RCxJQUFJLENBQUMsd0JBQXdCLEdBQUcsaUJBQU8sQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDaEUsSUFBSSxDQUFDLHNCQUFzQixHQUFLLGlCQUFPLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzlELElBQUksQ0FBQyxrQkFBa0IsR0FBUyxpQkFBaUIsQ0FBQztRQUNsRCxJQUFJLENBQUMsU0FBUyxHQUFrQixFQUFFLENBQUM7SUFDdkMsQ0FBQztJQUVNLElBQUksQ0FBRSxRQUFnQyxFQUFFLFdBQW9CO1FBQy9ELElBQUksQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLENBQUMsc0JBQXNCO2FBQ3BELElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDUCxPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUU7Z0JBQ3JDLFNBQVMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsK0JBQStCLENBQUMsQ0FBQyxDQUFDO29CQUN4RCxJQUFJLEVBQU0seUNBQXlDO29CQUNuRCxRQUFRLEVBQUUsV0FBVztpQkFDeEI7Z0JBQ0QsUUFBUSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLENBQUM7b0JBQ3BELElBQUksRUFBTSxzQ0FBc0M7b0JBQ2hELFFBQVEsRUFBRSxXQUFXO2lCQUN4QjthQUNKLEVBQUUsSUFBSSxDQUFDLHdCQUF3QixDQUFDLENBQUM7UUFDdEMsQ0FBQyxDQUFDO2FBQ0QsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQ1AsSUFBSSxDQUFDLGlCQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDL0IsTUFBTSxRQUFRLEdBQU8sRUFBc0MsQ0FBQyxRQUFRLENBQUM7Z0JBQ3JFLE1BQU0sV0FBVyxHQUFHLGdDQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUVyRCxJQUFJLENBQUMsV0FBVztvQkFDWixNQUFNLElBQUksZ0RBQXVDLENBQUMsV0FBVyxDQUFDLENBQUM7O29CQUUvRCxNQUFNLElBQUksMERBQWlELENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxDQUFDO2FBQzdGO1lBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDNUIsQ0FBQyxDQUFDLENBQUM7SUFFWCxDQUFDO0lBRU0sV0FBVztRQUNkLE9BQU8sSUFBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbEUsQ0FBQztDQUNKO0FBaERELG9DQWdEQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFkYXB0ZXIgfSBmcm9tICcuLi9hZGFwdGVyJztcbmltcG9ydCB7IEV4ZWN1dGVTZWxlY3RvckNvbW1hbmQgfSBmcm9tICcuLi8uLi90ZXN0LXJ1bi9jb21tYW5kcy9vYnNlcnZhdGlvbic7XG5pbXBvcnQgeyBFeGVjdXRlU2VsZWN0b3JGbiB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBOT0RFX1RZUEVfREVTQ1JJUFRJT05TIGZyb20gJy4uL3V0aWxzL25vZGUtdHlwZS1kZXNjcmlwdGlvbnMnO1xuaW1wb3J0IHtcbiAgICBBY3Rpb25TZWxlY3Rvck1hdGNoZXNXcm9uZ05vZGVUeXBlRXJyb3IsXG4gICAgQWN0aW9uQWRkaXRpb25hbFNlbGVjdG9yTWF0Y2hlc1dyb25nTm9kZVR5cGVFcnJvcixcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2Vycm9ycyc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudHNSZXRyaWV2ZXI8VD4ge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2dsb2JhbFNlbGVjdG9yVGltZW91dDogbnVtYmVyO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2Vuc3VyZUVsZW1lbnRzU3RhcnRUaW1lOiBudW1iZXI7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfZXhlY3V0ZVNlbGVjdG9yRm46IEV4ZWN1dGVTZWxlY3RvckZuPFQ+O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2VsZW1lbnRzOiBUW107XG4gICAgcHJpdmF0ZSBfZW5zdXJlRWxlbWVudHNQcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yIChnbG9iYWxTZWxlY3RvclRpbWVvdXQ6IG51bWJlciwgZXhlY3V0ZVNlbGVjdG9yRm46IEV4ZWN1dGVTZWxlY3RvckZuPFQ+KSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbFNlbGVjdG9yVGltZW91dCAgID0gZ2xvYmFsU2VsZWN0b3JUaW1lb3V0O1xuICAgICAgICB0aGlzLl9lbnN1cmVFbGVtZW50c1N0YXJ0VGltZSA9IGFkYXB0ZXIubmF0aXZlTWV0aG9kcy5kYXRlTm93KCk7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUVsZW1lbnRzUHJvbWlzZSAgID0gYWRhcHRlci5Qcm9taXNlQ3Rvci5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuX2V4ZWN1dGVTZWxlY3RvckZuICAgICAgID0gZXhlY3V0ZVNlbGVjdG9yRm47XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzICAgICAgICAgICAgICAgID0gW107XG4gICAgfVxuXG4gICAgcHVibGljIHB1c2ggKHNlbGVjdG9yOiBFeGVjdXRlU2VsZWN0b3JDb21tYW5kLCBlbGVtZW50TmFtZT86IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLl9lbnN1cmVFbGVtZW50c1Byb21pc2UgPSB0aGlzLl9lbnN1cmVFbGVtZW50c1Byb21pc2VcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhlY3V0ZVNlbGVjdG9yRm4oc2VsZWN0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgaW52aXNpYmxlOiAhZWxlbWVudE5hbWUgPyAnQWN0aW9uRWxlbWVudElzSW52aXNpYmxlRXJyb3InIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogICAgICdBY3Rpb25BZGRpdGlvbmFsRWxlbWVudElzSW52aXNpYmxlRXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RBcmc6IGVsZW1lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogIWVsZW1lbnROYW1lID8gJ0FjdGlvbkVsZW1lbnROb3RGb3VuZEVycm9yJyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICAgICAnQWN0aW9uQWRkaXRpb25hbEVsZW1lbnROb3RGb3VuZEVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0QXJnOiBlbGVtZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LCB0aGlzLl9lbnN1cmVFbGVtZW50c1N0YXJ0VGltZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZWwgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghYWRhcHRlci5kb20uaXNEb21FbGVtZW50KGVsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlVHlwZSAgICA9IChlbCBhcyB1bmtub3duIGFzIHsgbm9kZVR5cGU6IG51bWJlciB9KS5ub2RlVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZVR5cGVTdHIgPSBOT0RFX1RZUEVfREVTQ1JJUFRJT05TW25vZGVUeXBlXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnROYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFjdGlvblNlbGVjdG9yTWF0Y2hlc1dyb25nTm9kZVR5cGVFcnJvcihub2RlVHlwZVN0cik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBY3Rpb25BZGRpdGlvbmFsU2VsZWN0b3JNYXRjaGVzV3JvbmdOb2RlVHlwZUVycm9yKGVsZW1lbnROYW1lLCBub2RlVHlwZVN0cik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRFbGVtZW50cyAoKTogUHJvbWlzZTxUW10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vuc3VyZUVsZW1lbnRzUHJvbWlzZS50aGVuKCgpID0+IHRoaXMuX2VsZW1lbnRzKTtcbiAgICB9XG59XG4iXX0=