"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const adapter_1 = require("../../adapter");
const next_tick_1 = __importDefault(require("../../utils/next-tick"));
const settings_1 = __importDefault(require("./settings"));
const options_1 = require("../../../test-run/commands/options");
const last_hovered_element_holder_1 = __importDefault(require("./last-hovered-element-holder"));
const MOVE_REQUEST_CMD = 'automation|move|request';
const MOVE_RESPONSE_CMD = 'automation|move|response';
const get_automation_point_1 = __importDefault(require("../utils/get-automation-point"));
const axis_values_1 = __importDefault(require("../../utils/values/axis-values"));
const promise_1 = require("../../utils/promise");
const get_device_point_1 = __importDefault(require("../utils/get-device-point"));
class MoveAutomation {
    constructor(el, offset, moveOptions, win, cursor) {
        this.touchMode = adapter_1.adapter.featureDetection.isTouchDevice;
        this.moveEvent = this.touchMode ? 'touchmove' : 'mousemove';
        this.automationSettings = new settings_1.default(moveOptions.speed);
        this.cursorSpeed = this._getCursorSpeed();
        this.element = el;
        this.window = win;
        this.offset = offset;
        this.cursor = cursor;
        this.minMovingTime = moveOptions.minMovingTime || 0;
        this.modifiers = moveOptions.modifiers || {};
        this.skipScrolling = moveOptions.skipScrolling;
        this.skipDefaultDragBehavior = moveOptions.skipDefaultDragBehavior;
        this.speed = moveOptions.speed;
        this.firstMovingStepOccured = false;
    }
    static async create(el, moveOptions, win, cursor) {
        const { element, offset } = await MoveAutomation.getTarget(el, win, new axis_values_1.default(moveOptions.offsetX, moveOptions.offsetY));
        return new MoveAutomation(element, offset, moveOptions, win, cursor);
    }
    static getTarget(element, window, offset) {
        // NOTE: if the target point (considering offsets) is out of
        // the element change the target element to the document element
        return adapter_1.adapter.PromiseCtor.resolve(adapter_1.adapter.position.containsOffset(element, offset.x, offset.y))
            .then(containsOffset => {
            if (!containsOffset) {
                return Promise.all([
                    get_automation_point_1.default(element, offset),
                    adapter_1.adapter.dom.getDocumentElement(window),
                ])
                    .then(([point, docEl]) => ({ element: docEl, offset: point }));
            }
            return { element, offset };
        });
    }
    _getCursorSpeed() {
        return this.automationSettings.cursorSpeed;
    }
    _getTargetClientPoint() {
        return adapter_1.adapter.PromiseCtor.resolve(adapter_1.adapter.style.getElementScroll(this.element))
            .then(scroll => {
            if (adapter_1.adapter.dom.isHtmlElement(this.element)) {
                return axis_values_1.default.create(this.offset)
                    .sub(axis_values_1.default.create(scroll))
                    .round(Math.round);
            }
            return adapter_1.adapter.PromiseCtor.resolve(adapter_1.adapter.position.getClientPosition(this.element))
                .then(clientPosition => {
                const isDocumentBody = adapter_1.adapter.dom.isBodyElement(this.element);
                const clientPoint = axis_values_1.default.create(clientPosition).add(this.offset);
                if (!isDocumentBody)
                    clientPoint.sub(axis_values_1.default.create(scroll));
                return clientPoint.round(Math.floor);
            });
        });
    }
    _getEventSequenceOptions(currPosition) {
        const button = adapter_1.adapter.event.BUTTONS_PARAMETER.noButton;
        return get_device_point_1.default(currPosition)
            .then(devicePoint => {
            const eventOptions = {
                clientX: currPosition.x,
                clientY: currPosition.y,
                screenX: devicePoint === null || devicePoint === void 0 ? void 0 : devicePoint.x,
                screenY: devicePoint === null || devicePoint === void 0 ? void 0 : devicePoint.y,
                buttons: button,
                ctrl: this.modifiers.ctrl,
                alt: this.modifiers.alt,
                shift: this.modifiers.shift,
                meta: this.modifiers.meta,
            };
            return { eventOptions, eventSequenceOptions: { moveEvent: this.moveEvent } };
        });
    }
    async _runEventSequence(currentElement, { eventOptions, eventSequenceOptions }) {
        const eventSequence = await adapter_1.adapter.createEventSequence(false, this.firstMovingStepOccured, eventSequenceOptions);
        return eventSequence.run(currentElement, last_hovered_element_holder_1.default.get(), eventOptions, null, null);
    }
    _emulateEvents(currentElement, currPosition) {
        return this._getEventSequenceOptions(currPosition)
            .then(options => {
            return this._runEventSequence(currentElement, options);
        })
            .then(() => {
            this.firstMovingStepOccured = true;
            last_hovered_element_holder_1.default.set(currentElement);
        });
    }
    _movingStep(currPosition) {
        return this.cursor.move(currPosition)
            .then(() => adapter_1.adapter.getElementExceptUI(this.cursor.getPosition()))
            // NOTE: in touch mode, events are simulated for the element for which mousedown was simulated (GH-372)
            .then(topElement => {
            const currentElement = this._getCorrectedTopElement(topElement);
            // NOTE: it can be null in IE
            if (!currentElement)
                return null;
            return this._emulateEvents(currentElement, currPosition);
        })
            .then(next_tick_1.default);
    }
    _getCorrectedTopElement(topElement) {
        return topElement;
    }
    _move(endPoint) {
        const startPoint = this.cursor.getPosition();
        const distance = axis_values_1.default.create(endPoint).sub(startPoint);
        const startTime = adapter_1.adapter.nativeMethods.dateNow();
        const movingTime = Math.max(Math.max(Math.abs(distance.x), Math.abs(distance.y)) / this.cursorSpeed, this.minMovingTime);
        let currPosition = axis_values_1.default.create(startPoint);
        let isFirstStep = true;
        return promise_1.whilst(() => !currPosition.eql(endPoint), () => {
            if (this._needMoveCursorImmediately())
                currPosition = axis_values_1.default.create(endPoint);
            else if (isFirstStep) {
                isFirstStep = false;
                // NOTE: the mousemove event can't be simulated at the point where the cursor
                // was located at the start. Therefore, we add a minimal distance 1 px.
                currPosition.add({
                    x: distance.x > 0 ? 1 : -1,
                    y: distance.y > 0 ? 1 : -1,
                });
            }
            else {
                const progress = Math.min((adapter_1.adapter.nativeMethods.dateNow() - startTime) / movingTime, 1);
                currPosition = axis_values_1.default.create(distance).mul(progress).add(startPoint).round(Math.floor);
            }
            return this._movingStep(currPosition);
        });
    }
    //
    _needMoveCursorImmediately() {
        return this.touchMode;
    }
    _scroll() {
        if (this.skipScrolling)
            return adapter_1.adapter.PromiseCtor.resolve(false);
        const scrollOptions = new options_1.ScrollOptions({ offsetX: this.offset.x, offsetY: this.offset.y }, false);
        return adapter_1.adapter.scroll(this.element, scrollOptions);
    }
    _moveToCurrentFrame(endPoint) {
        if (this.cursor.isActive(this.window))
            return adapter_1.adapter.PromiseCtor.resolve();
        const { x, y } = this.cursor.getPosition();
        const activeWindow = this.cursor.getActiveWindow(this.window);
        let iframe = null;
        let iframeUnderCursor = null;
        const msg = {
            cmd: MOVE_REQUEST_CMD,
            startX: x,
            startY: y,
            endX: endPoint.x,
            endY: endPoint.y,
            modifiers: this.modifiers,
            speed: this.speed,
        };
        return adapter_1.adapter.PromiseCtor.resolve()
            .then(() => {
            if (activeWindow.parent === this.window) {
                return adapter_1.adapter.PromiseCtor.resolve(adapter_1.adapter.dom.findIframeByWindow(activeWindow))
                    .then(frame => {
                    iframe = frame;
                    return adapter_1.adapter.PromiseCtor.resolve(adapter_1.adapter.position.getIframeClientCoordinates(frame))
                        .then(rect => {
                        msg.left = rect.left;
                        msg.top = rect.top;
                        msg.right = rect.right;
                        msg.bottom = rect.bottom;
                    });
                });
            }
            return void 0;
        })
            .then(() => {
            return adapter_1.adapter.getElementExceptUI(this.cursor.getPosition());
        })
            .then(topElement => {
            iframeUnderCursor = topElement === iframe;
            if (activeWindow.parent === this.window)
                msg.iframeUnderCursor = iframeUnderCursor;
            return adapter_1.adapter.sendRequestToFrame(msg, MOVE_RESPONSE_CMD, activeWindow);
        })
            .then(message => {
            this.cursor.setActiveWindow(this.window);
            if (iframeUnderCursor || adapter_1.adapter.dom.isIframeWindow(this.window))
                return this.cursor.move(message);
            return void 0;
        });
    }
    run() {
        return this._scroll()
            .then(() => Promise.all([
            this._getTargetClientPoint(),
            adapter_1.adapter.style.getWindowDimensions(this.window),
        ]))
            .then(([endPoint, boundary]) => {
            if (!boundary.contains(endPoint))
                return void 0;
            return this._moveToCurrentFrame(endPoint)
                .then(() => this._move(endPoint));
        });
    }
}
exports.default = MoveAutomation;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW92ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvYWN0aW9ucy9hdXRvbWF0aW9ucy9tb3ZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsMkNBQXdDO0FBRXhDLHNFQUE2QztBQUM3QywwREFBNEM7QUFDNUMsZ0VBSTRDO0FBQzVDLGdHQUFxRTtBQUVyRSxNQUFNLGdCQUFnQixHQUFJLHlCQUF5QixDQUFDO0FBQ3BELE1BQU0saUJBQWlCLEdBQUcsMEJBQTBCLENBQUM7QUFFckQseUZBQStEO0FBQy9ELGlGQUE0RTtBQUc1RSxpREFBNkM7QUFDN0MsaUZBQXVEO0FBT3ZELE1BQXFCLGNBQWM7SUFtQi9CLFlBQXVCLEVBQUssRUFBRSxNQUE4QixFQUFFLFdBQXdCLEVBQUUsR0FBTSxFQUFFLE1BQWlCO1FBQzdHLElBQUksQ0FBQyxTQUFTLEdBQUcsaUJBQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUM7UUFDeEQsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztRQUU1RCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFcEUsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFFMUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLE1BQU0sR0FBSSxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLE1BQU0sR0FBSSxNQUFNLENBQUM7UUFDdEIsSUFBSSxDQUFDLE1BQU0sR0FBSSxNQUFNLENBQUM7UUFFdEIsSUFBSSxDQUFDLGFBQWEsR0FBYSxXQUFXLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQztRQUM5RCxJQUFJLENBQUMsU0FBUyxHQUFpQixXQUFX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LENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO2dCQUM1RCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBRXJDLE9BQU8sS0FBSyxDQUFDLENBQUM7UUFDbEIsQ0FBQyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBRU0sR0FBRztRQUNOLE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRTthQUNoQixJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztZQUNwQixJQUFJLENBQUMscUJBQXFCLEVBQUU7WUFDNUIsaUJBQU8sQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztTQUNqRCxDQUFDLENBQUM7YUFDRixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsRUFBRSxFQUFFO1lBQzNCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztnQkFDNUIsT0FBTyxLQUFLLENBQUMsQ0FBQztZQUVsQixPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUM7aUJBQ3BDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDMUMsQ0FBQyxDQUFDLENBQUM7SUFDWCxDQUFDO0NBQ0o7QUFqUkQsaUNBaVJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYWRhcHRlciB9IGZyb20gJy4uLy4uL2FkYXB0ZXInO1xuXG5pbXBvcnQgbmV4dFRpY2sgZnJvbSAnLi4vLi4vdXRpbHMvbmV4dC10aWNrJztcbmltcG9ydCBBdXRvbWF0aW9uU2V0dGluZ3MgZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQge1xuICAgIE1vZGlmaWVycyxcbiAgICBNb3ZlT3B0aW9ucyxcbiAgICBTY3JvbGxPcHRpb25zLFxufSBmcm9tICcuLi8uLi8uLi90ZXN0LXJ1bi9jb21tYW5kcy9vcHRpb25zJztcbmltcG9ydCBsYXN0SG92ZXJlZEVsZW1lbnRIb2xkZXIgZnJvbSAnLi9sYXN0LWhvdmVyZWQtZWxlbWVudC1ob2xkZXInO1xuXG5jb25zdCBNT1ZFX1JFUVVFU1RfQ01EICA9ICdhdXRvbWF0aW9ufG1vdmV8cmVxdWVzdCc7XG5jb25zdCBNT1ZFX1JFU1BPTlNFX0NNRCA9ICdhdXRvbWF0aW9ufG1vdmV8cmVzcG9uc2UnO1xuXG5pbXBvcnQgZ2V0QXV0b21hdGlvblBvaW50IGZyb20gJy4uL3V0aWxzL2dldC1hdXRvbWF0aW9uLXBvaW50JztcbmltcG9ydCBBeGlzVmFsdWVzLCB7IEF4aXNWYWx1ZXNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbHMvdmFsdWVzL2F4aXMtdmFsdWVzJztcbmltcG9ydCB7IFNoYXJlZFdpbmRvdyB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCBDdXJzb3IgZnJvbSAnLi4vY3Vyc29yJztcbmltcG9ydCB7IHdoaWxzdCB9IGZyb20gJy4uLy4uL3V0aWxzL3Byb21pc2UnO1xuaW1wb3J0IGdldERldmljZVBvaW50IGZyb20gJy4uL3V0aWxzL2dldC1kZXZpY2UtcG9pbnQnO1xuXG5pbnRlcmZhY2UgTW92ZUF1dG9tYXRpb25UYXJnZXQ8RT4ge1xuICAgIGVsZW1lbnQ6IEU7XG4gICAgb2Zmc2V0OiBBeGlzVmFsdWVzRGF0YTxudW1iZXI+O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3ZlQXV0b21hdGlvbjxFLCBXIGV4dGVuZHMgU2hhcmVkV2luZG93PiB7XG4gICAgcHJpdmF0ZSB0b3VjaE1vZGU6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBtb3ZlRXZlbnQ6IHN0cmluZztcblxuICAgIHByaXZhdGUgYXV0b21hdGlvblNldHRpbmdzOiBBdXRvbWF0aW9uU2V0dGluZ3M7XG5cbiAgICBwcml2YXRlIGVsZW1lbnQ6IEU7XG4gICAgcHJpdmF0ZSB3aW5kb3c6IFc7XG4gICAgcHJpdmF0ZSBvZmZzZXQ6IEF4aXNWYWx1ZXNEYXRhPG51bWJlcj47XG4gICAgcHJpdmF0ZSBjdXJzb3I6IEN1cnNvcjxXPjtcbiAgICBwcml2YXRlIHNwZWVkOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBjdXJzb3JTcGVlZDogbnVtYmVyO1xuXG4gICAgcHJpdmF0ZSBtaW5Nb3ZpbmdUaW1lOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBtb2RpZmllcnM6IE1vZGlmaWVycztcbiAgICBwcml2YXRlIHNraXBTY3JvbGxpbmc6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBza2lwRGVmYXVsdERyYWdCZWhhdmlvcjogYm9vbGVhbjtcbiAgICBwcml2YXRlIGZpcnN0TW92aW5nU3RlcE9jY3VyZWQ6IGJvb2xlYW47XG5cbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3IgKGVsOiBFLCBvZmZzZXQ6IEF4aXNWYWx1ZXNEYXRhPG51bWJlcj4sIG1vdmVPcHRpb25zOiBNb3ZlT3B0aW9ucywgd2luOiBXLCBjdXJzb3I6IEN1cnNvcjxXPikge1xuICAgICAgICB0aGlzLnRvdWNoTW9kZSA9IGFkYXB0ZXIuZmVhdHVyZURldGVjdGlvbi5pc1RvdWNoRGV2aWNlO1xuICAgICAgICB0aGlzLm1vdmVFdmVudCA9IHRoaXMudG91Y2hNb2RlID8gJ3RvdWNobW92ZScgOiAnbW91c2Vtb3ZlJztcblxuICAgICAgICB0aGlzLmF1dG9tYXRpb25TZXR0aW5ncyA9IG5ldyBBdXRvbWF0aW9uU2V0dGluZ3MobW92ZU9wdGlvbnMuc3BlZWQpO1xuXG4gICAgICAgIHRoaXMuY3Vyc29yU3BlZWQgPSB0aGlzLl9nZXRDdXJzb3JTcGVlZCgpO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsO1xuICAgICAgICB0aGlzLndpbmRvdyAgPSB3aW47XG4gICAgICAgIHRoaXMub2Zmc2V0ICA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5jdXJzb3IgID0gY3Vyc29yO1xuXG4gICAgICAgIHRoaXMubWluTW92aW5nVGltZSAgICAgICAgICAgPSBtb3ZlT3B0aW9ucy5taW5Nb3ZpbmdUaW1lIHx8IDA7XG4gICAgICAgIHRoaXMubW9kaWZpZXJzICAgICAgICAgICAgICAgPSBtb3ZlT3B0aW9ucy5tb2RpZmllcnMgfHwge307XG4gICAgICAgIHRoaXMuc2tpcFNjcm9sbGluZyAgICAgICAgICAgPSBtb3ZlT3B0aW9ucy5za2lwU2Nyb2xsaW5nO1xuICAgICAgICB0aGlzLnNraXBEZWZhdWx0RHJhZ0JlaGF2aW9yID0gbW92ZU9wdGlvbnMuc2tpcERlZmF1bHREcmFnQmVoYXZpb3I7XG4gICAgICAgIHRoaXMuc3BlZWQgICAgICAgICAgICAgICAgICAgPSBtb3ZlT3B0aW9ucy5zcGVlZDtcblxuICAgICAgICB0aGlzLmZpcnN0TW92aW5nU3RlcE9jY3VyZWQgID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBjcmVhdGU8RSwgVyBleHRlbmRzIFNoYXJlZFdpbmRvdz4gKGVsOiBFLCBtb3ZlT3B0aW9uczogTW92ZU9wdGlvbnMsIHdpbjogVywgY3Vyc29yOiBDdXJzb3I8Vz4pOiBQcm9taXNlPE1vdmVBdXRvbWF0aW9uPEUsIFc+PiB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgb2Zmc2V0IH0gPSBhd2FpdCBNb3ZlQXV0b21hdGlvbi5nZXRUYXJnZXQoZWwsIHdpbiwgbmV3IEF4aXNWYWx1ZXMobW92ZU9wdGlvbnMub2Zmc2V0WCwgbW92ZU9wdGlvbnMub2Zmc2V0WSkpO1xuXG4gICAgICAgIHJldHVybiBuZXcgTW92ZUF1dG9tYXRpb24oZWxlbWVudCwgb2Zmc2V0LCBtb3ZlT3B0aW9ucywgd2luLCBjdXJzb3IpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldFRhcmdldDxFLCBXPiAoZWxlbWVudDogRSwgd2luZG93OiBXLCBvZmZzZXQ6IEF4aXNWYWx1ZXNEYXRhPG51bWJlcj4pOiBQcm9taXNlPE1vdmVBdXRvbWF0aW9uVGFyZ2V0PEU+PiB7XG4gICAgICAgIC8vIE5PVEU6IGlmIHRoZSB0YXJnZXQgcG9pbnQgKGNvbnNpZGVyaW5nIG9mZnNldHMpIGlzIG91dCBvZlxuICAgICAgICAvLyB0aGUgZWxlbWVudCBjaGFuZ2UgdGhlIHRhcmdldCBlbGVtZW50IHRvIHRoZSBkb2N1bWVudCBlbGVtZW50XG4gICAgICAgIHJldHVybiBhZGFwdGVyLlByb21pc2VDdG9yLnJlc29sdmUoYWRhcHRlci5wb3NpdGlvbi5jb250YWluc09mZnNldChlbGVtZW50LCBvZmZzZXQueCwgb2Zmc2V0LnkpKVxuICAgICAgICAgICAgLnRoZW4oY29udGFpbnNPZmZzZXQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY29udGFpbnNPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF1dG9tYXRpb25Qb2ludChlbGVtZW50LCBvZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRhcHRlci5kb20uZ2V0RG9jdW1lbnRFbGVtZW50KHdpbmRvdyksXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoW3BvaW50LCBkb2NFbF0pID0+ICh7IGVsZW1lbnQ6IGRvY0VsLCBvZmZzZXQ6IHBvaW50IH0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyBlbGVtZW50LCBvZmZzZXQgfTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2dldEN1cnNvclNwZWVkICgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRvbWF0aW9uU2V0dGluZ3MuY3Vyc29yU3BlZWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2V0VGFyZ2V0Q2xpZW50UG9pbnQgKCk6IFByb21pc2U8QXhpc1ZhbHVlczxudW1iZXI+PiB7XG4gICAgICAgIHJldHVybiBhZGFwdGVyLlByb21pc2VDdG9yLnJlc29sdmUoYWRhcHRlci5zdHlsZS5nZXRFbGVtZW50U2Nyb2xsKHRoaXMuZWxlbWVudCkpXG4gICAgICAgICAgICAudGhlbihzY3JvbGwgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhZGFwdGVyLmRvbS5pc0h0bWxFbGVtZW50KHRoaXMuZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEF4aXNWYWx1ZXMuY3JlYXRlKHRoaXMub2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1YihBeGlzVmFsdWVzLmNyZWF0ZShzY3JvbGwpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJvdW5kKE1hdGgucm91bmQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyLlByb21pc2VDdG9yLnJlc29sdmUoYWRhcHRlci5wb3NpdGlvbi5nZXRDbGllbnRQb3NpdGlvbih0aGlzLmVsZW1lbnQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihjbGllbnRQb3NpdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0RvY3VtZW50Qm9keSA9IGFkYXB0ZXIuZG9tLmlzQm9keUVsZW1lbnQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFBvaW50ICAgID0gQXhpc1ZhbHVlcy5jcmVhdGUoY2xpZW50UG9zaXRpb24pLmFkZCh0aGlzLm9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNEb2N1bWVudEJvZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50UG9pbnQuc3ViKEF4aXNWYWx1ZXMuY3JlYXRlKHNjcm9sbCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50UG9pbnQucm91bmQoTWF0aC5mbG9vcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2V0RXZlbnRTZXF1ZW5jZU9wdGlvbnMgKGN1cnJQb3NpdGlvbjogQXhpc1ZhbHVlczxudW1iZXI+KTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgY29uc3QgYnV0dG9uID0gYWRhcHRlci5ldmVudC5CVVRUT05TX1BBUkFNRVRFUi5ub0J1dHRvbjtcblxuICAgICAgICByZXR1cm4gZ2V0RGV2aWNlUG9pbnQoY3VyclBvc2l0aW9uKVxuICAgICAgICAgICAgLnRoZW4oZGV2aWNlUG9pbnQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogY3VyclBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGN1cnJQb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgICAgICBzY3JlZW5YOiBkZXZpY2VQb2ludD8ueCxcbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuWTogZGV2aWNlUG9pbnQ/LnksXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IGJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgY3RybDogICAgdGhpcy5tb2RpZmllcnMuY3RybCxcbiAgICAgICAgICAgICAgICAgICAgYWx0OiAgICAgdGhpcy5tb2RpZmllcnMuYWx0LFxuICAgICAgICAgICAgICAgICAgICBzaGlmdDogICB0aGlzLm1vZGlmaWVycy5zaGlmdCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YTogICAgdGhpcy5tb2RpZmllcnMubWV0YSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXZlbnRPcHRpb25zLCBldmVudFNlcXVlbmNlT3B0aW9uczogeyBtb3ZlRXZlbnQ6IHRoaXMubW92ZUV2ZW50IH0gfTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX3J1bkV2ZW50U2VxdWVuY2UgKGN1cnJlbnRFbGVtZW50OiBFbGVtZW50LCB7IGV2ZW50T3B0aW9ucywgZXZlbnRTZXF1ZW5jZU9wdGlvbnMgfTogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgY29uc3QgZXZlbnRTZXF1ZW5jZSA9IGF3YWl0IGFkYXB0ZXIuY3JlYXRlRXZlbnRTZXF1ZW5jZShmYWxzZSwgdGhpcy5maXJzdE1vdmluZ1N0ZXBPY2N1cmVkLCBldmVudFNlcXVlbmNlT3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50U2VxdWVuY2UucnVuKFxuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQsXG4gICAgICAgICAgICBsYXN0SG92ZXJlZEVsZW1lbnRIb2xkZXIuZ2V0KCksXG4gICAgICAgICAgICBldmVudE9wdGlvbnMsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2VtdWxhdGVFdmVudHMgKGN1cnJlbnRFbGVtZW50OiBFbGVtZW50LCBjdXJyUG9zaXRpb246IEF4aXNWYWx1ZXM8bnVtYmVyPik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RXZlbnRTZXF1ZW5jZU9wdGlvbnMoY3VyclBvc2l0aW9uKVxuICAgICAgICAgICAgLnRoZW4ob3B0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bkV2ZW50U2VxdWVuY2UoY3VycmVudEVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0TW92aW5nU3RlcE9jY3VyZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgbGFzdEhvdmVyZWRFbGVtZW50SG9sZGVyLnNldChjdXJyZW50RWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tb3ZpbmdTdGVwIChjdXJyUG9zaXRpb246IEF4aXNWYWx1ZXM8bnVtYmVyPik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3IubW92ZShjdXJyUG9zaXRpb24pXG4gICAgICAgICAgICAudGhlbigoKSA9PiBhZGFwdGVyLmdldEVsZW1lbnRFeGNlcHRVSSh0aGlzLmN1cnNvci5nZXRQb3NpdGlvbigpKSlcbiAgICAgICAgICAgIC8vIE5PVEU6IGluIHRvdWNoIG1vZGUsIGV2ZW50cyBhcmUgc2ltdWxhdGVkIGZvciB0aGUgZWxlbWVudCBmb3Igd2hpY2ggbW91c2Vkb3duIHdhcyBzaW11bGF0ZWQgKEdILTM3MilcbiAgICAgICAgICAgIC50aGVuKHRvcEVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gdGhpcy5fZ2V0Q29ycmVjdGVkVG9wRWxlbWVudCh0b3BFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGl0IGNhbiBiZSBudWxsIGluIElFXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZW11bGF0ZUV2ZW50cyhjdXJyZW50RWxlbWVudCwgY3VyclBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihuZXh0VGljayk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2V0Q29ycmVjdGVkVG9wRWxlbWVudCAodG9wRWxlbWVudDogRWxlbWVudCk6IEVsZW1lbnQge1xuICAgICAgICByZXR1cm4gdG9wRWxlbWVudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tb3ZlIChlbmRQb2ludDogQXhpc1ZhbHVlczxudW1iZXI+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9pbnQgPSB0aGlzLmN1cnNvci5nZXRQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSAgID0gQXhpc1ZhbHVlcy5jcmVhdGUoZW5kUG9pbnQpLnN1YihzdGFydFBvaW50KTtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lICA9IGFkYXB0ZXIubmF0aXZlTWV0aG9kcy5kYXRlTm93KCk7XG4gICAgICAgIGNvbnN0IG1vdmluZ1RpbWUgPSBNYXRoLm1heChNYXRoLm1heChNYXRoLmFicyhkaXN0YW5jZS54KSwgTWF0aC5hYnMoZGlzdGFuY2UueSkpIC8gdGhpcy5jdXJzb3JTcGVlZCwgdGhpcy5taW5Nb3ZpbmdUaW1lKTtcbiAgICAgICAgbGV0IGN1cnJQb3NpdGlvbiA9IEF4aXNWYWx1ZXMuY3JlYXRlKHN0YXJ0UG9pbnQpO1xuICAgICAgICBsZXQgaXNGaXJzdFN0ZXAgID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gd2hpbHN0KCgpID0+ICFjdXJyUG9zaXRpb24uZXFsKGVuZFBvaW50KSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25lZWRNb3ZlQ3Vyc29ySW1tZWRpYXRlbHkoKSlcbiAgICAgICAgICAgICAgICBjdXJyUG9zaXRpb24gPSBBeGlzVmFsdWVzLmNyZWF0ZShlbmRQb2ludCk7XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlyc3RTdGVwKSB7XG4gICAgICAgICAgICAgICAgaXNGaXJzdFN0ZXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IHRoZSBtb3VzZW1vdmUgZXZlbnQgY2FuJ3QgYmUgc2ltdWxhdGVkIGF0IHRoZSBwb2ludCB3aGVyZSB0aGUgY3Vyc29yXG4gICAgICAgICAgICAgICAgLy8gd2FzIGxvY2F0ZWQgYXQgdGhlIHN0YXJ0LiBUaGVyZWZvcmUsIHdlIGFkZCBhIG1pbmltYWwgZGlzdGFuY2UgMSBweC5cbiAgICAgICAgICAgICAgICBjdXJyUG9zaXRpb24uYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgeDogZGlzdGFuY2UueCA+IDAgPyAxIDogLTEsXG4gICAgICAgICAgICAgICAgICAgIHk6IGRpc3RhbmNlLnkgPiAwID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1pbigoYWRhcHRlci5uYXRpdmVNZXRob2RzLmRhdGVOb3coKSAtIHN0YXJ0VGltZSkgLyBtb3ZpbmdUaW1lLCAxKTtcblxuICAgICAgICAgICAgICAgIGN1cnJQb3NpdGlvbiA9IEF4aXNWYWx1ZXMuY3JlYXRlKGRpc3RhbmNlKS5tdWwocHJvZ3Jlc3MpLmFkZChzdGFydFBvaW50KS5yb3VuZChNYXRoLmZsb29yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vdmluZ1N0ZXAoY3VyclBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vXG4gICAgcHJpdmF0ZSBfbmVlZE1vdmVDdXJzb3JJbW1lZGlhdGVseSAoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdWNoTW9kZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zY3JvbGwgKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBpZiAodGhpcy5za2lwU2Nyb2xsaW5nKVxuICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXIuUHJvbWlzZUN0b3IucmVzb2x2ZShmYWxzZSk7XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsT3B0aW9ucyA9IG5ldyBTY3JvbGxPcHRpb25zKHsgb2Zmc2V0WDogdGhpcy5vZmZzZXQueCwgb2Zmc2V0WTogdGhpcy5vZmZzZXQueSB9LCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGFkYXB0ZXIuc2Nyb2xsKHRoaXMuZWxlbWVudCwgc2Nyb2xsT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbW92ZVRvQ3VycmVudEZyYW1lIChlbmRQb2ludDogQXhpc1ZhbHVlczxudW1iZXI+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvci5pc0FjdGl2ZSh0aGlzLndpbmRvdykpXG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlci5Qcm9taXNlQ3Rvci5yZXNvbHZlKCk7XG5cbiAgICAgICAgY29uc3QgeyB4LCB5IH0gICAgICAgID0gdGhpcy5jdXJzb3IuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgY29uc3QgYWN0aXZlV2luZG93ICAgID0gdGhpcy5jdXJzb3IuZ2V0QWN0aXZlV2luZG93KHRoaXMud2luZG93KTtcbiAgICAgICAgbGV0IGlmcmFtZTogYW55ICAgICAgID0gbnVsbDtcbiAgICAgICAgbGV0IGlmcmFtZVVuZGVyQ3Vyc29yOiBib29sZWFuIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgY29uc3QgbXNnOiBhbnkgPSB7XG4gICAgICAgICAgICBjbWQ6ICAgICAgIE1PVkVfUkVRVUVTVF9DTUQsXG4gICAgICAgICAgICBzdGFydFg6ICAgIHgsXG4gICAgICAgICAgICBzdGFydFk6ICAgIHksXG4gICAgICAgICAgICBlbmRYOiAgICAgIGVuZFBvaW50LngsXG4gICAgICAgICAgICBlbmRZOiAgICAgIGVuZFBvaW50LnksXG4gICAgICAgICAgICBtb2RpZmllcnM6IHRoaXMubW9kaWZpZXJzLFxuICAgICAgICAgICAgc3BlZWQ6ICAgICB0aGlzLnNwZWVkLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBhZGFwdGVyLlByb21pc2VDdG9yLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVXaW5kb3cucGFyZW50ID09PSB0aGlzLndpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRhcHRlci5Qcm9taXNlQ3Rvci5yZXNvbHZlKGFkYXB0ZXIuZG9tLmZpbmRJZnJhbWVCeVdpbmRvdyhhY3RpdmVXaW5kb3cpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnJhbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZSA9IGZyYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXIuUHJvbWlzZUN0b3IucmVzb2x2ZShhZGFwdGVyLnBvc2l0aW9uLmdldElmcmFtZUNsaWVudENvb3JkaW5hdGVzKGZyYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVjdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cubGVmdCAgID0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnLnRvcCAgICA9IHJlY3QudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnLnJpZ2h0ICA9IHJlY3QucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cuYm90dG9tID0gcmVjdC5ib3R0b207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXIuZ2V0RWxlbWVudEV4Y2VwdFVJKHRoaXMuY3Vyc29yLmdldFBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKHRvcEVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmcmFtZVVuZGVyQ3Vyc29yID0gdG9wRWxlbWVudCA9PT0gaWZyYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVdpbmRvdy5wYXJlbnQgPT09IHRoaXMud2luZG93KVxuICAgICAgICAgICAgICAgICAgICBtc2cuaWZyYW1lVW5kZXJDdXJzb3IgPSBpZnJhbWVVbmRlckN1cnNvcjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyLnNlbmRSZXF1ZXN0VG9GcmFtZShtc2csIE1PVkVfUkVTUE9OU0VfQ01ELCBhY3RpdmVXaW5kb3cpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnNldEFjdGl2ZVdpbmRvdyh0aGlzLndpbmRvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaWZyYW1lVW5kZXJDdXJzb3IgfHwgYWRhcHRlci5kb20uaXNJZnJhbWVXaW5kb3codGhpcy53aW5kb3cpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3IubW92ZShtZXNzYWdlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcnVuICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbCgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0VGFyZ2V0Q2xpZW50UG9pbnQoKSxcbiAgICAgICAgICAgICAgICBhZGFwdGVyLnN0eWxlLmdldFdpbmRvd0RpbWVuc2lvbnModGhpcy53aW5kb3cpLFxuICAgICAgICAgICAgXSkpXG4gICAgICAgICAgICAudGhlbigoW2VuZFBvaW50LCBib3VuZGFyeV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWJvdW5kYXJ5LmNvbnRhaW5zKGVuZFBvaW50KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb3ZlVG9DdXJyZW50RnJhbWUoZW5kUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuX21vdmUoZW5kUG9pbnQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbiJdfQ==