"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const adapter_1 = require("../../adapter");
const get_automation_point_1 = __importDefault(require("../utils/get-automation-point"));
const screen_point_to_client_1 = __importDefault(require("../utils/screen-point-to-client"));
const get_device_point_1 = __importDefault(require("../utils/get-device-point"));
const offsets_1 = require("../utils/offsets");
const get_element_1 = __importDefault(require("../../../shared/actions/get-element"));
const automation_errors_1 = __importDefault(require("../../../shared/errors/automation-errors"));
const settings_1 = __importDefault(require("../../../shared/actions/automations/settings"));
const move_1 = __importDefault(require("./move"));
const delay_1 = __importDefault(require("../../utils/delay"));
const event_emitter_1 = __importDefault(require("../../../shared/utils/event-emitter"));
const options_1 = require("../../../test-run/commands/options");
class ElementState {
    constructor({ element = null, clientPoint = null, screenPoint = null, isTarget = false, inMoving = false, devicePoint = null }) {
        this.element = element;
        this.clientPoint = clientPoint;
        this.screenPoint = screenPoint;
        this.devicePoint = devicePoint;
        this.isTarget = isTarget;
        this.inMoving = inMoving;
    }
    static async create({ element, clientPoint, screenPoint, isTarget, inMoving }) {
        let devicePoint = null;
        if (clientPoint)
            devicePoint = await get_device_point_1.default(clientPoint);
        const state = new ElementState({ element, clientPoint, screenPoint, isTarget, inMoving, devicePoint });
        return state;
    }
}
class VisibleElementAutomation extends event_emitter_1.default {
    constructor(element, offsetOptions, win, cursor) {
        super();
        this.TARGET_ELEMENT_FOUND_EVENT = 'automation|target-element-found-event';
        this.element = element;
        this.options = offsetOptions;
        this.automationSettings = new settings_1.default(offsetOptions.speed || 1);
        this.window = win;
        this.cursor = cursor;
        // NOTE: only for legacy API
        adapter_1.adapter.automations._ensureWindowAndCursorForLegacyTests(this);
    }
    async _getElementForEvent(eventArgs) {
        const expectedElement = await adapter_1.adapter.position.containsOffset(this.element, this.options.offsetX, this.options.offsetY) ? this.element : null;
        return get_element_1.default(eventArgs.point, this.window, expectedElement);
    }
    async _moveToElement() {
        const moveOptions = new options_1.MoveOptions(adapter_1.adapter.utils.extend({ skipScrolling: true }, this.options), false);
        const moveAutomation = await move_1.default.create(this.element, moveOptions, this.window, this.cursor);
        return moveAutomation
            .run()
            .then(() => delay_1.default(this.automationSettings.mouseActionStepDelay));
    }
    _scrollToElement() {
        let wasScrolled = false;
        const scrollOptions = new options_1.ScrollOptions(this.options, false);
        return adapter_1.adapter.scroll(this.element, scrollOptions)
            .then(scrollWasPerformed => {
            wasScrolled = scrollWasPerformed;
            return delay_1.default(this.automationSettings.mouseActionStepDelay);
        })
            .then(() => get_element_1.default(this.cursor.getPosition(), this.window))
            .then(currentElement => {
            return adapter_1.adapter.ensureMouseEventAfterScroll(currentElement, this.element, wasScrolled);
        })
            .then(() => {
            return wasScrolled;
        });
    }
    async _getElementOffset() {
        const defaultOffsets = await offsets_1.getOffsetOptions(this.element);
        let { offsetX, offsetY } = this.options;
        offsetX = offsetX || offsetX === 0 ? offsetX : defaultOffsets.offsetX;
        offsetY = offsetY || offsetY === 0 ? offsetY : defaultOffsets.offsetY;
        return { offsetX, offsetY };
    }
    async _wrapAction(action) {
        const { offsetX: x, offsetY: y } = await this._getElementOffset();
        const screenPointBeforeAction = await get_automation_point_1.default(this.element, { x, y });
        const clientPositionBeforeAction = await adapter_1.adapter.position.getClientPosition(this.element);
        await action();
        const screenPointAfterAction = await get_automation_point_1.default(this.element, { x, y });
        const clientPositionAfterAction = await adapter_1.adapter.position.getClientPosition(this.element);
        const clientPoint = await screen_point_to_client_1.default(this.element, screenPointAfterAction);
        const expectedElement = await adapter_1.adapter.position.containsOffset(this.element, x, y) ? this.element : null;
        const element = await get_element_1.default(clientPoint, this.window, expectedElement);
        if (!element) {
            return ElementState.create({
                element: null,
                clientPoint: null,
                screenPoint: null,
                isTarget: false,
                inMoving: false,
            });
        }
        let isTarget = !expectedElement || element === expectedElement || element === this.element;
        if (!isTarget) {
            // NOTE: perform an operation with searching in dom only if necessary
            isTarget = await this._contains(this.element, element);
        }
        const offsetPositionChanged = screenPointBeforeAction.x !== screenPointAfterAction.x ||
            screenPointBeforeAction.y !== screenPointAfterAction.y;
        const clientPositionChanged = clientPositionBeforeAction.x !== clientPositionAfterAction.x ||
            clientPositionBeforeAction.y !== clientPositionAfterAction.y;
        // NOTE: We consider the element moved if its offset position and client position
        // are changed both. If only client position was changed it means the page was
        // scrolled and the element keeps its position on the page. If only offset position was
        // changed it means the element is fixed on the page (it can be implemented via script).
        const targetElementIsMoving = offsetPositionChanged && clientPositionChanged;
        return ElementState.create({
            element,
            clientPoint,
            screenPoint: screenPointAfterAction,
            isTarget,
            inMoving: targetElementIsMoving,
        });
    }
    static _checkElementState(state, useStrictElementCheck) {
        if (!state.element)
            throw new Error(automation_errors_1.default.elementIsInvisibleError);
        if (useStrictElementCheck && (!state.isTarget || state.inMoving))
            throw new Error(automation_errors_1.default.foundElementIsNotTarget);
        return state;
    }
    _ensureElement(useStrictElementCheck, skipCheckAfterMoving = false, skipMoving = false) {
        return this
            ._wrapAction(() => this._scrollToElement())
            .then(state => VisibleElementAutomation._checkElementState(state, useStrictElementCheck))
            .then(state => {
            return skipMoving ? state : this._wrapAction(() => this._moveToElement());
        })
            .then(state => {
            if (!skipCheckAfterMoving)
                VisibleElementAutomation._checkElementState(state, useStrictElementCheck);
            return state;
        })
            .then(state => {
            this.emit(this.TARGET_ELEMENT_FOUND_EVENT, { element: (state === null || state === void 0 ? void 0 : state.element) || null });
            return {
                element: (state === null || state === void 0 ? void 0 : state.element) || null,
                clientPoint: (state === null || state === void 0 ? void 0 : state.clientPoint) || null,
                screenPoint: (state === null || state === void 0 ? void 0 : state.screenPoint) || null,
                devicePoint: (state === null || state === void 0 ? void 0 : state.devicePoint) || null,
            };
        });
    }
    async _contains(parent, child) {
        const parents = await adapter_1.adapter.dom.getParents(child);
        for (const el of parents) {
            if (el === parent)
                return true;
        }
        return false;
    }
}
exports.default = VisibleElementAutomation;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlzaWJsZS1lbGVtZW50LWF1dG9tYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2FjdGlvbnMvYXV0b21hdGlvbnMvdmlzaWJsZS1lbGVtZW50LWF1dG9tYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwyQ0FBd0M7QUFDeEMseUZBQStEO0FBQy9ELDZGQUFrRTtBQUNsRSxpRkFBdUQ7QUFDdkQsOENBQW9EO0FBQ3BELHNGQUFzRTtBQUN0RSxpR0FBOEU7QUFDOUUsNEZBQThFO0FBQzlFLGtEQUFvQztBQUlwQyw4REFBc0M7QUFDdEMsd0ZBQXFFO0FBRXJFLGdFQUk0QztBQWM1QyxNQUFNLFlBQVk7SUFRZCxZQUF1QixFQUFFLE9BQU8sR0FBRyxJQUFJLEVBQUUsV0FBVyxHQUFHLElBQUksRUFBRSxXQUFXLEdBQUcsSUFBSSxFQUFFLFFBQVEsR0FBRyxLQUFLLEVBQUUsUUFBUSxHQUFHLEtBQUssRUFBRSxXQUFXLEdBQUcsSUFBSSxFQUF1QjtRQUMxSixJQUFJLENBQUMsT0FBTyxHQUFPLE9BQU8sQ0FBQztRQUMzQixJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztRQUMvQixJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztRQUMvQixJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztRQUMvQixJQUFJLENBQUMsUUFBUSxHQUFNLFFBQVEsQ0FBQztRQUM1QixJQUFJLENBQUMsUUFBUSxHQUFNLFFBQVEsQ0FBQztJQUNoQyxDQUFDO0lBRU0sTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUssRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUF1QjtRQUN6RyxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUM7UUFFdkIsSUFBSSxXQUFXO1lBQ1gsV0FBVyxHQUFHLE1BQU0sMEJBQWMsQ0FBQyxXQUFXLENBQUMsQ0FB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LENBQUM7UUFFcEQsS0FBSyxNQUFNLEVBQUUsSUFBSSxPQUFPLEVBQUU7WUFDdEIsSUFBSSxFQUFFLEtBQUssTUFBTTtnQkFDYixPQUFPLElBQUksQ0FBQztTQUNuQjtRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7Q0FDSjtBQXJLRCwyQ0FxS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhZGFwdGVyIH0gZnJvbSAnLi4vLi4vYWRhcHRlcic7XG5pbXBvcnQgZ2V0QXV0b21hdGlvblBvaW50IGZyb20gJy4uL3V0aWxzL2dldC1hdXRvbWF0aW9uLXBvaW50JztcbmltcG9ydCBzY3JlZW5Qb2ludFRvQ2xpZW50IGZyb20gJy4uL3V0aWxzL3NjcmVlbi1wb2ludC10by1jbGllbnQnO1xuaW1wb3J0IGdldERldmljZVBvaW50IGZyb20gJy4uL3V0aWxzL2dldC1kZXZpY2UtcG9pbnQnO1xuaW1wb3J0IHsgZ2V0T2Zmc2V0T3B0aW9ucyB9IGZyb20gJy4uL3V0aWxzL29mZnNldHMnO1xuaW1wb3J0IGdldEVsZW1lbnRGcm9tUG9pbnQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2FjdGlvbnMvZ2V0LWVsZW1lbnQnO1xuaW1wb3J0IEFVVE9NQVRJT05fRVJST1JfVFlQRVMgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2Vycm9ycy9hdXRvbWF0aW9uLWVycm9ycyc7XG5pbXBvcnQgQXV0b21hdGlvblNldHRpbmdzIGZyb20gJy4uLy4uLy4uL3NoYXJlZC9hY3Rpb25zL2F1dG9tYXRpb25zL3NldHRpbmdzJztcbmltcG9ydCBNb3ZlQXV0b21hdGlvbiBmcm9tICcuL21vdmUnO1xuaW1wb3J0IHsgU2hhcmVkV2luZG93IH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IEF4aXNWYWx1ZXMsIHsgQXhpc1ZhbHVlc0RhdGEgfSBmcm9tICcuLi8uLi91dGlscy92YWx1ZXMvYXhpcy12YWx1ZXMnO1xuaW1wb3J0IEN1cnNvciBmcm9tICcuLi9jdXJzb3InO1xuaW1wb3J0IGRlbGF5IGZyb20gJy4uLy4uL3V0aWxzL2RlbGF5JztcbmltcG9ydCBTaGFyZWRFdmVudEVtaXR0ZXIgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzL2V2ZW50LWVtaXR0ZXInO1xuXG5pbXBvcnQge1xuICAgIE1vdmVPcHRpb25zLFxuICAgIFNjcm9sbE9wdGlvbnMsXG4gICAgT2Zmc2V0T3B0aW9ucyxcbn0gZnJvbSAnLi4vLi4vLi4vdGVzdC1ydW4vY29tbWFuZHMvb3B0aW9ucyc7XG5cbmludGVyZmFjZSBFbGVtZW50U3RhdGVBcmdzQmFzZTxFPiB7XG4gICAgZWxlbWVudDogRSB8IG51bGw7XG4gICAgY2xpZW50UG9pbnQ6IEF4aXNWYWx1ZXM8bnVtYmVyPiB8IG51bGw7XG4gICAgc2NyZWVuUG9pbnQ6IEF4aXNWYWx1ZXM8bnVtYmVyPiB8IG51bGw7XG4gICAgZGV2aWNlUG9pbnQ/OiBBeGlzVmFsdWVzPG51bWJlcj4gfCBudWxsO1xufVxuXG5pbnRlcmZhY2UgRWxlbWVudFN0YXRlQXJnczxFPiBleHRlbmRzIEVsZW1lbnRTdGF0ZUFyZ3NCYXNlPEU+IHtcbiAgICBpc1RhcmdldDogYm9vbGVhbjtcbiAgICBpbk1vdmluZzogYm9vbGVhbjtcbn1cblxuY2xhc3MgRWxlbWVudFN0YXRlPEU+IGltcGxlbWVudHMgRWxlbWVudFN0YXRlQXJnczxFPiB7XG4gICAgcHVibGljIGVsZW1lbnQ6IEUgfCBudWxsO1xuICAgIHB1YmxpYyBjbGllbnRQb2ludDogQXhpc1ZhbHVlczxudW1iZXI+IHwgbnVsbDtcbiAgICBwdWJsaWMgc2NyZWVuUG9pbnQ6IEF4aXNWYWx1ZXM8bnVtYmVyPiB8IG51bGw7XG4gICAgcHVibGljIGRldmljZVBvaW50OiBBeGlzVmFsdWVzPG51bWJlcj4gfCBudWxsO1xuICAgIHB1YmxpYyBpc1RhcmdldDogYm9vbGVhbjtcbiAgICBwdWJsaWMgaW5Nb3Zpbmc6IGJvb2xlYW47XG5cbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3IgKHsgZWxlbWVudCA9IG51bGwsIGNsaWVudFBvaW50ID0gbnVsbCwgc2NyZWVuUG9pbnQgPSBudWxsLCBpc1RhcmdldCA9IGZhbHNlLCBpbk1vdmluZyA9IGZhbHNlLCBkZXZpY2VQb2ludCA9IG51bGwgfTogRWxlbWVudFN0YXRlQXJnczxFPikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgICAgID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5jbGllbnRQb2ludCA9IGNsaWVudFBvaW50O1xuICAgICAgICB0aGlzLnNjcmVlblBvaW50ID0gc2NyZWVuUG9pbnQ7XG4gICAgICAgIHRoaXMuZGV2aWNlUG9pbnQgPSBkZXZpY2VQb2ludDtcbiAgICAgICAgdGhpcy5pc1RhcmdldCAgICA9IGlzVGFyZ2V0O1xuICAgICAgICB0aGlzLmluTW92aW5nICAgID0gaW5Nb3Zpbmc7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBjcmVhdGU8RT4gKHsgZWxlbWVudCwgY2xpZW50UG9pbnQsIHNjcmVlblBvaW50LCBpc1RhcmdldCwgaW5Nb3ZpbmcgfTogRWxlbWVudFN0YXRlQXJnczxFPik6IFByb21pc2U8RWxlbWVudFN0YXRlPEU+PiB7XG4gICAgICAgIGxldCBkZXZpY2VQb2ludCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGNsaWVudFBvaW50KVxuICAgICAgICAgICAgZGV2aWNlUG9pbnQgPSBhd2FpdCBnZXREZXZpY2VQb2ludChjbGllbnRQb2ludCk7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgRWxlbWVudFN0YXRlPEU+KHsgZWxlbWVudCwgY2xpZW50UG9pbnQsIHNjcmVlblBvaW50LCBpc1RhcmdldCwgaW5Nb3ZpbmcsIGRldmljZVBvaW50IH0pO1xuXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW91c2VFdmVudEFyZ3M8RT4ge1xuICAgIHBvaW50OiBBeGlzVmFsdWVzRGF0YTxudW1iZXI+IHwgbnVsbDtcbiAgICBzY3JlZW5Qb2ludDogQXhpc1ZhbHVlc0RhdGE8bnVtYmVyPiB8IG51bGw7XG4gICAgZWxlbWVudDogRSB8IG51bGw7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBjbGllbnRYOiBudW1iZXI7XG4gICAgICAgIGNsaWVudFk6IG51bWJlcjtcbiAgICAgICAgc2NyZWVuWDogbnVtYmVyO1xuICAgICAgICBzY3JlZW5ZOiBudW1iZXI7XG4gICAgICAgIGN0cmw6IGJvb2xlYW47XG4gICAgICAgIGFsdDogYm9vbGVhbjtcbiAgICAgICAgc2hpZnQ6IGJvb2xlYW47XG4gICAgICAgIG1ldGE6IGJvb2xlYW47XG4gICAgICAgIHRpbWVTdGFtcDogdW5rbm93bjtcbiAgICB9IHwgbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlzaWJsZUVsZW1lbnRBdXRvbWF0aW9uPEUsIFcgZXh0ZW5kcyBTaGFyZWRXaW5kb3c+IGV4dGVuZHMgU2hhcmVkRXZlbnRFbWl0dGVyIHtcbiAgICBwcm90ZWN0ZWQgZWxlbWVudDogRTtcbiAgICBwcml2YXRlIHdpbmRvdzogVztcbiAgICBwcm90ZWN0ZWQgY3Vyc29yOiBDdXJzb3I8Vz5cbiAgICBwcml2YXRlIFRBUkdFVF9FTEVNRU5UX0ZPVU5EX0VWRU5UOiBzdHJpbmc7XG4gICAgcHJvdGVjdGVkIGF1dG9tYXRpb25TZXR0aW5nczogQXV0b21hdGlvblNldHRpbmdzO1xuICAgIHByaXZhdGUgb3B0aW9uczogT2Zmc2V0T3B0aW9ucztcblxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RvciAoZWxlbWVudDogRSwgb2Zmc2V0T3B0aW9uczogT2Zmc2V0T3B0aW9ucywgd2luOiBXLCBjdXJzb3I6IEN1cnNvcjxXPikge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuVEFSR0VUX0VMRU1FTlRfRk9VTkRfRVZFTlQgPSAnYXV0b21hdGlvbnx0YXJnZXQtZWxlbWVudC1mb3VuZC1ldmVudCc7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50ICAgICAgICAgICAgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm9wdGlvbnMgICAgICAgICAgICA9IG9mZnNldE9wdGlvbnM7XG4gICAgICAgIHRoaXMuYXV0b21hdGlvblNldHRpbmdzID0gbmV3IEF1dG9tYXRpb25TZXR0aW5ncyhvZmZzZXRPcHRpb25zLnNwZWVkIHx8IDEpO1xuXG4gICAgICAgIHRoaXMud2luZG93ICA9IHdpbjtcbiAgICAgICAgdGhpcy5jdXJzb3IgID0gY3Vyc29yO1xuXG4gICAgICAgIC8vIE5PVEU6IG9ubHkgZm9yIGxlZ2FjeSBBUElcbiAgICAgICAgYWRhcHRlci5hdXRvbWF0aW9ucy5fZW5zdXJlV2luZG93QW5kQ3Vyc29yRm9yTGVnYWN5VGVzdHModGhpcyk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFzeW5jIF9nZXRFbGVtZW50Rm9yRXZlbnQgKGV2ZW50QXJnczogTW91c2VFdmVudEFyZ3M8RT4pOiBQcm9taXNlPEUgfCBudWxsPiB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkRWxlbWVudCA9IGF3YWl0IGFkYXB0ZXIucG9zaXRpb24uY29udGFpbnNPZmZzZXQodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMub2Zmc2V0WCwgdGhpcy5vcHRpb25zLm9mZnNldFkpID8gdGhpcy5lbGVtZW50IDogbnVsbDtcblxuICAgICAgICByZXR1cm4gZ2V0RWxlbWVudEZyb21Qb2ludChldmVudEFyZ3MucG9pbnQgYXMgQXhpc1ZhbHVlc0RhdGE8bnVtYmVyPiwgdGhpcy53aW5kb3csIGV4cGVjdGVkRWxlbWVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfbW92ZVRvRWxlbWVudCAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IG1vdmVPcHRpb25zICAgID0gbmV3IE1vdmVPcHRpb25zKGFkYXB0ZXIudXRpbHMuZXh0ZW5kKHsgc2tpcFNjcm9sbGluZzogdHJ1ZSB9LCB0aGlzLm9wdGlvbnMpLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IG1vdmVBdXRvbWF0aW9uID0gYXdhaXQgTW92ZUF1dG9tYXRpb24uY3JlYXRlKHRoaXMuZWxlbWVudCwgbW92ZU9wdGlvbnMsIHRoaXMud2luZG93LCB0aGlzLmN1cnNvcik7XG5cbiAgICAgICAgcmV0dXJuIG1vdmVBdXRvbWF0aW9uXG4gICAgICAgICAgICAucnVuKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IGRlbGF5KHRoaXMuYXV0b21hdGlvblNldHRpbmdzLm1vdXNlQWN0aW9uU3RlcERlbGF5KSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc2Nyb2xsVG9FbGVtZW50ICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgbGV0IHdhc1Njcm9sbGVkICAgICAgICA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzY3JvbGxPcHRpb25zICAgID0gbmV3IFNjcm9sbE9wdGlvbnModGhpcy5vcHRpb25zLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGFkYXB0ZXIuc2Nyb2xsKHRoaXMuZWxlbWVudCwgc2Nyb2xsT3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKHNjcm9sbFdhc1BlcmZvcm1lZCA9PiB7XG4gICAgICAgICAgICAgICAgd2FzU2Nyb2xsZWQgPSBzY3JvbGxXYXNQZXJmb3JtZWQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsYXkodGhpcy5hdXRvbWF0aW9uU2V0dGluZ3MubW91c2VBY3Rpb25TdGVwRGVsYXkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IGdldEVsZW1lbnRGcm9tUG9pbnQodGhpcy5jdXJzb3IuZ2V0UG9zaXRpb24oKSwgdGhpcy53aW5kb3cpKVxuICAgICAgICAgICAgLnRoZW4oY3VycmVudEVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyLmVuc3VyZU1vdXNlRXZlbnRBZnRlclNjcm9sbChjdXJyZW50RWxlbWVudCwgdGhpcy5lbGVtZW50LCB3YXNTY3JvbGxlZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB3YXNTY3JvbGxlZDtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX2dldEVsZW1lbnRPZmZzZXQgKCk6IFByb21pc2U8eyBvZmZzZXRYOiBudW1iZXI7IG9mZnNldFk6IG51bWJlciB9PiB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRPZmZzZXRzID0gYXdhaXQgZ2V0T2Zmc2V0T3B0aW9ucyh0aGlzLmVsZW1lbnQpO1xuXG4gICAgICAgIGxldCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICBvZmZzZXRYID0gb2Zmc2V0WCB8fCBvZmZzZXRYID09PSAwID8gb2Zmc2V0WCA6IGRlZmF1bHRPZmZzZXRzLm9mZnNldFg7XG4gICAgICAgIG9mZnNldFkgPSBvZmZzZXRZIHx8IG9mZnNldFkgPT09IDAgPyBvZmZzZXRZIDogZGVmYXVsdE9mZnNldHMub2Zmc2V0WTtcblxuICAgICAgICByZXR1cm4geyBvZmZzZXRYLCBvZmZzZXRZIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfd3JhcEFjdGlvbiAoYWN0aW9uOiAoKSA9PiBQcm9taXNlPHVua25vd24+KTogUHJvbWlzZTxFbGVtZW50U3RhdGU8RT4+IHtcbiAgICAgICAgY29uc3QgeyBvZmZzZXRYOiB4LCBvZmZzZXRZOiB5IH0gPSBhd2FpdCB0aGlzLl9nZXRFbGVtZW50T2Zmc2V0KCk7XG4gICAgICAgIGNvbnN0IHNjcmVlblBvaW50QmVmb3JlQWN0aW9uICAgID0gYXdhaXQgZ2V0QXV0b21hdGlvblBvaW50KHRoaXMuZWxlbWVudCwgeyB4LCB5IH0pO1xuICAgICAgICBjb25zdCBjbGllbnRQb3NpdGlvbkJlZm9yZUFjdGlvbiA9IGF3YWl0IGFkYXB0ZXIucG9zaXRpb24uZ2V0Q2xpZW50UG9zaXRpb24odGhpcy5lbGVtZW50KTtcblxuICAgICAgICBhd2FpdCBhY3Rpb24oKTtcblxuICAgICAgICBjb25zdCBzY3JlZW5Qb2ludEFmdGVyQWN0aW9uICAgID0gYXdhaXQgZ2V0QXV0b21hdGlvblBvaW50KHRoaXMuZWxlbWVudCwgeyB4LCB5IH0pO1xuICAgICAgICBjb25zdCBjbGllbnRQb3NpdGlvbkFmdGVyQWN0aW9uID0gYXdhaXQgYWRhcHRlci5wb3NpdGlvbi5nZXRDbGllbnRQb3NpdGlvbih0aGlzLmVsZW1lbnQpO1xuICAgICAgICBjb25zdCBjbGllbnRQb2ludCAgICAgICAgICAgICAgID0gYXdhaXQgc2NyZWVuUG9pbnRUb0NsaWVudCh0aGlzLmVsZW1lbnQsIHNjcmVlblBvaW50QWZ0ZXJBY3Rpb24pO1xuICAgICAgICBjb25zdCBleHBlY3RlZEVsZW1lbnQgICAgICAgICAgID0gYXdhaXQgYWRhcHRlci5wb3NpdGlvbi5jb250YWluc09mZnNldCh0aGlzLmVsZW1lbnQsIHgsIHkpID8gdGhpcy5lbGVtZW50IDogbnVsbDtcblxuICAgICAgICBjb25zdCBlbGVtZW50ID0gYXdhaXQgZ2V0RWxlbWVudEZyb21Qb2ludChjbGllbnRQb2ludCwgdGhpcy53aW5kb3csIGV4cGVjdGVkRWxlbWVudCk7XG5cbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudFN0YXRlLmNyZWF0ZTxFPih7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogICAgIG51bGwsXG4gICAgICAgICAgICAgICAgY2xpZW50UG9pbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgc2NyZWVuUG9pbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgaXNUYXJnZXQ6ICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGluTW92aW5nOiAgICBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlzVGFyZ2V0ID0gIWV4cGVjdGVkRWxlbWVudCB8fCBlbGVtZW50ID09PSBleHBlY3RlZEVsZW1lbnQgfHwgZWxlbWVudCA9PT0gdGhpcy5lbGVtZW50O1xuXG4gICAgICAgIGlmICghaXNUYXJnZXQpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IHBlcmZvcm0gYW4gb3BlcmF0aW9uIHdpdGggc2VhcmNoaW5nIGluIGRvbSBvbmx5IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgaXNUYXJnZXQgPSBhd2FpdCB0aGlzLl9jb250YWlucyh0aGlzLmVsZW1lbnQsIGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2Zmc2V0UG9zaXRpb25DaGFuZ2VkID0gc2NyZWVuUG9pbnRCZWZvcmVBY3Rpb24ueCAhPT0gc2NyZWVuUG9pbnRBZnRlckFjdGlvbi54IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5Qb2ludEJlZm9yZUFjdGlvbi55ICE9PSBzY3JlZW5Qb2ludEFmdGVyQWN0aW9uLnk7XG4gICAgICAgIGNvbnN0IGNsaWVudFBvc2l0aW9uQ2hhbmdlZCA9IGNsaWVudFBvc2l0aW9uQmVmb3JlQWN0aW9uLnggIT09IGNsaWVudFBvc2l0aW9uQWZ0ZXJBY3Rpb24ueCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50UG9zaXRpb25CZWZvcmVBY3Rpb24ueSAhPT0gY2xpZW50UG9zaXRpb25BZnRlckFjdGlvbi55O1xuXG4gICAgICAgIC8vIE5PVEU6IFdlIGNvbnNpZGVyIHRoZSBlbGVtZW50IG1vdmVkIGlmIGl0cyBvZmZzZXQgcG9zaXRpb24gYW5kIGNsaWVudCBwb3NpdGlvblxuICAgICAgICAvLyBhcmUgY2hhbmdlZCBib3RoLiBJZiBvbmx5IGNsaWVudCBwb3NpdGlvbiB3YXMgY2hhbmdlZCBpdCBtZWFucyB0aGUgcGFnZSB3YXNcbiAgICAgICAgLy8gc2Nyb2xsZWQgYW5kIHRoZSBlbGVtZW50IGtlZXBzIGl0cyBwb3NpdGlvbiBvbiB0aGUgcGFnZS4gSWYgb25seSBvZmZzZXQgcG9zaXRpb24gd2FzXG4gICAgICAgIC8vIGNoYW5nZWQgaXQgbWVhbnMgdGhlIGVsZW1lbnQgaXMgZml4ZWQgb24gdGhlIHBhZ2UgKGl0IGNhbiBiZSBpbXBsZW1lbnRlZCB2aWEgc2NyaXB0KS5cbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudElzTW92aW5nID0gb2Zmc2V0UG9zaXRpb25DaGFuZ2VkICYmIGNsaWVudFBvc2l0aW9uQ2hhbmdlZDtcblxuICAgICAgICByZXR1cm4gRWxlbWVudFN0YXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgY2xpZW50UG9pbnQsXG4gICAgICAgICAgICBzY3JlZW5Qb2ludDogc2NyZWVuUG9pbnRBZnRlckFjdGlvbixcbiAgICAgICAgICAgIGlzVGFyZ2V0LFxuICAgICAgICAgICAgaW5Nb3Zpbmc6ICAgIHRhcmdldEVsZW1lbnRJc01vdmluZyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2NoZWNrRWxlbWVudFN0YXRlPEU+IChzdGF0ZTogRWxlbWVudFN0YXRlPEU+LCB1c2VTdHJpY3RFbGVtZW50Q2hlY2s6IGJvb2xlYW4pOiBFbGVtZW50U3RhdGU8RT4ge1xuICAgICAgICBpZiAoIXN0YXRlLmVsZW1lbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQVVUT01BVElPTl9FUlJPUl9UWVBFUy5lbGVtZW50SXNJbnZpc2libGVFcnJvcik7XG5cbiAgICAgICAgaWYgKHVzZVN0cmljdEVsZW1lbnRDaGVjayAmJiAoIXN0YXRlLmlzVGFyZ2V0IHx8IHN0YXRlLmluTW92aW5nKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihBVVRPTUFUSU9OX0VSUk9SX1RZUEVTLmZvdW5kRWxlbWVudElzTm90VGFyZ2V0KTtcblxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9lbnN1cmVFbGVtZW50ICh1c2VTdHJpY3RFbGVtZW50Q2hlY2s6IGJvb2xlYW4sIHNraXBDaGVja0FmdGVyTW92aW5nID0gZmFsc2UsIHNraXBNb3ZpbmcgPSBmYWxzZSk6IFByb21pc2U8RWxlbWVudFN0YXRlQXJnc0Jhc2U8RT4+IHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIC5fd3JhcEFjdGlvbigoKSA9PiB0aGlzLl9zY3JvbGxUb0VsZW1lbnQoKSlcbiAgICAgICAgICAgIC50aGVuKHN0YXRlID0+IFZpc2libGVFbGVtZW50QXV0b21hdGlvbi5fY2hlY2tFbGVtZW50U3RhdGUoc3RhdGUsIHVzZVN0cmljdEVsZW1lbnRDaGVjaykpXG4gICAgICAgICAgICAudGhlbihzdGF0ZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNraXBNb3ZpbmcgPyBzdGF0ZSA6IHRoaXMuX3dyYXBBY3Rpb24oKCkgPT4gdGhpcy5fbW92ZVRvRWxlbWVudCgpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihzdGF0ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFza2lwQ2hlY2tBZnRlck1vdmluZylcbiAgICAgICAgICAgICAgICAgICAgVmlzaWJsZUVsZW1lbnRBdXRvbWF0aW9uLl9jaGVja0VsZW1lbnRTdGF0ZShzdGF0ZSwgdXNlU3RyaWN0RWxlbWVudENoZWNrKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihzdGF0ZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuVEFSR0VUX0VMRU1FTlRfRk9VTkRfRVZFTlQsIHsgZWxlbWVudDogc3RhdGU/LmVsZW1lbnQgfHwgbnVsbCB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICAgICBzdGF0ZT8uZWxlbWVudCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRQb2ludDogc3RhdGU/LmNsaWVudFBvaW50IHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblBvaW50OiBzdGF0ZT8uc2NyZWVuUG9pbnQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZGV2aWNlUG9pbnQ6IHN0YXRlPy5kZXZpY2VQb2ludCB8fCBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9jb250YWlucyAocGFyZW50OiBFLCBjaGlsZDogRSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gYXdhaXQgYWRhcHRlci5kb20uZ2V0UGFyZW50cyhjaGlsZCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBlbCBvZiBwYXJlbnRzKSB7XG4gICAgICAgICAgICBpZiAoZWwgPT09IHBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iXX0=