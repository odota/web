"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const phase_1 = __importDefault(require("../test-run/phase"));
const process_test_fn_error_1 = __importDefault(require("../errors/process-test-fn-error"));
const execute_fn_with_timeout_1 = __importDefault(require("../utils/execute-fn-with-timeout"));
class FixtureHookController {
    constructor(tests, browserConnectionCount) {
        this._fixtureMap = FixtureHookController._createFixtureMap(tests, browserConnectionCount);
    }
    static _ensureFixtureMapItem(fixtureMap, fixture) {
        if (!fixtureMap.has(fixture)) {
            const item = {
                started: false,
                runningFixtureBeforeHook: false,
                fixtureBeforeHookErr: null,
                pendingTestRunCount: 0,
                fixtureCtx: Object.create(null),
            };
            fixtureMap.set(fixture, item);
        }
    }
    static _createFixtureMap(tests, browserConnectionCount) {
        return tests.reduce((fixtureMap, test) => {
            const fixture = test.fixture;
            if (!test.skip) {
                FixtureHookController._ensureFixtureMapItem(fixtureMap, fixture);
                const item = fixtureMap.get(fixture);
                item.pendingTestRunCount += browserConnectionCount;
            }
            return fixtureMap;
        }, new Map());
    }
    _getFixtureMapItem(test) {
        return test.skip ? null : this._fixtureMap.get(test.fixture);
    }
    isTestBlocked(test) {
        const item = this._getFixtureMapItem(test);
        return !!item && item.runningFixtureBeforeHook;
    }
    async _runFixtureBeforeHook(item, fn, testRun) {
        if (!fn)
            return true;
        item.runningFixtureBeforeHook = true;
        try {
            await execute_fn_with_timeout_1.default(fn, testRun.executionTimeout, item.fixtureCtx);
        }
        catch (err) {
            item.fixtureBeforeHookErr = process_test_fn_error_1.default(err);
        }
        item.runningFixtureBeforeHook = false;
        return !item.fixtureBeforeHookErr;
    }
    async _runFixtureAfterHook(item, fn, testRun) {
        if (!fn)
            return;
        testRun.phase = phase_1.default.inFixtureAfterHook;
        try {
            await execute_fn_with_timeout_1.default(fn, testRun.executionTimeout, item.fixtureCtx);
        }
        catch (err) {
            testRun.addError(process_test_fn_error_1.default(err));
        }
    }
    async runFixtureBeforeHookIfNecessary(testRun) {
        const fixture = testRun.test.fixture;
        const item = this._getFixtureMapItem(testRun.test);
        if (item) {
            const shouldRunBeforeHook = !item.started;
            item.started = true;
            const success = shouldRunBeforeHook
                && await this._runFixtureBeforeHook(item, fixture.globalBeforeFn, testRun)
                && await this._runFixtureBeforeHook(item, fixture.beforeFn, testRun);
            // NOTE: fail all tests in fixture if fixture.before hook has error
            if (!success && item.fixtureBeforeHookErr) {
                testRun.phase = phase_1.default.inFixtureBeforeHook;
                testRun.addError(item.fixtureBeforeHookErr);
                return false;
            }
            testRun.fixtureCtx = item.fixtureCtx;
        }
        return true;
    }
    async runFixtureAfterHookIfNecessary(testRun) {
        var _a;
        const fixture = testRun.test.fixture;
        const item = this._getFixtureMapItem(testRun.test);
        if (!item)
            return;
        item.pendingTestRunCount--;
        if (item.pendingTestRunCount !== 0)
            return;
        await this._runFixtureAfterHook(item, fixture.afterFn, testRun);
        await this._runFixtureAfterHook(item, fixture.globalAfterFn, testRun);
        if (item.fixtureCtx) {
            await ((_a = testRun.compilerService) === null || _a === void 0 ? void 0 : _a.removeFixtureCtxsFromState({
                fixtureIds: [fixture.id],
            }));
        }
        this._fixtureMap.delete(fixture);
    }
}
exports.default = FixtureHookController;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZml4dHVyZS1ob29rLWNvbnRyb2xsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcnVubmVyL2ZpeHR1cmUtaG9vay1jb250cm9sbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsOERBQStDO0FBQy9DLDRGQUFpRTtBQUlqRSwrRkFBb0U7QUFVcEUsTUFBcUIscUJBQXFCO0lBR3RDLFlBQW9CLEtBQWEsRUFBRSxzQkFBOEI7UUFDN0QsSUFBSSxDQUFDLFdBQVcsR0FBRyxxQkFBcUIsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztJQUM5RixDQUFDO0lBRU8sTUFBTSxDQUFDLHFCQUFxQixDQUFFLFVBQXNDLEVBQUUsT0FBZ0I7UUFDMUYsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDMUIsTUFBTSxJQUFJLEdBQUc7Z0JBQ1QsT0FBTyxFQUFtQixLQUFLO2dCQUMvQix3QkFBd0IsRUFBRSxLQUFLO2dCQUMvQixvQkFBb0IsRUFBTSxJQUFJO2dCQUM5QixtQkFBbUIsRUFBTyxDQUFDO2dCQUMzQixVQUFVLEVBQWdCLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO2FBQ2hELENBQUM7WUFFRixVQUFVLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNqQztJQUNMLENBQUM7SUFFTyxNQUFNLENBQUMsaUJBQWlCLENBQUUsS0FBYSxFQUFFLHNCQUE4QjtRQUMzRSxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxVQUFVLEVBQUUsSUFBSSxFQUFFLEVBQUU7WUFDckMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUU3QixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDWixxQkFBcUIsQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLEVBQUUsT0FBa0IsQ0FBQyxDQUFDO2dC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QUFLLENBQUM7YUFDaEI7WUFFRCxPQUFPLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7U0FDeEM7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRU0sS0FBSyxDQUFDLDhCQUE4QixDQUFFLE9BQWdCOztRQUN6RCxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQWtCLENBQUM7UUFDaEQsTUFBTSxJQUFJLEdBQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV0RCxJQUFJLENBQUMsSUFBSTtZQUNMLE9BQU87UUFFWCxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUUzQixJQUFJLElBQUksQ0FBQyxtQkFBbUIsS0FBSyxDQUFDO1lBQzlCLE9BQU87UUFFWCxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNoRSxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUV0RSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDakIsYUFBTSxPQUFPLENBQUMsZUFBZSwwQ0FBRSwwQkFBMEIsQ0FBQztnQkFDdEQsVUFBVSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQzthQUMzQixFQUFDLENBQUM7U0FDTjtRQUVELElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3JDLENBQUM7Q0FDSjtBQWxJRCx3Q0FrSUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVEVTVF9SVU5fUEhBU0UgZnJvbSAnLi4vdGVzdC1ydW4vcGhhc2UnO1xuaW1wb3J0IHByb2Nlc3NUZXN0Rm5FcnJvciBmcm9tICcuLi9lcnJvcnMvcHJvY2Vzcy10ZXN0LWZuLWVycm9yJztcbmltcG9ydCBUZXN0IGZyb20gJy4uL2FwaS9zdHJ1Y3R1cmUvdGVzdCc7XG5pbXBvcnQgRml4dHVyZSBmcm9tICcuLi9hcGkvc3RydWN0dXJlL2ZpeHR1cmUnO1xuaW1wb3J0IFRlc3RSdW4gZnJvbSAnLi4vdGVzdC1ydW4nO1xuaW1wb3J0IGV4ZWN1dGVGbldpdGhUaW1lb3V0IGZyb20gJy4uL3V0aWxzL2V4ZWN1dGUtZm4td2l0aC10aW1lb3V0JztcblxuaW50ZXJmYWNlIEZpeHR1cmVTdGF0ZSB7XG4gICAgc3RhcnRlZDogYm9vbGVhbjtcbiAgICBydW5uaW5nRml4dHVyZUJlZm9yZUhvb2s6IGJvb2xlYW47XG4gICAgZml4dHVyZUJlZm9yZUhvb2tFcnI6IG51bGwgfCBFcnJvcjtcbiAgICBwZW5kaW5nVGVzdFJ1bkNvdW50OiBudW1iZXI7XG4gICAgZml4dHVyZUN0eDogb2JqZWN0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXh0dXJlSG9va0NvbnRyb2xsZXIge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2ZpeHR1cmVNYXA6IE1hcDxGaXh0dXJlLCBGaXh0dXJlU3RhdGU+O1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yICh0ZXN0czogVGVzdFtdLCBicm93c2VyQ29ubmVjdGlvbkNvdW50OiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fZml4dHVyZU1hcCA9IEZpeHR1cmVIb29rQ29udHJvbGxlci5fY3JlYXRlRml4dHVyZU1hcCh0ZXN0cywgYnJvd3NlckNvbm5lY3Rpb25Db3VudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2Vuc3VyZUZpeHR1cmVNYXBJdGVtIChmaXh0dXJlTWFwOiBNYXA8Rml4dHVyZSwgRml4dHVyZVN0YXRlPiwgZml4dHVyZTogRml4dHVyZSk6IHZvaWQge1xuICAgICAgICBpZiAoIWZpeHR1cmVNYXAuaGFzKGZpeHR1cmUpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0ZWQ6ICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgcnVubmluZ0ZpeHR1cmVCZWZvcmVIb29rOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmaXh0dXJlQmVmb3JlSG9va0VycjogICAgIG51bGwsXG4gICAgICAgICAgICAgICAgcGVuZGluZ1Rlc3RSdW5Db3VudDogICAgICAwLFxuICAgICAgICAgICAgICAgIGZpeHR1cmVDdHg6ICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZpeHR1cmVNYXAuc2V0KGZpeHR1cmUsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2NyZWF0ZUZpeHR1cmVNYXAgKHRlc3RzOiBUZXN0W10sIGJyb3dzZXJDb25uZWN0aW9uQ291bnQ6IG51bWJlcik6IE1hcDxGaXh0dXJlLCBGaXh0dXJlU3RhdGU+IHtcbiAgICAgICAgcmV0dXJuIHRlc3RzLnJlZHVjZSgoZml4dHVyZU1hcCwgdGVzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZml4dHVyZSA9IHRlc3QuZml4dHVyZTtcblxuICAgICAgICAgICAgaWYgKCF0ZXN0LnNraXApIHtcbiAgICAgICAgICAgICAgICBGaXh0dXJlSG9va0NvbnRyb2xsZXIuX2Vuc3VyZUZpeHR1cmVNYXBJdGVtKGZpeHR1cmVNYXAsIGZpeHR1cmUgYXMgRml4dHVyZSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gZml4dHVyZU1hcC5nZXQoZml4dHVyZSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLnBlbmRpbmdUZXN0UnVuQ291bnQgKz0gYnJvd3NlckNvbm5lY3Rpb25Db3VudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZpeHR1cmVNYXA7XG4gICAgICAgIH0sIG5ldyBNYXAoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2V0Rml4dHVyZU1hcEl0ZW0gKHRlc3Q6IFRlc3QpOiBudWxsIHwgRml4dHVyZVN0YXRlIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRlc3Quc2tpcCA/IG51bGwgOiB0aGlzLl9maXh0dXJlTWFwLmdldCh0ZXN0LmZpeHR1cmUgYXMgRml4dHVyZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGlzVGVzdEJsb2NrZWQgKHRlc3Q6IFRlc3QpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2dldEZpeHR1cmVNYXBJdGVtKHRlc3QpO1xuXG4gICAgICAgIHJldHVybiAhIWl0ZW0gJiYgaXRlbS5ydW5uaW5nRml4dHVyZUJlZm9yZUhvb2s7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfcnVuRml4dHVyZUJlZm9yZUhvb2sgKGl0ZW06IEZpeHR1cmVTdGF0ZSwgZm46IEZ1bmN0aW9uLCB0ZXN0UnVuOiBUZXN0UnVuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGlmICghZm4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBpdGVtLnJ1bm5pbmdGaXh0dXJlQmVmb3JlSG9vayA9IHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGV4ZWN1dGVGbldpdGhUaW1lb3V0KGZuLCB0ZXN0UnVuLmV4ZWN1dGlvblRpbWVvdXQsIGl0ZW0uZml4dHVyZUN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaXRlbS5maXh0dXJlQmVmb3JlSG9va0VyciA9IHByb2Nlc3NUZXN0Rm5FcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbS5ydW5uaW5nRml4dHVyZUJlZm9yZUhvb2sgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gIWl0ZW0uZml4dHVyZUJlZm9yZUhvb2tFcnI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfcnVuRml4dHVyZUFmdGVySG9vayAoaXRlbTogRml4dHVyZVN0YXRlLCBmbjogRnVuY3Rpb24gfCBudWxsLCB0ZXN0UnVuOiBUZXN0UnVuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghZm4pXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdGVzdFJ1bi5waGFzZSA9IFRFU1RfUlVOX1BIQVNFLmluRml4dHVyZUFmdGVySG9vaztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZXhlY3V0ZUZuV2l0aFRpbWVvdXQoZm4sIHRlc3RSdW4uZXhlY3V0aW9uVGltZW91dCwgaXRlbS5maXh0dXJlQ3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0ZXN0UnVuLmFkZEVycm9yKHByb2Nlc3NUZXN0Rm5FcnJvcihlcnIpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBydW5GaXh0dXJlQmVmb3JlSG9va0lmTmVjZXNzYXJ5ICh0ZXN0UnVuOiBUZXN0UnVuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IGZpeHR1cmUgPSB0ZXN0UnVuLnRlc3QuZml4dHVyZSBhcyBGaXh0dXJlO1xuICAgICAgICBjb25zdCBpdGVtICAgID0gdGhpcy5fZ2V0Rml4dHVyZU1hcEl0ZW0odGVzdFJ1bi50ZXN0KTtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUnVuQmVmb3JlSG9vayA9ICFpdGVtLnN0YXJ0ZWQ7XG5cbiAgICAgICAgICAgIGl0ZW0uc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBzaG91bGRSdW5CZWZvcmVIb29rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYXdhaXQgdGhpcy5fcnVuRml4dHVyZUJlZm9yZUhvb2soaXRlbSwgZml4dHVyZS5nbG9iYWxCZWZvcmVGbiBhcyBGdW5jdGlvbiwgdGVzdFJ1bilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBhd2FpdCB0aGlzLl9ydW5GaXh0dXJlQmVmb3JlSG9vayhpdGVtLCBmaXh0dXJlLmJlZm9yZUZuIGFzIEZ1bmN0aW9uLCB0ZXN0UnVuKTtcblxuICAgICAgICAgICAgLy8gTk9URTogZmFpbCBhbGwgdGVzdHMgaW4gZml4dHVyZSBpZiBmaXh0dXJlLmJlZm9yZSBob29rIGhhcyBlcnJvclxuICAgICAgICAgICAgaWYgKCFzdWNjZXNzICYmIGl0ZW0uZml4dHVyZUJlZm9yZUhvb2tFcnIpIHtcbiAgICAgICAgICAgICAgICB0ZXN0UnVuLnBoYXNlID0gVEVTVF9SVU5fUEhBU0UuaW5GaXh0dXJlQmVmb3JlSG9vaztcblxuICAgICAgICAgICAgICAgIHRlc3RSdW4uYWRkRXJyb3IoaXRlbS5maXh0dXJlQmVmb3JlSG9va0Vycik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRlc3RSdW4uZml4dHVyZUN0eCA9IGl0ZW0uZml4dHVyZUN0eDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBydW5GaXh0dXJlQWZ0ZXJIb29rSWZOZWNlc3NhcnkgKHRlc3RSdW46IFRlc3RSdW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgZml4dHVyZSA9IHRlc3RSdW4udGVzdC5maXh0dXJlIGFzIEZpeHR1cmU7XG4gICAgICAgIGNvbnN0IGl0ZW0gICAgPSB0aGlzLl9nZXRGaXh0dXJlTWFwSXRlbSh0ZXN0UnVuLnRlc3QpO1xuXG4gICAgICAgIGlmICghaXRlbSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpdGVtLnBlbmRpbmdUZXN0UnVuQ291bnQtLTtcblxuICAgICAgICBpZiAoaXRlbS5wZW5kaW5nVGVzdFJ1bkNvdW50ICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuX3J1bkZpeHR1cmVBZnRlckhvb2soaXRlbSwgZml4dHVyZS5hZnRlckZuLCB0ZXN0UnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcnVuRml4dHVyZUFmdGVySG9vayhpdGVtLCBmaXh0dXJlLmdsb2JhbEFmdGVyRm4sIHRlc3RSdW4pO1xuXG4gICAgICAgIGlmIChpdGVtLmZpeHR1cmVDdHgpIHtcbiAgICAgICAgICAgIGF3YWl0IHRlc3RSdW4uY29tcGlsZXJTZXJ2aWNlPy5yZW1vdmVGaXh0dXJlQ3R4c0Zyb21TdGF0ZSh7XG4gICAgICAgICAgICAgICAgZml4dHVyZUlkczogW2ZpeHR1cmUuaWRdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9maXh0dXJlTWFwLmRlbGV0ZShmaXh0dXJlKTtcbiAgICB9XG59XG4iXX0=