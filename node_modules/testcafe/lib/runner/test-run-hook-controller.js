"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const process_test_fn_error_1 = __importDefault(require("../errors/process-test-fn-error"));
const phase_1 = __importDefault(require("../test-run/phase"));
const type_assertions_1 = require("../errors/runtime/type-assertions");
class TestRunHookController {
    constructor(tests, hook) {
        this.beforeFn = hook === null || hook === void 0 ? void 0 : hook.before;
        this.afterFn = hook === null || hook === void 0 ? void 0 : hook.after;
        this.started = false;
        this.runningBeforeHook = false;
        this.beforeHookErr = null;
        this.pendingTestRunCount = tests.length;
        this.testRunCtx = Object.create(null);
        this._assertHooks();
    }
    _assertHooks() {
        if (this.beforeFn)
            type_assertions_1.assertType(type_assertions_1.is.function, 'globalBefore', 'The testRun.globalBefore hook', this.beforeFn);
        if (this.afterFn)
            type_assertions_1.assertType(type_assertions_1.is.function, 'globalAfter', 'The testRun.globalAfter hook', this.afterFn);
    }
    isTestBlocked() {
        return this.runningBeforeHook;
    }
    async runTestRunBeforeHookIfNecessary(testRun) {
        const shouldRunBeforeHook = !this.started && this.beforeFn;
        this.started = true;
        if (shouldRunBeforeHook) {
            this.runningBeforeHook = true;
            try {
                await this.beforeFn(this.testRunCtx);
            }
            catch (err) {
                this.beforeHookErr = process_test_fn_error_1.default(err);
            }
            this.runningBeforeHook = false;
        }
        // NOTE: fail all tests if testRun.before hook has error
        if (this.beforeHookErr) {
            testRun.phase = phase_1.default.inTestRunBeforeHook;
            testRun.addError(this.beforeHookErr);
            return false;
        }
        testRun.testRunCtx = this.testRunCtx;
        return true;
    }
    async runTestRunAfterHookIfNecessary(testRun) {
        this.pendingTestRunCount--;
        if (this.pendingTestRunCount === 0 && this.afterFn) {
            testRun.phase = phase_1.default.inTestRunAfterHook;
            try {
                await this.afterFn(this.testRunCtx);
            }
            catch (err) {
                testRun.addError(process_test_fn_error_1.default(err));
            }
        }
    }
}
exports.default = TestRunHookController;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC1ydW4taG9vay1jb250cm9sbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3J1bm5lci90ZXN0LXJ1bi1ob29rLWNvbnRyb2xsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw0RkFBaUU7QUFFakUsOERBQStDO0FBRS9DLHVFQUFtRTtBQUVuRSxNQUFxQixxQkFBcUI7SUFTdEMsWUFBb0IsS0FBYSxFQUFFLElBQXdCO1FBQ3ZELElBQUksQ0FBQyxRQUFRLEdBQWMsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE1BQU0sQ0FBQztRQUN4QyxJQUFJLENBQUMsT0FBTyxHQUFlLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxLQUFLLENBQUM7UUFDdkMsSUFBSSxDQUFDLE9BQU8sR0FBZSxLQUFLLENBQUM7UUFDakMsSUFBSSxDQUFDLGlCQUFpQixHQUFLLEtBQUssQ0FBQztRQUNqQyxJQUFJLENBQUMsYUFBYSxHQUFTLElBQUksQ0FBQztRQUNoQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUN4QyxJQUFJLENBQUMsVUFBVSxHQUFZLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFL0MsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3hCLENBQUM7SUFFTyxZQUFZO1FBQ2hCLElBQUksSUFBSSxDQUFDLFFBQVE7WUFDYiw0QkFBVSxDQUFDLG9CQUFFLENBQUMsUUFBUSxFQUFFLGNBQWMsRUFBRSwrQkFBK0IsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFNUYsSUFBSSxJQUFJLENBQUMsT0FBTztZQUNaLDRCQUFVLENBQUMsb0JBQUUsQ0FBQyxRQUFRLEVBQUUsYUFBYSxFQUFFLDhCQUE4QixFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM3RixDQUFDO0lBRU0sYUFBYTtRQUNoQixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztJQUNsQyxDQUFDO0lBRU0sS0FBSyxDQUFDLCtCQUErQixDQUFFLE9BQWdCO1FBQzFELE1BQU0sbUJBQW1CLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUM7UUFFM0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFFcEIsSUFBSSxtQkFBbUIsRUFBRTtZQUNyQixJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDO1lBRTlCLElBQUk7Z0JBQ0EsTUFBTyxJQUFJLENBQUMsUUFBcUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDdEQ7WUFDRCxPQUFPLEdBQUcsRUFBRTtnQkFDUixJQUFJLENBQUMsYUFBYSxHQUFHLCtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ2hEO1lBRUQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLEtBQUssQ0FBQztTQUNsQztRQUVELHdEQUF3RDtRQUN4RCxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDcEIsT0FBTyxDQUFDLEtBQUssR0FBRyxlQUFjLENBQUMsbUJBQW1CLENBQUM7WUFFbkQsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFFckMsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxPQUFPLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7UUFFckMsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVNLEtBQUssQ0FBQyw4QkFBOEIsQ0FBRSxPQUFnQjtRQUN6RCxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUUzQixJQUFJLElBQUksQ0FBQyxtQkFBbUIsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNoRCxPQUFPLENBQUMsS0FBSyxHQUFHLGVBQWMsQ0FBQyxrQkFBa0IsQ0FBQztZQUVsRCxJQUFJO2dCQUNBLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDdkM7WUFDRCxPQUFPLEdBQUcsRUFBRTtnQkFDUixPQUFPLENBQUMsUUFBUSxDQUFDLCtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDN0M7U0FDSjtJQUNMLENBQUM7Q0FDSjtBQS9FRCx3Q0ErRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcHJvY2Vzc1Rlc3RGbkVycm9yIGZyb20gJy4uL2Vycm9ycy9wcm9jZXNzLXRlc3QtZm4tZXJyb3InO1xuaW1wb3J0IFRlc3QgZnJvbSAnLi4vYXBpL3N0cnVjdHVyZS90ZXN0JztcbmltcG9ydCBURVNUX1JVTl9QSEFTRSBmcm9tICcuLi90ZXN0LXJ1bi9waGFzZSc7XG5pbXBvcnQgVGVzdFJ1biBmcm9tICcuLi90ZXN0LXJ1bic7XG5pbXBvcnQgeyBhc3NlcnRUeXBlLCBpcyB9IGZyb20gJy4uL2Vycm9ycy9ydW50aW1lL3R5cGUtYXNzZXJ0aW9ucyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlc3RSdW5Ib29rQ29udHJvbGxlciB7XG4gICAgcHVibGljIGJlZm9yZUZuPzogRnVuY3Rpb247XG4gICAgcHVibGljIGFmdGVyRm4/OiBGdW5jdGlvbjtcbiAgICBwdWJsaWMgc3RhcnRlZDogYm9vbGVhbjtcbiAgICBwdWJsaWMgcnVubmluZ0JlZm9yZUhvb2s6IGJvb2xlYW47XG4gICAgcHVibGljIGJlZm9yZUhvb2tFcnI6IG51bGwgfCBFcnJvcjtcbiAgICBwdWJsaWMgcGVuZGluZ1Rlc3RSdW5Db3VudDogbnVtYmVyO1xuICAgIHB1YmxpYyB0ZXN0UnVuQ3R4OiBvYmplY3Q7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IgKHRlc3RzOiBUZXN0W10sIGhvb2s/OiBUZXN0aW5nRW50cnlIb29rcykge1xuICAgICAgICB0aGlzLmJlZm9yZUZuICAgICAgICAgICAgPSBob29rPy5iZWZvcmU7XG4gICAgICAgIHRoaXMuYWZ0ZXJGbiAgICAgICAgICAgICA9IGhvb2s/LmFmdGVyO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgICAgICAgICAgICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ydW5uaW5nQmVmb3JlSG9vayAgID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmVmb3JlSG9va0VyciAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ1Rlc3RSdW5Db3VudCA9IHRlc3RzLmxlbmd0aDtcbiAgICAgICAgdGhpcy50ZXN0UnVuQ3R4ICAgICAgICAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICB0aGlzLl9hc3NlcnRIb29rcygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2Fzc2VydEhvb2tzICgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuYmVmb3JlRm4pXG4gICAgICAgICAgICBhc3NlcnRUeXBlKGlzLmZ1bmN0aW9uLCAnZ2xvYmFsQmVmb3JlJywgJ1RoZSB0ZXN0UnVuLmdsb2JhbEJlZm9yZSBob29rJywgdGhpcy5iZWZvcmVGbik7XG5cbiAgICAgICAgaWYgKHRoaXMuYWZ0ZXJGbilcbiAgICAgICAgICAgIGFzc2VydFR5cGUoaXMuZnVuY3Rpb24sICdnbG9iYWxBZnRlcicsICdUaGUgdGVzdFJ1bi5nbG9iYWxBZnRlciBob29rJywgdGhpcy5hZnRlckZuKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNUZXN0QmxvY2tlZCAoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmdCZWZvcmVIb29rO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBydW5UZXN0UnVuQmVmb3JlSG9va0lmTmVjZXNzYXJ5ICh0ZXN0UnVuOiBUZXN0UnVuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IHNob3VsZFJ1bkJlZm9yZUhvb2sgPSAhdGhpcy5zdGFydGVkICYmIHRoaXMuYmVmb3JlRm47XG5cbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc2hvdWxkUnVuQmVmb3JlSG9vaykge1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nQmVmb3JlSG9vayA9IHRydWU7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgKHRoaXMuYmVmb3JlRm4gYXMgRnVuY3Rpb24pKHRoaXMudGVzdFJ1bkN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iZWZvcmVIb29rRXJyID0gcHJvY2Vzc1Rlc3RGbkVycm9yKGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucnVubmluZ0JlZm9yZUhvb2sgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5PVEU6IGZhaWwgYWxsIHRlc3RzIGlmIHRlc3RSdW4uYmVmb3JlIGhvb2sgaGFzIGVycm9yXG4gICAgICAgIGlmICh0aGlzLmJlZm9yZUhvb2tFcnIpIHtcbiAgICAgICAgICAgIHRlc3RSdW4ucGhhc2UgPSBURVNUX1JVTl9QSEFTRS5pblRlc3RSdW5CZWZvcmVIb29rO1xuXG4gICAgICAgICAgICB0ZXN0UnVuLmFkZEVycm9yKHRoaXMuYmVmb3JlSG9va0Vycik7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlc3RSdW4udGVzdFJ1bkN0eCA9IHRoaXMudGVzdFJ1bkN0eDtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgcnVuVGVzdFJ1bkFmdGVySG9va0lmTmVjZXNzYXJ5ICh0ZXN0UnVuOiBUZXN0UnVuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMucGVuZGluZ1Rlc3RSdW5Db3VudC0tO1xuXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdUZXN0UnVuQ291bnQgPT09IDAgJiYgdGhpcy5hZnRlckZuKSB7XG4gICAgICAgICAgICB0ZXN0UnVuLnBoYXNlID0gVEVTVF9SVU5fUEhBU0UuaW5UZXN0UnVuQWZ0ZXJIb29rO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYWZ0ZXJGbih0aGlzLnRlc3RSdW5DdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRlc3RSdW4uYWRkRXJyb3IocHJvY2Vzc1Rlc3RGbkVycm9yKGVycikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIl19