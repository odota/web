"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertType = exports.is = void 0;
const lodash_1 = require("lodash");
const _1 = require("./");
const types_1 = require("../types");
const hook_1 = __importDefault(require("../../api/request-hooks/hook"));
const test_timeout_1 = __importDefault(require("../../api/structure/test-timeout"));
const START_FROM_VOWEL_RE = /^[aeiou]/i;
function getIndefiniteArticle(text) {
    return START_FROM_VOWEL_RE.test(text) ? 'an' : 'a';
}
function isNonNegativeValue(value) {
    return lodash_1.isFinite(value) && value >= 0;
}
function getNumberTypeActualValueMsg(value, type) {
    if (type !== 'number')
        return type;
    if (Number.isNaN(value))
        return NaN;
    if (!lodash_1.isFinite(value))
        return Infinity;
    return value;
}
function hasSomePropInObject(obj, props) {
    return !!obj &&
        typeof obj === 'object' &&
        props.some(prop => prop in obj);
}
exports.is = {
    number: {
        name: 'number',
        predicate: lodash_1.isFinite,
        getActualValueMsg: getNumberTypeActualValueMsg,
    },
    nonNegativeNumber: {
        name: 'non-negative number',
        predicate: isNonNegativeValue,
        getActualValueMsg: getNumberTypeActualValueMsg,
    },
    nonNegativeNumberString: {
        name: 'non-negative number',
        predicate: value => isNonNegativeValue(parseInt(value, 10)),
        getActualValueMsg: value => {
            const number = parseInt(value, 10);
            return isNaN(number) ? JSON.stringify(value) : number;
        },
    },
    boolean: {
        name: 'boolean',
        predicate: (value, type) => type === 'boolean',
    },
    string: {
        name: 'string',
        predicate: (value, type) => type === 'string',
    },
    function: {
        name: 'function',
        predicate: (value, type) => type === 'function',
    },
    regExp: {
        name: 'regular expression',
        predicate: lodash_1.isRegExp,
    },
    array: {
        name: 'array',
        predicate: value => Array.isArray(value),
    },
    nonNullObject: {
        name: 'non-null object',
        predicate: (value, type) => type === 'object' && !lodash_1.isNil(value),
        getActualValueMsg: (value, type) => lodash_1.isNil(value) ? String(value) : type,
    },
    requestHookSubclass: {
        name: 'RequestHook subclass',
        predicate: value => value instanceof hook_1.default && value.constructor && value.constructor !== hook_1.default,
    },
    clientScriptInitializer: {
        name: 'client script initializer',
        predicate: obj => hasSomePropInObject(obj, ['path', 'content', 'module']),
    },
    testTimeouts: {
        name: 'test timeouts initializer',
        predicate: obj => hasSomePropInObject(obj, Object.keys(test_timeout_1.default)),
    },
};
function assertType(types, callsiteName, what, value) {
    types = lodash_1.castArray(types);
    let pass = false;
    const actualType = typeof value;
    let actualMsg = actualType;
    let expectedTypeMsg = '';
    const last = types.length - 1;
    types.forEach((type, i) => {
        pass = pass || type.predicate(value, actualType);
        if (type.getActualValueMsg)
            actualMsg = type.getActualValueMsg(value, actualType);
        if (i === 0)
            expectedTypeMsg += type.name;
        else
            expectedTypeMsg += (i === last ? ' or ' + getIndefiniteArticle(type.name) + ' ' : ', ') + type.name;
    });
    if (!pass) {
        throw callsiteName ?
            new _1.APIError(callsiteName, types_1.RUNTIME_ERRORS.invalidValueType, what, actualMsg, expectedTypeMsg) :
            new _1.GeneralError(types_1.RUNTIME_ERRORS.invalidValueType, what, actualMsg, expectedTypeMsg);
    }
}
exports.assertType = assertType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS1hc3NlcnRpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Vycm9ycy9ydW50aW1lL3R5cGUtYXNzZXJ0aW9ucy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxtQ0FLZ0I7QUFFaEIseUJBQTRDO0FBQzVDLG9DQUEwQztBQUMxQyx3RUFBdUQ7QUFDdkQsb0ZBQTJEO0FBRTNELE1BQU0sbUJBQW1CLEdBQUcsV0FBVyxDQUFDO0FBRXhDLFNBQVMsb0JBQW9CLENBQUUsSUFBSTtJQUMvQixPQUFPLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDdkQsQ0FBQztBQUVELFNBQVMsa0JBQWtCLENBQUUsS0FBSztJQUM5QixPQUFPLGlCQUFjLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsQ0FBQztBQUMvQyxDQUFDO0FBRUQsU0FBUywyQkFBMkIsQ0FBRSxLQUFLLEVBQUUsSUFBSTtJQUM3QyxJQUFJLElBQUksS0FBSyxRQUFRO1FBQ2pCLE9BQU8sSUFBSSxDQUFDO0lBRWhCLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7UUFDbkIsT0FBTyxHQUFHLENBQUM7SUFFZixJQUFJLENBQUMsaUJBQWMsQ0FBQyxLQUFLLENBQUM7UUFDdEIsT0FBTyxRQUFRLENBQUM7SUFFcEIsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQUVELFNBQVMsbUJBQW1CLENBQUUsR0FBRyxFQUFFLEtBQUs7SUFDcEMsT0FBTyxDQUFDLENBQUMsR0FBRztRQUNSLE9BQU8sR0FBRyxLQUFLLFFBQVE7UUFDdkIsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztBQUN4QyxDQUFDO0FBRVksUUFBQSxFQUFFLEdBQUc7SUFDZCxNQUFN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dCI6WyJpbXBvcnQge1xuICAgIGlzRmluaXRlIGFzIGlzRmluaXRlTnVtYmVyLFxuICAgIGlzUmVnRXhwLFxuICAgIGlzTmlsIGFzIGlzTnVsbE9yVW5kZWZpbmVkLFxuICAgIGNhc3RBcnJheSxcbn0gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IHsgQVBJRXJyb3IsIEdlbmVyYWxFcnJvciB9IGZyb20gJy4vJztcbmltcG9ydCB7IFJVTlRJTUVfRVJST1JTIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IFJlcXVlc3RIb29rIGZyb20gJy4uLy4uL2FwaS9yZXF1ZXN0LWhvb2tzL2hvb2snO1xuaW1wb3J0IFRlc3RUaW1lb3V0IGZyb20gJy4uLy4uL2FwaS9zdHJ1Y3R1cmUvdGVzdC10aW1lb3V0JztcblxuY29uc3QgU1RBUlRfRlJPTV9WT1dFTF9SRSA9IC9eW2FlaW91XS9pO1xuXG5mdW5jdGlvbiBnZXRJbmRlZmluaXRlQXJ0aWNsZSAodGV4dCkge1xuICAgIHJldHVybiBTVEFSVF9GUk9NX1ZPV0VMX1JFLnRlc3QodGV4dCkgPyAnYW4nIDogJ2EnO1xufVxuXG5mdW5jdGlvbiBpc05vbk5lZ2F0aXZlVmFsdWUgKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSA+PSAwO1xufVxuXG5mdW5jdGlvbiBnZXROdW1iZXJUeXBlQWN0dWFsVmFsdWVNc2cgKHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgIT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKVxuICAgICAgICByZXR1cm4gTmFOO1xuXG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcih2YWx1ZSkpXG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gaGFzU29tZVByb3BJbk9iamVjdCAob2JqLCBwcm9wcykge1xuICAgIHJldHVybiAhIW9iaiAmJlxuICAgICAgICB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBwcm9wcy5zb21lKHByb3AgPT4gcHJvcCBpbiBvYmopO1xufVxuXG5leHBvcnQgY29uc3QgaXMgPSB7XG4gICAgbnVtYmVyOiB7XG4gICAgICAgIG5hbWU6ICAgICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgcHJlZGljYXRlOiAgICAgICAgIGlzRmluaXRlTnVtYmVyLFxuICAgICAgICBnZXRBY3R1YWxWYWx1ZU1zZzogZ2V0TnVtYmVyVHlwZUFjdHVhbFZhbHVlTXNnLFxuICAgIH0sXG5cbiAgICBub25OZWdhdGl2ZU51bWJlcjoge1xuICAgICAgICBuYW1lOiAgICAgICAgICAgICAgJ25vbi1uZWdhdGl2ZSBudW1iZXInLFxuICAgICAgICBwcmVkaWNhdGU6ICAgICAgICAgaXNOb25OZWdhdGl2ZVZhbHVlLFxuICAgICAgICBnZXRBY3R1YWxWYWx1ZU1zZzogZ2V0TnVtYmVyVHlwZUFjdHVhbFZhbHVlTXNnLFxuICAgIH0sXG5cbiAgICBub25OZWdhdGl2ZU51bWJlclN0cmluZzoge1xuICAgICAgICBuYW1lOiAgICAgICdub24tbmVnYXRpdmUgbnVtYmVyJyxcbiAgICAgICAgcHJlZGljYXRlOiB2YWx1ZSA9PiBpc05vbk5lZ2F0aXZlVmFsdWUocGFyc2VJbnQodmFsdWUsIDEwKSksXG5cbiAgICAgICAgZ2V0QWN0dWFsVmFsdWVNc2c6IHZhbHVlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG5cbiAgICAgICAgICAgIHJldHVybiBpc05hTihudW1iZXIpID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogbnVtYmVyO1xuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBib29sZWFuOiB7XG4gICAgICAgIG5hbWU6ICAgICAgJ2Jvb2xlYW4nLFxuICAgICAgICBwcmVkaWNhdGU6ICh2YWx1ZSwgdHlwZSkgPT4gdHlwZSA9PT0gJ2Jvb2xlYW4nLFxuICAgIH0sXG5cbiAgICBzdHJpbmc6IHtcbiAgICAgICAgbmFtZTogICAgICAnc3RyaW5nJyxcbiAgICAgICAgcHJlZGljYXRlOiAodmFsdWUsIHR5cGUpID0+IHR5cGUgPT09ICdzdHJpbmcnLFxuICAgIH0sXG5cbiAgICBmdW5jdGlvbjoge1xuICAgICAgICBuYW1lOiAgICAgICdmdW5jdGlvbicsXG4gICAgICAgIHByZWRpY2F0ZTogKHZhbHVlLCB0eXBlKSA9PiB0eXBlID09PSAnZnVuY3Rpb24nLFxuICAgIH0sXG5cbiAgICByZWdFeHA6IHtcbiAgICAgICAgbmFtZTogICAgICAncmVndWxhciBleHByZXNzaW9uJyxcbiAgICAgICAgcHJlZGljYXRlOiBpc1JlZ0V4cCxcbiAgICB9LFxuXG4gICAgYXJyYXk6IHtcbiAgICAgICAgbmFtZTogICAgICAnYXJyYXknLFxuICAgICAgICBwcmVkaWNhdGU6IHZhbHVlID0+IEFycmF5LmlzQXJyYXkodmFsdWUpLFxuICAgIH0sXG5cbiAgICBub25OdWxsT2JqZWN0OiB7XG4gICAgICAgIG5hbWU6ICAgICAgICAgICAgICAnbm9uLW51bGwgb2JqZWN0JyxcbiAgICAgICAgcHJlZGljYXRlOiAgICAgICAgICh2YWx1ZSwgdHlwZSkgPT4gdHlwZSA9PT0gJ29iamVjdCcgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSxcbiAgICAgICAgZ2V0QWN0dWFsVmFsdWVNc2c6ICh2YWx1ZSwgdHlwZSkgPT4gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6IHR5cGUsXG4gICAgfSxcblxuICAgIHJlcXVlc3RIb29rU3ViY2xhc3M6IHtcbiAgICAgICAgbmFtZTogICAgICAnUmVxdWVzdEhvb2sgc3ViY2xhc3MnLFxuICAgICAgICBwcmVkaWNhdGU6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgUmVxdWVzdEhvb2sgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IgIT09IFJlcXVlc3RIb29rLFxuICAgIH0sXG5cbiAgICBjbGllbnRTY3JpcHRJbml0aWFsaXplcjoge1xuICAgICAgICBuYW1lOiAgICAgICdjbGllbnQgc2NyaXB0IGluaXRpYWxpemVyJyxcbiAgICAgICAgcHJlZGljYXRlOiBvYmogPT4gaGFzU29tZVByb3BJbk9iamVjdChvYmosIFsncGF0aCcsICdjb250ZW50JywgJ21vZHVsZSddKSxcbiAgICB9LFxuXG4gICAgdGVzdFRpbWVvdXRzOiB7XG4gICAgICAgIG5hbWU6ICAgICAgJ3Rlc3QgdGltZW91dHMgaW5pdGlhbGl6ZXInLFxuICAgICAgICBwcmVkaWNhdGU6IG9iaiA9PiBoYXNTb21lUHJvcEluT2JqZWN0KG9iaiwgT2JqZWN0LmtleXMoVGVzdFRpbWVvdXQpKSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFR5cGUgKHR5cGVzLCBjYWxsc2l0ZU5hbWUsIHdoYXQsIHZhbHVlKSB7XG4gICAgdHlwZXMgPSBjYXN0QXJyYXkodHlwZXMpO1xuXG4gICAgbGV0IHBhc3MgICAgICAgICAgICA9IGZhbHNlO1xuICAgIGNvbnN0IGFjdHVhbFR5cGUgICAgPSB0eXBlb2YgdmFsdWU7XG4gICAgbGV0IGFjdHVhbE1zZyAgICAgICA9IGFjdHVhbFR5cGU7XG4gICAgbGV0IGV4cGVjdGVkVHlwZU1zZyA9ICcnO1xuICAgIGNvbnN0IGxhc3QgICAgICAgICAgICA9IHR5cGVzLmxlbmd0aCAtIDE7XG5cbiAgICB0eXBlcy5mb3JFYWNoKCh0eXBlLCBpKSA9PiB7XG4gICAgICAgIHBhc3MgPSBwYXNzIHx8IHR5cGUucHJlZGljYXRlKHZhbHVlLCBhY3R1YWxUeXBlKTtcblxuICAgICAgICBpZiAodHlwZS5nZXRBY3R1YWxWYWx1ZU1zZylcbiAgICAgICAgICAgIGFjdHVhbE1zZyA9IHR5cGUuZ2V0QWN0dWFsVmFsdWVNc2codmFsdWUsIGFjdHVhbFR5cGUpO1xuXG4gICAgICAgIGlmIChpID09PSAwKVxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlTXNnICs9IHR5cGUubmFtZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlTXNnICs9IChpID09PSBsYXN0ID8gJyBvciAnICsgZ2V0SW5kZWZpbml0ZUFydGljbGUodHlwZS5uYW1lKSArICcgJyA6ICcsICcpICsgdHlwZS5uYW1lO1xuICAgIH0pO1xuXG4gICAgaWYgKCFwYXNzKSB7XG4gICAgICAgIHRocm93IGNhbGxzaXRlTmFtZSA/XG4gICAgICAgICAgICBuZXcgQVBJRXJyb3IoY2FsbHNpdGVOYW1lLCBSVU5USU1FX0VSUk9SUy5pbnZhbGlkVmFsdWVUeXBlLCB3aGF0LCBhY3R1YWxNc2csIGV4cGVjdGVkVHlwZU1zZykgOlxuICAgICAgICAgICAgbmV3IEdlbmVyYWxFcnJvcihSVU5USU1FX0VSUk9SUy5pbnZhbGlkVmFsdWVUeXBlLCB3aGF0LCBhY3R1YWxNc2csIGV4cGVjdGVkVHlwZU1zZyk7XG4gICAgfVxufVxuIl19