"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = __importDefault(require("os"));
const debug_1 = __importDefault(require("debug"));
const base_1 = __importDefault(require("./base"));
const runtime_1 = require("../../errors/runtime");
const promisified_functions_1 = require("../promisified-functions");
const render_template_1 = __importDefault(require("../../utils/render-template"));
const types_1 = require("../../errors/types");
const warning_message_1 = __importDefault(require("../../notifications/warning-message"));
const DEBUG_LOGGER = debug_1.default('testcafe:utils:get-options:ssl');
const MAX_PATH_LENGTH = {
    'Linux': 4096,
    'Windows_NT': 260,
    'Darwin': 1024,
};
const OS_MAX_PATH_LENGTH = MAX_PATH_LENGTH[os_1.default.type()];
const OPTIONS_SEPARATOR = ';';
const FILE_OPTION_NAMES = ['cert', 'key', 'pfx'];
async function default_1(optionString) {
    return base_1.default(optionString, {
        optionsSeparator: OPTIONS_SEPARATOR,
        async onOptionParsed(key, value) {
            if (!FILE_OPTION_NAMES.includes(key) || value.length > OS_MAX_PATH_LENGTH)
                return value;
            try {
                await promisified_functions_1.stat(value);
            }
            catch (error) {
                DEBUG_LOGGER(render_template_1.default(warning_message_1.default.cannotFindSSLCertFile, value, key, error.stack));
                return value;
            }
            try {
                return await promisified_functions_1.readFile(value);
            }
            catch (error) {
                throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.cannotReadSSLCertFile, key, value, error.stack);
            }
        },
    });
}
exports.default = default_1;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3NsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3V0aWxzL2dldC1vcHRpb25zL3NzbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLDRDQUFvQjtBQUNwQixrREFBMEI7QUFDMUIsa0RBQW9DO0FBQ3BDLGtEQUFvRDtBQUNwRCxvRUFBMEQ7QUFDMUQsa0ZBQXlEO0FBQ3pELDhDQUFvRDtBQUNwRCwwRkFBbUU7QUFHbkUsTUFBTSxZQUFZLEdBQUcsZUFBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7QUFFN0QsTUFBTSxlQUFlLEdBQXVCO0lBQ3hDLE9BQU8sRUFBTyxJQUFJO0lBQ2xCLFlBQVksRUFBRSxHQUFHO0lBQ2pCLFFBQVEsRUFBTSxJQUFJO0NBQ3JCLENBQUM7QUFFRixNQUFNLGtCQUFrQixHQUFHLGVBQWUsQ0FBQyxZQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUV0RCxNQUFNLGlCQUFpQixHQUFHLEdBQUcsQ0FBQztBQUM5QixNQUFNLGlCQUFpQixHQUFHLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztBQUVsQyxLQUFLLG9CQUFXLFlBQW9CO0lBQy9DLE9BQU8sY0FBYyxDQUFDLFlBQVksRUFBRTtRQUNoQyxnQkFBZ0IsRUFBRSxpQkFBaUI7UUFFbkMsS0FBSyxDQUFDLGNBQWMsQ0FBRSxHQUFXLEVBQUUsS0FBYTtZQUM1QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsa0JBQWtCO2dCQUNyRSxPQUFPLEtBQUssQ0FBQztZQUVqQixJQUFJO2dCQUNBLE1BQU0sNEJBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNyQjtZQUNELE9BQU8sS0FBSyxFQUFFO2dCQUNWLFlBQVksQ0FBQyx5QkFBYyxDQUFDLHlCQUFnQixDQUFDLHFCQUFxQixFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBRTlGLE9BQU8sS0FBSyxDQUFDO2FBQ2hCO1lBRUQsSUFBSTtnQkFDQSxPQUFPLE1BQU0sZ0NBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNoQztZQUNELE9BQU8sS0FBSyxFQUFFO2dCQUNWLE1BQU0sSUFBSSxzQkFBWSxDQUFDLHNCQUFjLENBQUMscUJBQXFCLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDekY7UUFDTCxDQUFDO0tBQ0osQ0FBQyxDQUFDO0FBQ1AsQ0FBQztBQXpCRCw0QkF5QkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBiYXNlR2V0T3B0aW9ucyBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgR2VuZXJhbEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzL3J1bnRpbWUnO1xuaW1wb3J0IHsgc3RhdCwgcmVhZEZpbGUgfSBmcm9tICcuLi9wcm9taXNpZmllZC1mdW5jdGlvbnMnO1xuaW1wb3J0IHJlbmRlclRlbXBsYXRlIGZyb20gJy4uLy4uL3V0aWxzL3JlbmRlci10ZW1wbGF0ZSc7XG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uLy4uL2Vycm9ycy90eXBlcyc7XG5pbXBvcnQgV0FSTklOR19NRVNTQUdFUyBmcm9tICcuLi8uLi9ub3RpZmljYXRpb25zL3dhcm5pbmctbWVzc2FnZSc7XG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vLi4vY29uZmlndXJhdGlvbi9pbnRlcmZhY2VzJztcblxuY29uc3QgREVCVUdfTE9HR0VSID0gZGVidWcoJ3Rlc3RjYWZlOnV0aWxzOmdldC1vcHRpb25zOnNzbCcpO1xuXG5jb25zdCBNQVhfUEFUSF9MRU5HVEg6IERpY3Rpb25hcnk8bnVtYmVyPiA9IHtcbiAgICAnTGludXgnOiAgICAgIDQwOTYsXG4gICAgJ1dpbmRvd3NfTlQnOiAyNjAsXG4gICAgJ0Rhcndpbic6ICAgICAxMDI0LFxufTtcblxuY29uc3QgT1NfTUFYX1BBVEhfTEVOR1RIID0gTUFYX1BBVEhfTEVOR1RIW29zLnR5cGUoKV07XG5cbmNvbnN0IE9QVElPTlNfU0VQQVJBVE9SID0gJzsnO1xuY29uc3QgRklMRV9PUFRJT05fTkFNRVMgPSBbJ2NlcnQnLCAna2V5JywgJ3BmeCddO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiAob3B0aW9uU3RyaW5nOiBzdHJpbmcpOiBQcm9taXNlPERpY3Rpb25hcnk8c3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlcj4+IHtcbiAgICByZXR1cm4gYmFzZUdldE9wdGlvbnMob3B0aW9uU3RyaW5nLCB7XG4gICAgICAgIG9wdGlvbnNTZXBhcmF0b3I6IE9QVElPTlNfU0VQQVJBVE9SLFxuXG4gICAgICAgIGFzeW5jIG9uT3B0aW9uUGFyc2VkIChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgICAgICAgICAgaWYgKCFGSUxFX09QVElPTl9OQU1FUy5pbmNsdWRlcyhrZXkpIHx8IHZhbHVlLmxlbmd0aCA+IE9TX01BWF9QQVRIX0xFTkdUSClcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RhdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBERUJVR19MT0dHRVIocmVuZGVyVGVtcGxhdGUoV0FSTklOR19NRVNTQUdFUy5jYW5ub3RGaW5kU1NMQ2VydEZpbGUsIHZhbHVlLCBrZXksIGVycm9yLnN0YWNrKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlYWRGaWxlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMuY2Fubm90UmVhZFNTTENlcnRGaWxlLCBrZXksIHZhbHVlLCBlcnJvci5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbiJdfQ==