"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const async_exit_hook_1 = __importDefault(require("async-exit-hook"));
const tmp_1 = __importDefault(require("tmp"));
const make_dir_1 = __importDefault(require("make-dir"));
const lockfile_1 = __importDefault(require("./lockfile"));
const cleanup_process_1 = __importDefault(require("./cleanup-process"));
const promisified_functions_1 = require("../../utils/promisified-functions");
// NOTE: mutable for testing purposes
const TESTCAFE_TMP_DIRS_ROOT = path_1.default.join(os_1.default.tmpdir(), 'testcafe');
const DEFAULT_NAME_PREFIX = 'tmp';
const USED_TEMP_DIRS = {};
const DEBUG_LOGGER = debug_1.default('testcafe:utils:temp-directory');
class TempDirectory {
    constructor(namePrefix) {
        this.namePrefix = namePrefix || DEFAULT_NAME_PREFIX;
        this.path = '';
        this.lockFile = null;
    }
    async _getTmpDirsList() {
        const tmpDirNames = await promisified_functions_1.readDir(TempDirectory.TEMP_DIRECTORIES_ROOT);
        return tmpDirNames
            .filter(tmpDir => !USED_TEMP_DIRS[tmpDir])
            .filter(tmpDir => path_1.default.basename(tmpDir).startsWith(this.namePrefix));
    }
    async _findFreeTmpDir(tmpDirNames) {
        for (const tmpDirName of tmpDirNames) {
            const tmpDirPath = path_1.default.join(TempDirectory.TEMP_DIRECTORIES_ROOT, tmpDirName);
            const lockFile = new lockfile_1.default(tmpDirPath);
            if (lockFile.init()) {
                this.path = tmpDirPath;
                this.lockFile = lockFile;
                return true;
            }
        }
        return false;
    }
    async _createNewTmpDir() {
        this.path = tmp_1.default.tmpNameSync({ dir: TempDirectory.TEMP_DIRECTORIES_ROOT, prefix: this.namePrefix + '-' });
        await make_dir_1.default(this.path);
        this.lockFile = new lockfile_1.default(this.path);
        this.lockFile.init();
    }
    _disposeSync() {
        if (!USED_TEMP_DIRS[this.path])
            return;
        this.lockFile.dispose();
        delete USED_TEMP_DIRS[this.path];
    }
    static async createDirectory(prefix) {
        const tmpDir = new TempDirectory(prefix);
        await tmpDir.init();
        return tmpDir;
    }
    static disposeDirectoriesSync() {
        Object.values(USED_TEMP_DIRS).forEach(tmpDir => tmpDir._disposeSync());
    }
    async init() {
        await make_dir_1.default(TempDirectory.TEMP_DIRECTORIES_ROOT);
        const tmpDirNames = await this._getTmpDirsList(this.namePrefix);
        DEBUG_LOGGER('Found temp directories:', tmpDirNames);
        const existingTmpDirFound = await this._findFreeTmpDir(tmpDirNames);
        if (!existingTmpDirFound)
            await this._createNewTmpDir();
        DEBUG_LOGGER('Temp directory path: ', this.path);
        await cleanup_process_1.default.init();
        await cleanup_process_1.default.addDirectory(this.path);
        USED_TEMP_DIRS[this.path] = this;
    }
    async dispose() {
        if (!USED_TEMP_DIRS[this.path])
            return;
        this.lockFile.dispose();
        await cleanup_process_1.default.removeDirectory(this.path);
        delete USED_TEMP_DIRS[this.path];
    }
}
exports.default = TempDirectory;
// NOTE: exposed for testing purposes
TempDirectory.TEMP_DIRECTORIES_ROOT = TESTCAFE_TMP_DIRS_ROOT;
async_exit_hook_1.default(TempDirectory.disposeDirectoriesSync);
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvdGVtcC1kaXJlY3RvcnkvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxrREFBMEI7QUFDMUIsNENBQW9CO0FBQ3BCLGdEQUF3QjtBQUN4QixzRUFBNEM7QUFDNUMsOENBQXNCO0FBQ3RCLHdEQUErQjtBQUMvQiwwREFBa0M7QUFDbEMsd0VBQStDO0FBQy9DLDZFQUE0RDtBQUc1RCxxQ0FBcUM7QUFDckMsTUFBTSxzQkFBc0IsR0FBRyxjQUFJLENBQUMsSUFBSSxDQUFDLFlBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUNsRSxNQUFNLG1CQUFtQixHQUFNLEtBQUssQ0FBQztBQUNyQyxNQUFNLGNBQWMsR0FBVyxFQUFFLENBQUM7QUFDbEMsTUFBTSxZQUFZLEdBQWEsZUFBSyxDQUFDLCtCQUErQixDQUFDLENBQUM7QUFFdEUsTUFBcUIsYUFBYTtJQUM5QixZQUFhLFVBQVU7UUFDbkIsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLElBQUksbUJBQW1CLENBQUM7UUFFcEQsSUFBSSxDQUFDLElBQUksR0FBTyxFQUFFLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7SUFDekIsQ0FBQztJQUVELEtBQUssQ0FBQyxlQUFlO1FBQ2pCLE1BQU0sV0FBVyxHQUFHLE1BQU0sK0JBQU8sQ0FBQyxhQUFhLENBQUMscUJBQXFCLENBQUMsQ0FBQztRQUV2RSxPQUFPLFdBQVc7YUFDYixNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUN6QyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxjQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUM3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LENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVoRCxPQUFPLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDckMsQ0FBQztDQUNKO0FBOUZELGdDQThGQztBQUVELHFDQUFxQztBQUNyQyxhQUFhLENBQUMscUJBQXFCLEdBQUcsc0JBQXNCLENBQUM7QUFFN0QseUJBQWEsQ0FBQyxhQUFhLENBQUMsc0JBQXNCLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc2V0dXBFeGl0SG9vayBmcm9tICdhc3luYy1leGl0LWhvb2snO1xuaW1wb3J0IHRtcCBmcm9tICd0bXAnO1xuaW1wb3J0IG1ha2VEaXIgZnJvbSAnbWFrZS1kaXInO1xuaW1wb3J0IExvY2tGaWxlIGZyb20gJy4vbG9ja2ZpbGUnO1xuaW1wb3J0IGNsZWFudXBQcm9jZXNzIGZyb20gJy4vY2xlYW51cC1wcm9jZXNzJztcbmltcG9ydCB7IHJlYWREaXIgfSBmcm9tICcuLi8uLi91dGlscy9wcm9taXNpZmllZC1mdW5jdGlvbnMnO1xuXG5cbi8vIE5PVEU6IG11dGFibGUgZm9yIHRlc3RpbmcgcHVycG9zZXNcbmNvbnN0IFRFU1RDQUZFX1RNUF9ESVJTX1JPT1QgPSBwYXRoLmpvaW4ob3MudG1wZGlyKCksICd0ZXN0Y2FmZScpO1xuY29uc3QgREVGQVVMVF9OQU1FX1BSRUZJWCAgICA9ICd0bXAnO1xuY29uc3QgVVNFRF9URU1QX0RJUlMgICAgICAgICA9IHt9O1xuY29uc3QgREVCVUdfTE9HR0VSICAgICAgICAgICA9IGRlYnVnKCd0ZXN0Y2FmZTp1dGlsczp0ZW1wLWRpcmVjdG9yeScpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZW1wRGlyZWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvciAobmFtZVByZWZpeCkge1xuICAgICAgICB0aGlzLm5hbWVQcmVmaXggPSBuYW1lUHJlZml4IHx8IERFRkFVTFRfTkFNRV9QUkVGSVg7XG5cbiAgICAgICAgdGhpcy5wYXRoICAgICA9ICcnO1xuICAgICAgICB0aGlzLmxvY2tGaWxlID0gbnVsbDtcbiAgICB9XG5cbiAgICBhc3luYyBfZ2V0VG1wRGlyc0xpc3QgKCkge1xuICAgICAgICBjb25zdCB0bXBEaXJOYW1lcyA9IGF3YWl0IHJlYWREaXIoVGVtcERpcmVjdG9yeS5URU1QX0RJUkVDVE9SSUVTX1JPT1QpO1xuXG4gICAgICAgIHJldHVybiB0bXBEaXJOYW1lc1xuICAgICAgICAgICAgLmZpbHRlcih0bXBEaXIgPT4gIVVTRURfVEVNUF9ESVJTW3RtcERpcl0pXG4gICAgICAgICAgICAuZmlsdGVyKHRtcERpciA9PiBwYXRoLmJhc2VuYW1lKHRtcERpcikuc3RhcnRzV2l0aCh0aGlzLm5hbWVQcmVmaXgpKTtcbiAgICB9XG5cbiAgICBhc3luYyBfZmluZEZyZWVUbXBEaXIgKHRtcERpck5hbWVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgdG1wRGlyTmFtZSBvZiB0bXBEaXJOYW1lcykge1xuICAgICAgICAgICAgY29uc3QgdG1wRGlyUGF0aCA9IHBhdGguam9pbihUZW1wRGlyZWN0b3J5LlRFTVBfRElSRUNUT1JJRVNfUk9PVCwgdG1wRGlyTmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGxvY2tGaWxlID0gbmV3IExvY2tGaWxlKHRtcERpclBhdGgpO1xuXG4gICAgICAgICAgICBpZiAobG9ja0ZpbGUuaW5pdCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoICAgICA9IHRtcERpclBhdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NrRmlsZSA9IGxvY2tGaWxlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYXN5bmMgX2NyZWF0ZU5ld1RtcERpciAoKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHRtcC50bXBOYW1lU3luYyh7IGRpcjogVGVtcERpcmVjdG9yeS5URU1QX0RJUkVDVE9SSUVTX1JPT1QsIHByZWZpeDogdGhpcy5uYW1lUHJlZml4ICsgJy0nIH0pO1xuXG4gICAgICAgIGF3YWl0IG1ha2VEaXIodGhpcy5wYXRoKTtcblxuICAgICAgICB0aGlzLmxvY2tGaWxlID0gbmV3IExvY2tGaWxlKHRoaXMucGF0aCk7XG5cbiAgICAgICAgdGhpcy5sb2NrRmlsZS5pbml0KCk7XG4gICAgfVxuXG4gICAgX2Rpc3Bvc2VTeW5jICgpIHtcbiAgICAgICAgaWYgKCFVU0VEX1RFTVBfRElSU1t0aGlzLnBhdGhdKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMubG9ja0ZpbGUuZGlzcG9zZSgpO1xuXG4gICAgICAgIGRlbGV0ZSBVU0VEX1RFTVBfRElSU1t0aGlzLnBhdGhdO1xuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGVEaXJlY3RvcnkgKHByZWZpeCkge1xuICAgICAgICBjb25zdCB0bXBEaXIgPSBuZXcgVGVtcERpcmVjdG9yeShwcmVmaXgpO1xuXG4gICAgICAgIGF3YWl0IHRtcERpci5pbml0KCk7XG5cbiAgICAgICAgcmV0dXJuIHRtcERpcjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGlzcG9zZURpcmVjdG9yaWVzU3luYyAoKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoVVNFRF9URU1QX0RJUlMpLmZvckVhY2godG1wRGlyID0+IHRtcERpci5fZGlzcG9zZVN5bmMoKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgaW5pdCAoKSB7XG4gICAgICAgIGF3YWl0IG1ha2VEaXIoVGVtcERpcmVjdG9yeS5URU1QX0RJUkVDVE9SSUVTX1JPT1QpO1xuXG4gICAgICAgIGNvbnN0IHRtcERpck5hbWVzID0gYXdhaXQgdGhpcy5fZ2V0VG1wRGlyc0xpc3QodGhpcy5uYW1lUHJlZml4KTtcblxuICAgICAgICBERUJVR19MT0dHRVIoJ0ZvdW5kIHRlbXAgZGlyZWN0b3JpZXM6JywgdG1wRGlyTmFtZXMpO1xuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVG1wRGlyRm91bmQgPSBhd2FpdCB0aGlzLl9maW5kRnJlZVRtcERpcih0bXBEaXJOYW1lcyk7XG5cbiAgICAgICAgaWYgKCFleGlzdGluZ1RtcERpckZvdW5kKVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY3JlYXRlTmV3VG1wRGlyKCk7XG5cbiAgICAgICAgREVCVUdfTE9HR0VSKCdUZW1wIGRpcmVjdG9yeSBwYXRoOiAnLCB0aGlzLnBhdGgpO1xuXG4gICAgICAgIGF3YWl0IGNsZWFudXBQcm9jZXNzLmluaXQoKTtcbiAgICAgICAgYXdhaXQgY2xlYW51cFByb2Nlc3MuYWRkRGlyZWN0b3J5KHRoaXMucGF0aCk7XG5cbiAgICAgICAgVVNFRF9URU1QX0RJUlNbdGhpcy5wYXRoXSA9IHRoaXM7XG4gICAgfVxuXG4gICAgYXN5bmMgZGlzcG9zZSAoKSB7XG4gICAgICAgIGlmICghVVNFRF9URU1QX0RJUlNbdGhpcy5wYXRoXSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aGlzLmxvY2tGaWxlLmRpc3Bvc2UoKTtcblxuICAgICAgICBhd2FpdCBjbGVhbnVwUHJvY2Vzcy5yZW1vdmVEaXJlY3RvcnkodGhpcy5wYXRoKTtcblxuICAgICAgICBkZWxldGUgVVNFRF9URU1QX0RJUlNbdGhpcy5wYXRoXTtcbiAgICB9XG59XG5cbi8vIE5PVEU6IGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXNcblRlbXBEaXJlY3RvcnkuVEVNUF9ESVJFQ1RPUklFU19ST09UID0gVEVTVENBRkVfVE1QX0RJUlNfUk9PVDtcblxuc2V0dXBFeGl0SG9vayhUZW1wRGlyZWN0b3J5LmRpc3Bvc2VEaXJlY3Rvcmllc1N5bmMpO1xuIl19