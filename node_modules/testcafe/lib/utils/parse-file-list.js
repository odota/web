"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const globby_1 = __importDefault(require("globby"));
const is_glob_1 = __importDefault(require("is-glob"));
const compiler_1 = __importDefault(require("../compiler"));
const os_family_1 = __importDefault(require("os-family"));
const lodash_1 = require("lodash");
const promisified_functions_1 = require("../utils/promisified-functions");
const DEFAULT_TEST_LOOKUP_DIRS = ['test', 'tests'];
const TEST_FILE_GLOB_PATTERN = `./**/*@(${compiler_1.default.getSupportedTestFileExtensions().join('|')})`;
const GLOB_POSIX_SLASH_ENDING = '*' + path_1.default.posix.sep;
function modifyFileRoot(baseDir, file) {
    const absPath = path_1.default.resolve(baseDir, file);
    const fileIsOnOtherDrive = path_1.default.isAbsolute(path_1.default.relative(baseDir, file));
    if (!path_1.default.isAbsolute(file) || fileIsOnOtherDrive)
        return file;
    const { root, dir, base } = path_1.default.parse(absPath);
    return path_1.default.join(path_1.default.parse(baseDir).root, path_1.default.relative(root, dir), base);
}
async function getDefaultDirs(baseDir) {
    return await globby_1.default(DEFAULT_TEST_LOOKUP_DIRS, {
        cwd: baseDir,
        absolute: true,
        caseSensitiveMatch: false,
        expandDirectories: false,
        onlyDirectories: true,
        suppressErrors: true,
    });
}
// NOTE: glob patterns can only contain forward-slashes (https://github.com/sindresorhus/globby#api)
function ensurePosix(fileString) {
    return fileString.split(path_1.default.win32.sep).join(path_1.default.posix.sep);
}
async function convertDirsToGlobs(fileList, baseDir) {
    fileList = await Promise.all(fileList.map(async (file) => {
        if (!is_glob_1.default(file)) {
            const absPath = path_1.default.resolve(baseDir, file);
            let fileStat = null;
            try {
                fileStat = await promisified_functions_1.stat(absPath);
            }
            catch (err) {
                return null;
            }
            if (fileStat.isDirectory()) {
                file = path_1.default.join(file, TEST_FILE_GLOB_PATTERN);
                return ensurePosix(file);
            }
            if (os_family_1.default.win)
                file = modifyFileRoot(baseDir, file);
        }
        // TODO: remove this workaround after resolving https://github.com/mrmlnc/fast-glob/issues/290
        else {
            file = ensurePosix(file);
            if (file.endsWith(GLOB_POSIX_SLASH_ENDING))
                return file.slice(0, -1);
        }
        return ensurePosix(file);
    }));
    return fileList.filter(file => !!file);
}
async function getFiles(globTask) {
    const files = await globby_1.default(globTask.pattern, globTask.options);
    return files.sort((fileA, fileB) => fileA.localeCompare(fileB));
}
async function execFileGlobs(globs, baseDir) {
    // NOTE: We have to create glob tasks, execute them and sort their results separately to preserve the same item order
    // as in the older globby versions (<7.1.1)
    const tasks = globby_1.default.generateGlobTasks(globs, { cwd: baseDir, expandDirectories: false, onlyFiles: true });
    const files = await Promise.all(tasks.map(getFiles));
    return lodash_1.flatten(files);
}
async function parseFileList(fileList, baseDir) {
    if (lodash_1.isEmpty(fileList))
        fileList = await getDefaultDirs(baseDir);
    fileList = await convertDirsToGlobs(fileList, baseDir);
    fileList = await execFileGlobs(fileList, baseDir);
    return fileList.map(file => path_1.default.resolve(baseDir, file));
}
exports.default = parseFileList;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UtZmlsZS1saXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL3BhcnNlLWZpbGUtbGlzdC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdEQUF3QjtBQUN4QixvREFBNEI7QUFDNUIsc0RBQTZCO0FBQzdCLDJEQUFtQztBQUNuQywwREFBMkI7QUFDM0IsbUNBQTBDO0FBQzFDLDBFQUFzRDtBQUd0RCxNQUFNLHdCQUF3QixHQUFHLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ25ELE1BQU0sc0JBQXNCLEdBQUssV0FBVyxrQkFBUSxDQUFDLDhCQUE4QixFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7QUFDbkcsTUFBTSx1QkFBdUIsR0FBSSxHQUFHLEdBQUcsY0FBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUM7QUFFdEQsU0FBUyxjQUFjLENBQUUsT0FBTyxFQUFFLElBQUk7SUFDbEMsTUFBTSxPQUFPLEdBQWMsY0FBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDdkQsTUFBTSxrQkFBa0IsR0FBRyxjQUFJLENBQUMsVUFBVSxDQUFDLGNBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7SUFFekUsSUFBSSxDQUFDLGNBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksa0JBQWtCO1FBQzVDLE9BQU8sSUFBSSxDQUFDO0lBRWhCLE1BQU0sRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLGNBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFaEQsT0FBTyxjQUFJLENBQUMsSUFBSSxDQUFDLGNBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLGNBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FB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QUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFFckQsT0FBTyxnQkFBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzFCLENBQUM7QUFFYyxLQUFLLFVBQVUsYUFBYSxDQUFFLFFBQVEsRUFBRSxPQUFPO0lBQzFELElBQUksZ0JBQU8sQ0FBQyxRQUFRLENBQUM7UUFDakIsUUFBUSxHQUFHLE1BQU0sY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRTdDLFFBQVEsR0FBRyxNQUFNLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN2RCxRQUFRLEdBQUcsTUFBTSxhQUFhLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRWxELE9BQU8sUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGNBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDN0QsQ0FBQztBQVJELGdDQVFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgZ2xvYmJ5IGZyb20gJ2dsb2JieSc7XG5pbXBvcnQgaXNHbG9iIGZyb20gJ2lzLWdsb2InO1xuaW1wb3J0IENvbXBpbGVyIGZyb20gJy4uL2NvbXBpbGVyJztcbmltcG9ydCBPUyBmcm9tICdvcy1mYW1pbHknO1xuaW1wb3J0IHsgaXNFbXB0eSwgZmxhdHRlbiB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBzdGF0IH0gZnJvbSAnLi4vdXRpbHMvcHJvbWlzaWZpZWQtZnVuY3Rpb25zJztcblxuXG5jb25zdCBERUZBVUxUX1RFU1RfTE9PS1VQX0RJUlMgPSBbJ3Rlc3QnLCAndGVzdHMnXTtcbmNvbnN0IFRFU1RfRklMRV9HTE9CX1BBVFRFUk4gICA9IGAuLyoqLypAKCR7Q29tcGlsZXIuZ2V0U3VwcG9ydGVkVGVzdEZpbGVFeHRlbnNpb25zKCkuam9pbignfCcpfSlgO1xuY29uc3QgR0xPQl9QT1NJWF9TTEFTSF9FTkRJTkcgID0gJyonICsgcGF0aC5wb3NpeC5zZXA7XG5cbmZ1bmN0aW9uIG1vZGlmeUZpbGVSb290IChiYXNlRGlyLCBmaWxlKSB7XG4gICAgY29uc3QgYWJzUGF0aCAgICAgICAgICAgID0gcGF0aC5yZXNvbHZlKGJhc2VEaXIsIGZpbGUpO1xuICAgIGNvbnN0IGZpbGVJc09uT3RoZXJEcml2ZSA9IHBhdGguaXNBYnNvbHV0ZShwYXRoLnJlbGF0aXZlKGJhc2VEaXIsIGZpbGUpKTtcblxuICAgIGlmICghcGF0aC5pc0Fic29sdXRlKGZpbGUpIHx8IGZpbGVJc09uT3RoZXJEcml2ZSlcbiAgICAgICAgcmV0dXJuIGZpbGU7XG5cbiAgICBjb25zdCB7IHJvb3QsIGRpciwgYmFzZSB9ID0gcGF0aC5wYXJzZShhYnNQYXRoKTtcblxuICAgIHJldHVybiBwYXRoLmpvaW4ocGF0aC5wYXJzZShiYXNlRGlyKS5yb290LCBwYXRoLnJlbGF0aXZlKHJvb3QsIGRpciksIGJhc2UpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXREZWZhdWx0RGlycyAoYmFzZURpcikge1xuICAgIHJldHVybiBhd2FpdCBnbG9iYnkoREVGQVVMVF9URVNUX0xPT0tVUF9ESVJTLCB7XG4gICAgICAgIGN3ZDogICAgICAgICAgICAgICAgYmFzZURpcixcbiAgICAgICAgYWJzb2x1dGU6ICAgICAgICAgICB0cnVlLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlTWF0Y2g6IGZhbHNlLFxuICAgICAgICBleHBhbmREaXJlY3RvcmllczogIGZhbHNlLFxuICAgICAgICBvbmx5RGlyZWN0b3JpZXM6ICAgIHRydWUsXG4gICAgICAgIHN1cHByZXNzRXJyb3JzOiAgICAgdHJ1ZSxcbiAgICB9KTtcbn1cblxuLy8gTk9URTogZ2xvYiBwYXR0ZXJucyBjYW4gb25seSBjb250YWluIGZvcndhcmQtc2xhc2hlcyAoaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9nbG9iYnkjYXBpKVxuZnVuY3Rpb24gZW5zdXJlUG9zaXggKGZpbGVTdHJpbmcpIHtcbiAgICByZXR1cm4gZmlsZVN0cmluZy5zcGxpdChwYXRoLndpbjMyLnNlcCkuam9pbihwYXRoLnBvc2l4LnNlcCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnREaXJzVG9HbG9icyAoZmlsZUxpc3QsIGJhc2VEaXIpIHtcbiAgICBmaWxlTGlzdCA9IGF3YWl0IFByb21pc2UuYWxsKGZpbGVMaXN0Lm1hcChhc3luYyBmaWxlID0+IHtcbiAgICAgICAgaWYgKCFpc0dsb2IoZmlsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFic1BhdGggPSBwYXRoLnJlc29sdmUoYmFzZURpciwgZmlsZSk7XG4gICAgICAgICAgICBsZXQgZmlsZVN0YXQgID0gbnVsbDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmaWxlU3RhdCA9IGF3YWl0IHN0YXQoYWJzUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaWxlU3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgZmlsZSA9IHBhdGguam9pbihmaWxlLCBURVNUX0ZJTEVfR0xPQl9QQVRURVJOKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBlbnN1cmVQb3NpeChmaWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9TLndpbilcbiAgICAgICAgICAgICAgICBmaWxlID0gbW9kaWZ5RmlsZVJvb3QoYmFzZURpciwgZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgd29ya2Fyb3VuZCBhZnRlciByZXNvbHZpbmcgaHR0cHM6Ly9naXRodWIuY29tL21ybWxuYy9mYXN0LWdsb2IvaXNzdWVzLzI5MFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbGUgPSBlbnN1cmVQb3NpeChmaWxlKTtcblxuICAgICAgICAgICAgaWYgKGZpbGUuZW5kc1dpdGgoR0xPQl9QT1NJWF9TTEFTSF9FTkRJTkcpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbnN1cmVQb3NpeChmaWxlKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZmlsZUxpc3QuZmlsdGVyKGZpbGUgPT4gISFmaWxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZXMgKGdsb2JUYXNrKSB7XG4gICAgY29uc3QgZmlsZXMgPSBhd2FpdCBnbG9iYnkoZ2xvYlRhc2sucGF0dGVybiwgZ2xvYlRhc2sub3B0aW9ucyk7XG5cbiAgICByZXR1cm4gZmlsZXMuc29ydCgoZmlsZUEsIGZpbGVCKSA9PiBmaWxlQS5sb2NhbGVDb21wYXJlKGZpbGVCKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4ZWNGaWxlR2xvYnMgKGdsb2JzLCBiYXNlRGlyKSB7XG4gICAgLy8gTk9URTogV2UgaGF2ZSB0byBjcmVhdGUgZ2xvYiB0YXNrcywgZXhlY3V0ZSB0aGVtIGFuZCBzb3J0IHRoZWlyIHJlc3VsdHMgc2VwYXJhdGVseSB0byBwcmVzZXJ2ZSB0aGUgc2FtZSBpdGVtIG9yZGVyXG4gICAgLy8gYXMgaW4gdGhlIG9sZGVyIGdsb2JieSB2ZXJzaW9ucyAoPDcuMS4xKVxuICAgIGNvbnN0IHRhc2tzID0gZ2xvYmJ5LmdlbmVyYXRlR2xvYlRhc2tzKGdsb2JzLCB7IGN3ZDogYmFzZURpciwgZXhwYW5kRGlyZWN0b3JpZXM6IGZhbHNlLCBvbmx5RmlsZXM6IHRydWUgfSk7XG4gICAgY29uc3QgZmlsZXMgPSBhd2FpdCBQcm9taXNlLmFsbCh0YXNrcy5tYXAoZ2V0RmlsZXMpKTtcblxuICAgIHJldHVybiBmbGF0dGVuKGZpbGVzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGFyc2VGaWxlTGlzdCAoZmlsZUxpc3QsIGJhc2VEaXIpIHtcbiAgICBpZiAoaXNFbXB0eShmaWxlTGlzdCkpXG4gICAgICAgIGZpbGVMaXN0ID0gYXdhaXQgZ2V0RGVmYXVsdERpcnMoYmFzZURpcik7XG5cbiAgICBmaWxlTGlzdCA9IGF3YWl0IGNvbnZlcnREaXJzVG9HbG9icyhmaWxlTGlzdCwgYmFzZURpcik7XG4gICAgZmlsZUxpc3QgPSBhd2FpdCBleGVjRmlsZUdsb2JzKGZpbGVMaXN0LCBiYXNlRGlyKTtcblxuICAgIHJldHVybiBmaWxlTGlzdC5tYXAoZmlsZSA9PiBwYXRoLnJlc29sdmUoYmFzZURpciwgZmlsZSkpO1xufVxuIl19