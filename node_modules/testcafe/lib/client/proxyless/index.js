(function () {
    var nativeMethods = {
        Function: window.Function,
        Node: window.Node,
        Promise: window.Promise,
        NodeList: window.NodeList,
        HTMLCollection: window.HTMLCollection,
        elementClass: window.Element,
        svgElementClass: window.SVGElement,
        objectKeys: window.Object.keys,
        objectAssign: window.Object.assign,
        objectToString: window.Object.prototype.toString,
        objectGetPrototypeOf: window.Object.getPrototypeOf,
        // eslint-disable-next-line no-restricted-properties
        dateNow: window.Date.now,
        isArray: window.Array.isArray,
        arrayFilter: window.Array.prototype.filter,
        setTimeout: window.setTimeout,
        closest: window.Element.prototype.closest,
        matches: window.Element.prototype.matches,
        getAttribute: window.Element.prototype.getAttribute,
        querySelector: window.HTMLElement.prototype.querySelector,
        querySelectorAll: window.HTMLElement.prototype.querySelectorAll,
        scrollTo: window.scrollTo,
        // @ts-ignore
        contentWindowGetter: window.Object.getOwnPropertyDescriptor(window.HTMLIFrameElement.prototype, 'contentWindow').get,
    };

    // @ts-ignore
    var emptyAdapter = {};
    function initializeAdapter(initializer) {
        // eslint-disable-next-line no-restricted-globals
        var keys = Object.keys(initializer);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            // @ts-ignore
            emptyAdapter[key] = initializer[key];
        }
    }

    initializeAdapter({
        PromiseCtor: nativeMethods.Promise,
        controller: {
            waitForScroll: function () {
                var result = nativeMethods.Promise.resolve();
                // @ts-ignore
                result.cancel = function () { };
                return result;
            },
        },
    });

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var replicator = createCommonjsModule(function (module) {
    // Const
    var TRANSFORMED_TYPE_KEY    = '@t';
    var CIRCULAR_REF_KEY        = '@r';
    var KEY_REQUIRE_ESCAPING_RE = /^#*@(t|r)$/;

    var GLOBAL = (function getGlobal () {
        // NOTE: see http://www.ecma-international.org/ecma-262/6.0/index.html#sec-performeval step 10
        var savedEval = eval;

        return savedEval('this');
    })();

    var TYPED_ARRAY_CTORS = {
        'Int8Array':         typeof Int8Array === 'function' ? Int8Array : void 0,
        'Uint8Array':        typeof Uint8Array === 'function' ? Uint8Array : void 0,
        'Uint8ClampedArray': typeof Uint8ClampedArray === 'function' ? Uint8ClampedArray : void 0,
        'Int16Array':        typeof Int16Array === 'function' ? Int16Array : void 0,
        'Uint16Array':       typeof Uint16Array === 'function' ? Uint16Array : void 0,
        'Int32Array':        typeof Int32Array === 'function' ? Int32Array : void 0,
        'Uint32Array':       typeof Uint32Array === 'function' ? Uint32Array : void 0,
        'Float32Array':      typeof Float32Array === 'function' ? Float32Array : void 0,
        'Float64Array':      typeof Float64Array === 'function' ? Float64Array : void 0
    };

    var ARRAY_BUFFER_SUPPORTED = typeof ArrayBuffer === 'function';
    var MAP_SUPPORTED          = typeof Map === 'function';
    var SET_SUPPORTED          = typeof Set === 'function';
    var BUFFER_FROM_SUPPORTED  = typeof Buffer === 'function';

    var TYPED_ARRAY_SUPPORTED  = function (typeName) {
        return !!TYPED_ARRAY_CTORS[typeName];
    };

    // Saved proto functions
    var arrSlice = Array.prototype.slice;


    // Default serializer
    var JSONSerializer = {
        serialize: function (val) {
            return JSON.stringify(val);
        },

        deserialize: function (val) {
            return JSON.parse(val);
        }
    };


    // EncodingTransformer
    var EncodingTransformer = function (val, transforms) {
        this.references               = val;
        this.transforms               = transforms;
        this.circularCandidates       = [];
        this.circularCandidatesDescrs = [];
        this.circularRefCount         = 0;
    };

    EncodingTransformer._createRefMark = function (idx) {
        var obj = Object.create(null);

        obj[CIRCULAR_REF_KEY] = idx;

        return obj;
    };

    EncodingTransformer.prototype._createCircularCandidate = function (val, parent, key) {
        this.circularCandidates.push(val);
        this.circularCandidatesDescrs.push({ parent: parent, key: key, refIdx: -1 });
    };

    EncodingTransformer.prototype._applyTransform = function (val, parent, key, transform) {
        var result          = Object.create(null);
        var serializableVal = transform.toSerializable(val);

        if (typeof serializableVal === 'object')
            this._createCircularCandidate(val, parent, key);

        result[TRANSFORMED_TYPE_KEY] = transform.type;
        result.data                  = this._handleValue(serializableVal, parent, key);

        return result;
    };

    EncodingTransformer.prototype._handleArray = function (arr) {
        var result = [];

        for (var i = 0; i < arr.length; i++)
            result[i] = this._handleValue(arr[i], result, i);

        return result;
    };

    EncodingTransformer.prototype._handlePlainObject = function (obj) {
        var replicator       = this;
        var result           = Object.create(null);
        var ownPropertyNames = Object.getOwnPropertyNames(obj);

        ownPropertyNames.forEach(function (key) {
            var resultKey = KEY_REQUIRE_ESCAPING_RE.test(key) ? '#' + key : key;

            result[resultKey] = replicator._handleValue(obj[key], result, resultKey);
        });

        return result;
    };

    EncodingTransformer.prototype._handleObject = function (obj, parent, key) {
        this._createCircularCandidate(obj, parent, key);

        return Array.isArray(obj) ? this._handleArray(obj) : this._handlePlainObject(obj);
    };

    EncodingTransformer.prototype._ensureCircularReference = function (obj) {
        var circularCandidateIdx = this.circularCandidates.indexOf(obj);

        if (circularCandidateIdx > -1) {
            var descr = this.circularCandidatesDescrs[circularCandidateIdx];

            if (descr.refIdx === -1)
                descr.refIdx = descr.parent ? ++this.circularRefCount : 0;

            return EncodingTransformer._createRefMark(descr.refIdx);
        }

        return null;
    };

    EncodingTransformer.prototype._handleValue = function (val, parent, key) {
        var type     = typeof val;
        var isObject = type === 'object' && val !== null;

        if (isObject) {
            var refMark = this._ensureCircularReference(val);

            if (refMark)
                return refMark;
        }

        for (var i = 0; i < this.transforms.length; i++) {
            var transform = this.transforms[i];

            if (transform.shouldTransform(type, val))
                return this._applyTransform(val, parent, key, transform);
        }

        if (isObject)
            return this._handleObject(val, parent, key);

        return val;
    };

    EncodingTransformer.prototype.transform = function () {
        var references = [this._handleValue(this.references, null, null)];

        for (var i = 0; i < this.circularCandidatesDescrs.length; i++) {
            var descr = this.circularCandidatesDescrs[i];

            if (descr.refIdx > 0) {
                references[descr.refIdx] = descr.parent[descr.key];
                descr.parent[descr.key]  = EncodingTransformer._createRefMark(descr.refIdx);
            }
        }

        return references;
    };

    // DecodingTransform
    var DecodingTransformer = function (references, transformsMap) {
        this.references            = references;
        this.transformMap          = transformsMap;
        this.activeTransformsStack = [];
        this.visitedRefs           = Object.create(null);
    };

    DecodingTransformer.prototype._handlePlainObject = function (obj) {
        var replicator       = this;
        var unescaped        = Object.create(null);
        var ownPropertyNames = Object.getOwnPropertyNames(obj);

        ownPropertyNames.forEach(function (key) {
            replicator._handleValue(obj[key], obj, key);

            if (KEY_REQUIRE_ESCAPING_RE.test(key)) {
                // NOTE: use intermediate object to avoid unescaped and escaped keys interference
                // E.g. unescaped "##@t" will be "#@t" which can overwrite escaped "#@t".
                unescaped[key.substring(1)] = obj[key];
                delete obj[key];
            }
        });

        for (var unsecapedKey in unescaped)
            obj[unsecapedKey] = unescaped[unsecapedKey];
    };

    DecodingTransformer.prototype._handleTransformedObject = function (obj, parent, key) {
        var transformType = obj[TRANSFORMED_TYPE_KEY];
        var transform     = this.transformMap[transformType];

        if (!transform)
            throw new Error('Can\'t find transform for "' + transformType + '" type.');

        this.activeTransformsStack.push(obj);
        this._handleValue(obj.data, obj, 'data');
        this.activeTransformsStack.pop();

        parent[key] = transform.fromSerializable(obj.data);
    };

    DecodingTransformer.prototype._handleCircularSelfRefDuringTransform = function (refIdx, parent, key) {
        // NOTE: we've hit a hard case: object reference itself during transformation.
        // We can't dereference it since we don't have resulting object yet. And we'll
        // not be able to restore reference lately because we will need to traverse
        // transformed object again and reference might be unreachable or new object contain
        // new circular references. As a workaround we create getter, so once transformation
        // complete, dereferenced property will point to correct transformed object.
        var references = this.references;
        var val = void 0;

        Object.defineProperty(parent, key, {
            configurable: true,
            enumerable:   true,

            get: function () {
                if (val === void 0)
                    val = references[refIdx];

                return val;
            },

            set: function (value) {
                val = value;
                return val;
            }
        });
    };

    DecodingTransformer.prototype._handleCircularRef = function (refIdx, parent, key) {
        if (this.activeTransformsStack.indexOf(this.references[refIdx]) > -1)
            this._handleCircularSelfRefDuringTransform(refIdx, parent, key);

        else {
            if (!this.visitedRefs[refIdx]) {
                this.visitedRefs[refIdx] = true;
                this._handleValue(this.references[refIdx], this.references, refIdx);
            }

            parent[key] = this.references[refIdx];
        }
    };

    DecodingTransformer.prototype._handleValue = function (val, parent, key) {
        if (typeof val !== 'object' || val === null)
            return;

        var refIdx = val[CIRCULAR_REF_KEY];

        if (refIdx !== void 0)
            this._handleCircularRef(refIdx, parent, key);

        else if (val[TRANSFORMED_TYPE_KEY])
            this._handleTransformedObject(val, parent, key);

        else if (Array.isArray(val)) {
            for (var i = 0; i < val.length; i++)
                this._handleValue(val[i], val, i);
        }

        else
            this._handlePlainObject(val);
    };

    DecodingTransformer.prototype.transform = function () {
        this.visitedRefs[0] = true;
        this._handleValue(this.references[0], this.references, 0);

        return this.references[0];
    };


    // Transforms
    var builtInTransforms = [
        {
            type: '[[NaN]]',

            shouldTransform: function (type, val) {
                return type === 'number' && isNaN(val);
            },

            toSerializable: function () {
                return '';
            },

            fromSerializable: function () {
                return NaN;
            }
        },

        {
            type: '[[undefined]]',

            shouldTransform: function (type) {
                return type === 'undefined';
            },

            toSerializable: function () {
                return '';
            },

            fromSerializable: function () {
                return void 0;
            }
        },
        {
            type: '[[Date]]',

            shouldTransform: function (type, val) {
                return val instanceof Date;
            },

            toSerializable: function (date) {
                return date.getTime();
            },

            fromSerializable: function (val) {
                var date = new Date();

                date.setTime(val);
                return date;
            }
        },
        {
            type: '[[RegExp]]',

            shouldTransform: function (type, val) {
                return val instanceof RegExp;
            },

            toSerializable: function (re) {
                var result = {
                    src:   re.source,
                    flags: ''
                };

                if (re.global)
                    result.flags += 'g';

                if (re.ignoreCase)
                    result.flags += 'i';

                if (re.multiline)
                    result.flags += 'm';

                return result;
            },

            fromSerializable: function (val) {
                return new RegExp(val.src, val.flags);
            }
        },

        {
            type: '[[Error]]',

            shouldTransform: function (type, val) {
                return val instanceof Error;
            },

            toSerializable: function (err) {
                return {
                    name:    err.name,
                    message: err.message,
                    stack:   err.stack
                };
            },

            fromSerializable: function (val) {
                var Ctor = GLOBAL[val.name] || Error;
                var err  = new Ctor(val.message);

                err.stack = val.stack;
                return err;
            }
        },

        {
            type: '[[ArrayBuffer]]',

            shouldTransform: function (type, val) {
                return ARRAY_BUFFER_SUPPORTED && val instanceof ArrayBuffer;
            },

            toSerializable: function (buffer) {
                var view = new Int8Array(buffer);

                return arrSlice.call(view);
            },

            fromSerializable: function (val) {
                if (ARRAY_BUFFER_SUPPORTED) {
                    var buffer = new ArrayBuffer(val.length);
                    var view   = new Int8Array(buffer);

                    view.set(val);

                    return buffer;
                }

                return val;
            }
        },

        {
            type: '[[Buffer]]',

            shouldTransform: function (type, val) {
                return BUFFER_FROM_SUPPORTED && val instanceof Buffer;
            },

            toSerializable: function (buffer) {
                return arrSlice.call(buffer);
            },

            fromSerializable: function (val) {
                if (BUFFER_FROM_SUPPORTED)
                    return Buffer.from(val);

                return val;
            }
        },

        {
            type: '[[TypedArray]]',

            shouldTransform: function (type, val) {
                return Object.keys(TYPED_ARRAY_CTORS).some(function (ctorName) {
                    return TYPED_ARRAY_SUPPORTED(ctorName) && val instanceof TYPED_ARRAY_CTORS[ctorName];
                });
            },

            toSerializable: function (arr) {
                return {
                    ctorName: arr.constructor.name,
                    arr:      arrSlice.call(arr)
                };
            },

            fromSerializable: function (val) {
                return TYPED_ARRAY_SUPPORTED(val.ctorName) ? new TYPED_ARRAY_CTORS[val.ctorName](val.arr) : val.arr;
            }
        },

        {
            type: '[[Map]]',

            shouldTransform: function (type, val) {
                return MAP_SUPPORTED && val instanceof Map;
            },

            toSerializable: function (map) {
                var flattenedKVArr = [];

                map.forEach(function (val, key) {
                    flattenedKVArr.push(key);
                    flattenedKVArr.push(val);
                });

                return flattenedKVArr;
            },

            fromSerializable: function (val) {
                if (MAP_SUPPORTED) {
                    // NOTE: new Map(iterable) is not supported by all browsers
                    var map = new Map();

                    for (var i = 0; i < val.length; i += 2)
                        map.set(val[i], val[i + 1]);

                    return map;
                }

                var kvArr = [];

                for (var j = 0; j < val.length; j += 2)
                    kvArr.push([val[i], val[i + 1]]);

                return kvArr;
            }
        },

        {
            type: '[[Set]]',

            shouldTransform: function (type, val) {
                return SET_SUPPORTED && val instanceof Set;
            },

            toSerializable: function (set) {
                var arr = [];

                set.forEach(function (val) {
                    arr.push(val);
                });

                return arr;
            },

            fromSerializable: function (val) {
                if (SET_SUPPORTED) {
                    // NOTE: new Set(iterable) is not supported by all browsers
                    var set = new Set();

                    for (var i = 0; i < val.length; i++)
                        set.add(val[i]);

                    return set;
                }

                return val;
            }
        }
    ];

    // Replicator
    var Replicator = module.exports = function (serializer) {
        this.transforms    = [];
        this.transformsMap = Object.create(null);
        this.serializer    = serializer || JSONSerializer;

        this.addTransforms(builtInTransforms);
    };

    // Manage transforms
    Replicator.prototype.addTransforms = function (transforms) {
        transforms = Array.isArray(transforms) ? transforms : [transforms];

        for (var i = 0; i < transforms.length; i++) {
            var transform = transforms[i];

            if (this.transformsMap[transform.type])
                throw new Error('Transform with type "' + transform.type + '" was already added.');

            this.transforms.push(transform);
            this.transformsMap[transform.type] = transform;
        }

        return this;
    };

    Replicator.prototype.removeTransforms = function (transforms) {
        transforms = Array.isArray(transforms) ? transforms : [transforms];

        for (var i = 0; i < transforms.length; i++) {
            var transform = transforms[i];
            var idx       = this.transforms.indexOf(transform);

            if (idx > -1)
                this.transforms.splice(idx, 1);

            delete this.transformsMap[transform.type];
        }

        return this;
    };

    Replicator.prototype.encode = function (val) {
        var transformer = new EncodingTransformer(val, this.transforms);
        var references  = transformer.transform();

        return this.serializer.serialize(references);
    };

    Replicator.prototype.decode = function (val) {
        var references  = this.serializer.deserialize(val);
        var transformer = new DecodingTransformer(references, this.transformsMap);

        return transformer.transform();
    };
    });

    var identity = function (val) { return val; };
    function createReplicator(transforms) {
        // NOTE: we will serialize replicator results
        // to JSON with a command or command result.
        // Therefore there is no need to do additional job here,
        // so we use identity functions for serialization.
        var replicator$1 = new replicator({
            serialize: identity,
            deserialize: identity,
        });
        return replicator$1.addTransforms(transforms);
    }

    var PENDING = 'pending';
    var SETTLED = 'settled';
    var FULFILLED = 'fulfilled';
    var REJECTED = 'rejected';
    var NOOP = function () {};
    var isNode = typeof commonjsGlobal !== 'undefined' && typeof commonjsGlobal.process !== 'undefined' && typeof commonjsGlobal.process.emit === 'function';

    var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
    var asyncQueue = [];
    var asyncTimer;

    function asyncFlush() {
    	// run promise callbacks
    	for (var i = 0; i < asyncQueue.length; i++) {
    		asyncQueue[i][0](asyncQueue[i][1]);
    	}

    	// reset async asyncQueue
    	asyncQueue = [];
    	asyncTimer = false;
    }

    function asyncCall(callback, arg) {
    	asyncQueue.push([callback, arg]);

    	if (!asyncTimer) {
    		asyncTimer = true;
    		asyncSetTimer(asyncFlush, 0);
    	}
    }

    function invokeResolver(resolver, promise) {
    	function resolvePromise(value) {
    		resolve(promise, value);
    	}

    	function rejectPromise(reason) {
    		reject(promise, reason);
    	}

    	try {
    		resolver(resolvePromise, rejectPromise);
    	} catch (e) {
    		rejectPromise(e);
    	}
    }

    function invokeCallback(subscriber) {
    	var owner = subscriber.owner;
    	var settled = owner._state;
    	var value = owner._data;
    	var callback = subscriber[settled];
    	var promise = subscriber.then;

    	if (typeof callback === 'function') {
    		settled = FULFILLED;
    		try {
    			value = callback(value);
    		} catch (e) {
    			reject(promise, e);
    		}
    	}

    	if (!handleThenable(promise, value)) {
    		if (settled === FULFILLED) {
    			resolve(promise, value);
    		}

    		if (settled === REJECTED) {
    			reject(promise, value);
    		}
    	}
    }

    function handleThenable(promise, value) {
    	var resolved;

    	try {
    		if (promise === value) {
    			throw new TypeError('A promises callback cannot return that same promise.');
    		}

    		if (value && (typeof value === 'function' || typeof value === 'object')) {
    			// then should be retrieved only once
    			var then = value.then;

    			if (typeof then === 'function') {
    				then.call(value, function (val) {
    					if (!resolved) {
    						resolved = true;

    						if (value === val) {
    							fulfill(promise, val);
    						} else {
    							resolve(promise, val);
    						}
    					}
    				}, function (reason) {
    					if (!resolved) {
    						resolved = true;

    						reject(promise, reason);
    					}
    				});

    				return true;
    			}
    		}
    	} catch (e) {
    		if (!resolved) {
    			reject(promise, e);
    		}

    		return true;
    	}

    	return false;
    }

    function resolve(promise, value) {
    	if (promise === value || !handleThenable(promise, value)) {
    		fulfill(promise, value);
    	}
    }

    function fulfill(promise, value) {
    	if (promise._state === PENDING) {
    		promise._state = SETTLED;
    		promise._data = value;

    		asyncCall(publishFulfillment, promise);
    	}
    }

    function reject(promise, reason) {
    	if (promise._state === PENDING) {
    		promise._state = SETTLED;
    		promise._data = reason;

    		asyncCall(publishRejection, promise);
    	}
    }

    function publish(promise) {
    	promise._then = promise._then.forEach(invokeCallback);
    }

    function publishFulfillment(promise) {
    	promise._state = FULFILLED;
    	publish(promise);
    }

    function publishRejection(promise) {
    	promise._state = REJECTED;
    	publish(promise);
    	if (!promise._handled && isNode) {
    		commonjsGlobal.process.emit('unhandledRejection', promise._data, promise);
    	}
    }

    function notifyRejectionHandled(promise) {
    	commonjsGlobal.process.emit('rejectionHandled', promise);
    }

    /**
     * @class
     */
    function Promise(resolver) {
    	if (typeof resolver !== 'function') {
    		throw new TypeError('Promise resolver ' + resolver + ' is not a function');
    	}

    	if (this instanceof Promise === false) {
    		throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
    	}

    	this._then = [];

    	invokeResolver(resolver, this);
    }

    Promise.prototype = {
    	constructor: Promise,

    	_state: PENDING,
    	_then: null,
    	_data: undefined,
    	_handled: false,

    	then: function (onFulfillment, onRejection) {
    		var subscriber = {
    			owner: this,
    			then: new this.constructor(NOOP),
    			fulfilled: onFulfillment,
    			rejected: onRejection
    		};

    		if ((onRejection || onFulfillment) && !this._handled) {
    			this._handled = true;
    			if (this._state === REJECTED && isNode) {
    				asyncCall(notifyRejectionHandled, this);
    			}
    		}

    		if (this._state === FULFILLED || this._state === REJECTED) {
    			// already resolved, call callback async
    			asyncCall(invokeCallback, subscriber);
    		} else {
    			// subscribe
    			this._then.push(subscriber);
    		}

    		return subscriber.then;
    	},

    	catch: function (onRejection) {
    		return this.then(null, onRejection);
    	}
    };

    Promise.all = function (promises) {
    	if (!Array.isArray(promises)) {
    		throw new TypeError('You must pass an array to Promise.all().');
    	}

    	return new Promise(function (resolve, reject) {
    		var results = [];
    		var remaining = 0;

    		function resolver(index) {
    			remaining++;
    			return function (value) {
    				results[index] = value;
    				if (!--remaining) {
    					resolve(results);
    				}
    			};
    		}

    		for (var i = 0, promise; i < promises.length; i++) {
    			promise = promises[i];

    			if (promise && typeof promise.then === 'function') {
    				promise.then(resolver(i), reject);
    			} else {
    				results[i] = promise;
    			}
    		}

    		if (!remaining) {
    			resolve(results);
    		}
    	});
    };

    Promise.race = function (promises) {
    	if (!Array.isArray(promises)) {
    		throw new TypeError('You must pass an array to Promise.race().');
    	}

    	return new Promise(function (resolve, reject) {
    		for (var i = 0, promise; i < promises.length; i++) {
    			promise = promises[i];

    			if (promise && typeof promise.then === 'function') {
    				promise.then(resolve, reject);
    			} else {
    				resolve(promise);
    			}
    		}
    	});
    };

    Promise.resolve = function (value) {
    	if (value && typeof value === 'object' && value.constructor === Promise) {
    		return value;
    	}

    	return new Promise(function (resolve) {
    		resolve(value);
    	});
    };

    Promise.reject = function (reason) {
    	return new Promise(function (resolve, reject) {
    		reject(reason);
    	});
    };

    var pinkie = Promise;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = pinkie))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    // -------------------------------------------------------------
    // WARNING: this file is used by both the client and the server.
    // Do not use any browser or node-specific API!
    // -------------------------------------------------------------
    var TEST_RUN_ERRORS = {
        uncaughtErrorOnPage: 'E1',
        uncaughtErrorInTestCode: 'E2',
        uncaughtNonErrorObjectInTestCode: 'E3',
        uncaughtErrorInClientFunctionCode: 'E4',
        uncaughtErrorInCustomDOMPropertyCode: 'E5',
        unhandledPromiseRejection: 'E6',
        uncaughtException: 'E7',
        missingAwaitError: 'E8',
        actionIntegerOptionError: 'E9',
        actionPositiveIntegerOptionError: 'E10',
        actionBooleanOptionError: 'E11',
        actionSpeedOptionError: 'E12',
        actionOptionsTypeError: 'E14',
        actionBooleanArgumentError: 'E15',
        actionStringArgumentError: 'E16',
        actionNullableStringArgumentError: 'E17',
        actionStringOrStringArrayArgumentError: 'E18',
        actionStringArrayElementError: 'E19',
        actionIntegerArgumentError: 'E20',
        actionRoleArgumentError: 'E21',
        actionPositiveIntegerArgumentError: 'E22',
        actionSelectorError: 'E23',
        actionElementNotFoundError: 'E24',
        actionElementIsInvisibleError: 'E26',
        actionSelectorMatchesWrongNodeTypeError: 'E27',
        actionAdditionalElementNotFoundError: 'E28',
        actionAdditionalElementIsInvisibleError: 'E29',
        actionAdditionalSelectorMatchesWrongNodeTypeError: 'E30',
        actionElementNonEditableError: 'E31',
        actionElementNotTextAreaError: 'E32',
        actionElementNonContentEditableError: 'E33',
        actionElementIsNotFileInputError: 'E34',
        actionRootContainerNotFoundError: 'E35',
        actionIncorrectKeysError: 'E36',
        actionCannotFindFileToUploadError: 'E37',
        actionUnsupportedDeviceTypeError: 'E38',
        actionIframeIsNotLoadedError: 'E39',
        actionElementNotIframeError: 'E40',
        actionInvalidScrollTargetError: 'E41',
        currentIframeIsNotLoadedError: 'E42',
        currentIframeNotFoundError: 'E43',
        currentIframeIsInvisibleError: 'E44',
        nativeDialogNotHandledError: 'E45',
        uncaughtErrorInNativeDialogHandler: 'E46',
        setTestSpeedArgumentError: 'E47',
        setNativeDialogHandlerCodeWrongTypeError: 'E48',
        clientFunctionExecutionInterruptionError: 'E49',
        domNodeClientFunctionResultError: 'E50',
        invalidSelectorResultError: 'E51',
        cannotObtainInfoForElementSpecifiedBySelectorError: 'E52',
        externalAssertionLibraryError: 'E53',
        pageLoadError: 'E54',
        windowDimensionsOverflowError: 'E55',
        forbiddenCharactersInScreenshotPathError: 'E56',
        invalidElementScreenshotDimensionsError: 'E57',
        roleSwitchInRoleInitializerError: 'E58',
        assertionExecutableArgumentError: 'E59',
        assertionWithoutMethodCallError: 'E60',
        assertionUnawaitedPromiseError: 'E61',
        requestHookNotImplementedError: 'E62',
        requestHookUnhandledError: 'E63',
        uncaughtErrorInCustomClientScriptCode: 'E64',
        uncaughtErrorInCustomClientScriptCodeLoadedFromModule: 'E65',
        uncaughtErrorInCustomScript: 'E66',
        uncaughtTestCafeErrorInCustomScript: 'E67',
        childWindowIsNotLoadedError: 'E68',
        childWindowNotFoundError: 'E69',
        cannotSwitchToWindowError: 'E70',
        closeChildWindowError: 'E71',
        childWindowClosedBeforeSwitchingError: 'E72',
        cannotCloseWindowWithChildrenError: 'E73',
        targetWindowNotFoundError: 'E74',
        parentWindowNotFoundError: 'E76',
        previousWindowNotFoundError: 'E77',
        switchToWindowPredicateError: 'E78',
        actionFunctionArgumentError: 'E79',
        multipleWindowsModeIsDisabledError: 'E80',
        multipleWindowsModeIsNotSupportedInRemoteBrowserError: 'E81',
        cannotCloseWindowWithoutParent: 'E82',
        cannotRestoreChildWindowError: 'E83',
        executionTimeoutExceeded: 'E84',
        actionRequiredCookieArguments: 'E85',
        actionCookieArgumentError: 'E86',
        actionCookieArgumentsError: 'E87',
        actionUrlCookieArgumentError: 'E88',
        actionUrlsCookieArgumentError: 'E89',
        actionStringOptionError: 'E90',
        actionDateOptionError: 'E91',
        actionNumberOptionError: 'E92',
    };

    // Base
    //--------------------------------------------------------------------
    var TestRunErrorBase = /** @class */ (function () {
        function TestRunErrorBase(code, callsite) {
            this.code = code;
            this.isTestCafeError = true;
            this.callsite = callsite || null;
        }
        return TestRunErrorBase;
    }());
    var ActionOptionErrorBase = /** @class */ (function (_super) {
        __extends(ActionOptionErrorBase, _super);
        function ActionOptionErrorBase(code, optionName, actualValue) {
            var _this = _super.call(this, code) || this;
            _this.optionName = optionName;
            _this.actualValue = actualValue;
            return _this;
        }
        return ActionOptionErrorBase;
    }(TestRunErrorBase));
    // Client function errors
    //--------------------------------------------------------------------
    var ClientFunctionExecutionInterruptionError = /** @class */ (function (_super) {
        __extends(ClientFunctionExecutionInterruptionError, _super);
        function ClientFunctionExecutionInterruptionError(instantiationCallsiteName, callsite) {
            var _this = _super.call(this, TEST_RUN_ERRORS.clientFunctionExecutionInterruptionError, callsite) || this;
            _this.instantiationCallsiteName = instantiationCallsiteName;
            return _this;
        }
        return ClientFunctionExecutionInterruptionError;
    }(TestRunErrorBase));
    var DomNodeClientFunctionResultError = /** @class */ (function (_super) {
        __extends(DomNodeClientFunctionResultError, _super);
        function DomNodeClientFunctionResultError(instantiationCallsiteName, callsite) {
            var _this = _super.call(this, TEST_RUN_ERRORS.domNodeClientFunctionResultError, callsite) || this;
            _this.instantiationCallsiteName = instantiationCallsiteName;
            return _this;
        }
        return DomNodeClientFunctionResultError;
    }(TestRunErrorBase));
    // Selector errors
    //--------------------------------------------------------------------
    var SelectorErrorBase = /** @class */ (function (_super) {
        __extends(SelectorErrorBase, _super);
        function SelectorErrorBase(code, _a, callsite) {
            var apiFnChain = _a.apiFnChain, apiFnIndex = _a.apiFnIndex;
            var _this = _super.call(this, code, callsite) || this;
            _this.apiFnChain = apiFnChain;
            _this.apiFnIndex = apiFnIndex;
            return _this;
        }
        return SelectorErrorBase;
    }(TestRunErrorBase));
    var InvalidSelectorResultError = /** @class */ (function (_super) {
        __extends(InvalidSelectorResultError, _super);
        function InvalidSelectorResultError(callsite) {
            return _super.call(this, TEST_RUN_ERRORS.invalidSelectorResultError, callsite) || this;
        }
        return InvalidSelectorResultError;
    }(TestRunErrorBase));
    var CannotObtainInfoForElementSpecifiedBySelectorError = /** @class */ (function (_super) {
        __extends(CannotObtainInfoForElementSpecifiedBySelectorError, _super);
        function CannotObtainInfoForElementSpecifiedBySelectorError(callsite, apiFnArgs) {
            return _super.call(this, TEST_RUN_ERRORS.cannotObtainInfoForElementSpecifiedBySelectorError, apiFnArgs, callsite) || this;
        }
        return CannotObtainInfoForElementSpecifiedBySelectorError;
    }(SelectorErrorBase));
    // Uncaught errors
    //--------------------------------------------------------------------
    var UncaughtErrorOnPage = /** @class */ (function (_super) {
        __extends(UncaughtErrorOnPage, _super);
        function UncaughtErrorOnPage(errStack, pageDestUrl) {
            var _this = _super.call(this, TEST_RUN_ERRORS.uncaughtErrorOnPage) || this;
            _this.errStack = errStack;
            _this.pageDestUrl = pageDestUrl;
            return _this;
        }
        return UncaughtErrorOnPage;
    }(TestRunErrorBase));
    var UncaughtErrorInClientFunctionCode = /** @class */ (function (_super) {
        __extends(UncaughtErrorInClientFunctionCode, _super);
        function UncaughtErrorInClientFunctionCode(instantiationCallsiteName, err, callsite) {
            var _this = _super.call(this, TEST_RUN_ERRORS.uncaughtErrorInClientFunctionCode, callsite) || this;
            _this.errMsg = String(err);
            _this.instantiationCallsiteName = instantiationCallsiteName;
            return _this;
        }
        return UncaughtErrorInClientFunctionCode;
    }(TestRunErrorBase));
    var UncaughtErrorInCustomDOMPropertyCode = /** @class */ (function (_super) {
        __extends(UncaughtErrorInCustomDOMPropertyCode, _super);
        function UncaughtErrorInCustomDOMPropertyCode(instantiationCallsiteName, err, prop, callsite) {
            var _this = _super.call(this, TEST_RUN_ERRORS.uncaughtErrorInCustomDOMPropertyCode, callsite) || this;
            _this.errMsg = String(err);
            _this.property = prop;
            _this.instantiationCallsiteName = instantiationCallsiteName;
            return _this;
        }
        return UncaughtErrorInCustomDOMPropertyCode;
    }(TestRunErrorBase));
    var UncaughtErrorInCustomClientScriptCode = /** @class */ (function (_super) {
        __extends(UncaughtErrorInCustomClientScriptCode, _super);
        function UncaughtErrorInCustomClientScriptCode(err) {
            var _this = _super.call(this, TEST_RUN_ERRORS.uncaughtErrorInCustomClientScriptCode) || this;
            _this.errMsg = String(err);
            return _this;
        }
        return UncaughtErrorInCustomClientScriptCode;
    }(TestRunErrorBase));
    var UncaughtErrorInCustomClientScriptLoadedFromModule = /** @class */ (function (_super) {
        __extends(UncaughtErrorInCustomClientScriptLoadedFromModule, _super);
        function UncaughtErrorInCustomClientScriptLoadedFromModule(err, moduleName) {
            var _this = _super.call(this, TEST_RUN_ERRORS.uncaughtErrorInCustomClientScriptCodeLoadedFromModule) || this;
            _this.errMsg = String(err);
            _this.moduleName = moduleName;
            return _this;
        }
        return UncaughtErrorInCustomClientScriptLoadedFromModule;
    }(TestRunErrorBase));
    // Action parameters errors
    //--------------------------------------------------------------------
    // Options errors
    //--------------------------------------------------------------------
    var ActionIntegerOptionError = /** @class */ (function (_super) {
        __extends(ActionIntegerOptionError, _super);
        function ActionIntegerOptionError(optionName, actualValue) {
            return _super.call(this, TEST_RUN_ERRORS.actionIntegerOptionError, optionName, actualValue) || this;
        }
        return ActionIntegerOptionError;
    }(ActionOptionErrorBase));
    var ActionPositiveIntegerOptionError = /** @class */ (function (_super) {
        __extends(ActionPositiveIntegerOptionError, _super);
        function ActionPositiveIntegerOptionError(optionName, actualValue) {
            return _super.call(this, TEST_RUN_ERRORS.actionPositiveIntegerOptionError, optionName, actualValue) || this;
        }
        return ActionPositiveIntegerOptionError;
    }(ActionOptionErrorBase));
    var ActionBooleanOptionError = /** @class */ (function (_super) {
        __extends(ActionBooleanOptionError, _super);
        function ActionBooleanOptionError(optionName, actualValue) {
            return _super.call(this, TEST_RUN_ERRORS.actionBooleanOptionError, optionName, actualValue) || this;
        }
        return ActionBooleanOptionError;
    }(ActionOptionErrorBase));
    var ActionSpeedOptionError = /** @class */ (function (_super) {
        __extends(ActionSpeedOptionError, _super);
        function ActionSpeedOptionError(optionName, actualValue) {
            return _super.call(this, TEST_RUN_ERRORS.actionSpeedOptionError, optionName, actualValue) || this;
        }
        return ActionSpeedOptionError;
    }(ActionOptionErrorBase));
    var ActionStringOptionError = /** @class */ (function (_super) {
        __extends(ActionStringOptionError, _super);
        function ActionStringOptionError(optionName, actualValue) {
            return _super.call(this, TEST_RUN_ERRORS.actionStringOptionError, optionName, actualValue) || this;
        }
        return ActionStringOptionError;
    }(ActionOptionErrorBase));
    var ActionDateOptionError = /** @class */ (function (_super) {
        __extends(ActionDateOptionError, _super);
        function ActionDateOptionError(optionName, actualValue) {
            return _super.call(this, TEST_RUN_ERRORS.actionDateOptionError, optionName, actualValue) || this;
        }
        return ActionDateOptionError;
    }(ActionOptionErrorBase));
    var ActionNumberOptionError = /** @class */ (function (_super) {
        __extends(ActionNumberOptionError, _super);
        function ActionNumberOptionError(optionName, actualValue) {
            return _super.call(this, TEST_RUN_ERRORS.actionNumberOptionError, optionName, actualValue) || this;
        }
        return ActionNumberOptionError;
    }(ActionOptionErrorBase));
    // Action execution errors
    //--------------------------------------------------------------------
    var ActionElementNotFoundError = /** @class */ (function (_super) {
        __extends(ActionElementNotFoundError, _super);
        function ActionElementNotFoundError(callsite, apiFnArgs) {
            return _super.call(this, TEST_RUN_ERRORS.actionElementNotFoundError, apiFnArgs, callsite) || this;
        }
        return ActionElementNotFoundError;
    }(SelectorErrorBase));
    var ActionElementIsInvisibleError = /** @class */ (function (_super) {
        __extends(ActionElementIsInvisibleError, _super);
        function ActionElementIsInvisibleError(callsite) {
            return _super.call(this, TEST_RUN_ERRORS.actionElementIsInvisibleError, callsite) || this;
        }
        return ActionElementIsInvisibleError;
    }(TestRunErrorBase));
    var ActionSelectorMatchesWrongNodeTypeError = /** @class */ (function (_super) {
        __extends(ActionSelectorMatchesWrongNodeTypeError, _super);
        function ActionSelectorMatchesWrongNodeTypeError(nodeDescription) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionSelectorMatchesWrongNodeTypeError) || this;
            _this.nodeDescription = nodeDescription;
            return _this;
        }
        return ActionSelectorMatchesWrongNodeTypeError;
    }(TestRunErrorBase));
    var ActionAdditionalElementNotFoundError = /** @class */ (function (_super) {
        __extends(ActionAdditionalElementNotFoundError, _super);
        function ActionAdditionalElementNotFoundError(argumentName, apiFnArgs) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionAdditionalElementNotFoundError, apiFnArgs) || this;
            _this.argumentName = argumentName;
            return _this;
        }
        return ActionAdditionalElementNotFoundError;
    }(SelectorErrorBase));
    var ActionAdditionalElementIsInvisibleError = /** @class */ (function (_super) {
        __extends(ActionAdditionalElementIsInvisibleError, _super);
        function ActionAdditionalElementIsInvisibleError(argumentName) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionAdditionalElementIsInvisibleError) || this;
            _this.argumentName = argumentName;
            return _this;
        }
        return ActionAdditionalElementIsInvisibleError;
    }(TestRunErrorBase));
    var ActionAdditionalSelectorMatchesWrongNodeTypeError = /** @class */ (function (_super) {
        __extends(ActionAdditionalSelectorMatchesWrongNodeTypeError, _super);
        function ActionAdditionalSelectorMatchesWrongNodeTypeError(argumentName, nodeDescription) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionAdditionalSelectorMatchesWrongNodeTypeError) || this;
            _this.argumentName = argumentName;
            _this.nodeDescription = nodeDescription;
            return _this;
        }
        return ActionAdditionalSelectorMatchesWrongNodeTypeError;
    }(TestRunErrorBase));
    var ActionElementNonEditableError = /** @class */ (function (_super) {
        __extends(ActionElementNonEditableError, _super);
        function ActionElementNonEditableError() {
            return _super.call(this, TEST_RUN_ERRORS.actionElementNonEditableError) || this;
        }
        return ActionElementNonEditableError;
    }(TestRunErrorBase));
    var ActionElementNotTextAreaError = /** @class */ (function (_super) {
        __extends(ActionElementNotTextAreaError, _super);
        function ActionElementNotTextAreaError() {
            return _super.call(this, TEST_RUN_ERRORS.actionElementNotTextAreaError) || this;
        }
        return ActionElementNotTextAreaError;
    }(TestRunErrorBase));
    var ActionElementNonContentEditableError = /** @class */ (function (_super) {
        __extends(ActionElementNonContentEditableError, _super);
        function ActionElementNonContentEditableError(argumentName) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionElementNonContentEditableError) || this;
            _this.argumentName = argumentName;
            return _this;
        }
        return ActionElementNonContentEditableError;
    }(TestRunErrorBase));
    var ActionRootContainerNotFoundError = /** @class */ (function (_super) {
        __extends(ActionRootContainerNotFoundError, _super);
        function ActionRootContainerNotFoundError() {
            return _super.call(this, TEST_RUN_ERRORS.actionRootContainerNotFoundError) || this;
        }
        return ActionRootContainerNotFoundError;
    }(TestRunErrorBase));
    var ActionIncorrectKeysError = /** @class */ (function (_super) {
        __extends(ActionIncorrectKeysError, _super);
        function ActionIncorrectKeysError(argumentName) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionIncorrectKeysError) || this;
            _this.argumentName = argumentName;
            return _this;
        }
        return ActionIncorrectKeysError;
    }(TestRunErrorBase));
    var ActionCannotFindFileToUploadError = /** @class */ (function (_super) {
        __extends(ActionCannotFindFileToUploadError, _super);
        function ActionCannotFindFileToUploadError(filePaths, scannedFilePaths) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionCannotFindFileToUploadError) || this;
            _this.filePaths = filePaths;
            _this.scannedFilePaths = scannedFilePaths;
            return _this;
        }
        return ActionCannotFindFileToUploadError;
    }(TestRunErrorBase));
    var ActionElementIsNotFileInputError = /** @class */ (function (_super) {
        __extends(ActionElementIsNotFileInputError, _super);
        function ActionElementIsNotFileInputError() {
            return _super.call(this, TEST_RUN_ERRORS.actionElementIsNotFileInputError) || this;
        }
        return ActionElementIsNotFileInputError;
    }(TestRunErrorBase));
    var ActionInvalidScrollTargetError = /** @class */ (function (_super) {
        __extends(ActionInvalidScrollTargetError, _super);
        function ActionInvalidScrollTargetError(scrollTargetXValid, scrollTargetYValid) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionInvalidScrollTargetError) || this;
            if (!scrollTargetXValid) {
                if (!scrollTargetYValid)
                    _this.properties = 'scrollTargetX and scrollTargetY properties';
                else
                    _this.properties = 'scrollTargetX property';
            }
            else
                _this.properties = 'scrollTargetY property';
            return _this;
        }
        return ActionInvalidScrollTargetError;
    }(TestRunErrorBase));
    var InvalidElementScreenshotDimensionsError = /** @class */ (function (_super) {
        __extends(InvalidElementScreenshotDimensionsError, _super);
        function InvalidElementScreenshotDimensionsError(width, height) {
            var _this = _super.call(this, TEST_RUN_ERRORS.invalidElementScreenshotDimensionsError) || this;
            var widthIsInvalid = width <= 0;
            var heightIsInvalid = height <= 0;
            if (widthIsInvalid) {
                if (heightIsInvalid) {
                    _this.verb = 'are';
                    _this.dimensions = 'width and height';
                }
                else {
                    _this.verb = 'is';
                    _this.dimensions = 'width';
                }
            }
            else {
                _this.verb = 'is';
                _this.dimensions = 'height';
            }
            return _this;
        }
        return InvalidElementScreenshotDimensionsError;
    }(TestRunErrorBase));
    // Iframe errors
    //--------------------------------------------------------------------
    var ActionElementNotIframeError = /** @class */ (function (_super) {
        __extends(ActionElementNotIframeError, _super);
        function ActionElementNotIframeError(callsite) {
            return _super.call(this, TEST_RUN_ERRORS.actionElementNotIframeError, callsite) || this;
        }
        return ActionElementNotIframeError;
    }(TestRunErrorBase));
    var ActionIframeIsNotLoadedError = /** @class */ (function (_super) {
        __extends(ActionIframeIsNotLoadedError, _super);
        function ActionIframeIsNotLoadedError() {
            return _super.call(this, TEST_RUN_ERRORS.actionIframeIsNotLoadedError) || this;
        }
        return ActionIframeIsNotLoadedError;
    }(TestRunErrorBase));
    var CurrentIframeIsNotLoadedError = /** @class */ (function (_super) {
        __extends(CurrentIframeIsNotLoadedError, _super);
        function CurrentIframeIsNotLoadedError() {
            return _super.call(this, TEST_RUN_ERRORS.currentIframeIsNotLoadedError) || this;
        }
        return CurrentIframeIsNotLoadedError;
    }(TestRunErrorBase));
    var ChildWindowNotFoundError = /** @class */ (function (_super) {
        __extends(ChildWindowNotFoundError, _super);
        function ChildWindowNotFoundError() {
            return _super.call(this, TEST_RUN_ERRORS.childWindowNotFoundError) || this;
        }
        return ChildWindowNotFoundError;
    }(TestRunErrorBase));
    var ChildWindowIsNotLoadedError = /** @class */ (function (_super) {
        __extends(ChildWindowIsNotLoadedError, _super);
        function ChildWindowIsNotLoadedError() {
            return _super.call(this, TEST_RUN_ERRORS.childWindowIsNotLoadedError) || this;
        }
        return ChildWindowIsNotLoadedError;
    }(TestRunErrorBase));
    var CannotSwitchToWindowError = /** @class */ (function (_super) {
        __extends(CannotSwitchToWindowError, _super);
        function CannotSwitchToWindowError() {
            return _super.call(this, TEST_RUN_ERRORS.cannotSwitchToWindowError) || this;
        }
        return CannotSwitchToWindowError;
    }(TestRunErrorBase));
    var CloseChildWindowError = /** @class */ (function (_super) {
        __extends(CloseChildWindowError, _super);
        function CloseChildWindowError() {
            return _super.call(this, TEST_RUN_ERRORS.closeChildWindowError) || this;
        }
        return CloseChildWindowError;
    }(TestRunErrorBase));
    var CannotCloseWindowWithChildrenError = /** @class */ (function (_super) {
        __extends(CannotCloseWindowWithChildrenError, _super);
        function CannotCloseWindowWithChildrenError() {
            return _super.call(this, TEST_RUN_ERRORS.cannotCloseWindowWithChildrenError) || this;
        }
        return CannotCloseWindowWithChildrenError;
    }(TestRunErrorBase));
    var CannotCloseWindowWithoutParentError = /** @class */ (function (_super) {
        __extends(CannotCloseWindowWithoutParentError, _super);
        function CannotCloseWindowWithoutParentError() {
            return _super.call(this, TEST_RUN_ERRORS.cannotCloseWindowWithoutParent) || this;
        }
        return CannotCloseWindowWithoutParentError;
    }(TestRunErrorBase));
    var SwitchToWindowPredicateError = /** @class */ (function (_super) {
        __extends(SwitchToWindowPredicateError, _super);
        function SwitchToWindowPredicateError(errMsg) {
            var _this = _super.call(this, TEST_RUN_ERRORS.switchToWindowPredicateError) || this;
            _this.errMsg = errMsg;
            return _this;
        }
        return SwitchToWindowPredicateError;
    }(TestRunErrorBase));
    var WindowNotFoundError = /** @class */ (function (_super) {
        __extends(WindowNotFoundError, _super);
        function WindowNotFoundError() {
            return _super.call(this, TEST_RUN_ERRORS.targetWindowNotFoundError) || this;
        }
        return WindowNotFoundError;
    }(TestRunErrorBase));
    var ParentWindowNotFoundError = /** @class */ (function (_super) {
        __extends(ParentWindowNotFoundError, _super);
        function ParentWindowNotFoundError() {
            return _super.call(this, TEST_RUN_ERRORS.parentWindowNotFoundError) || this;
        }
        return ParentWindowNotFoundError;
    }(TestRunErrorBase));
    var PreviousWindowNotFoundError = /** @class */ (function (_super) {
        __extends(PreviousWindowNotFoundError, _super);
        function PreviousWindowNotFoundError() {
            return _super.call(this, TEST_RUN_ERRORS.previousWindowNotFoundError) || this;
        }
        return PreviousWindowNotFoundError;
    }(TestRunErrorBase));
    var ChildWindowClosedBeforeSwitchingError = /** @class */ (function (_super) {
        __extends(ChildWindowClosedBeforeSwitchingError, _super);
        function ChildWindowClosedBeforeSwitchingError() {
            return _super.call(this, TEST_RUN_ERRORS.childWindowClosedBeforeSwitchingError) || this;
        }
        return ChildWindowClosedBeforeSwitchingError;
    }(TestRunErrorBase));
    var CannotRestoreChildWindowError = /** @class */ (function (_super) {
        __extends(CannotRestoreChildWindowError, _super);
        function CannotRestoreChildWindowError() {
            return _super.call(this, TEST_RUN_ERRORS.cannotRestoreChildWindowError) || this;
        }
        return CannotRestoreChildWindowError;
    }(TestRunErrorBase));
    var CurrentIframeNotFoundError = /** @class */ (function (_super) {
        __extends(CurrentIframeNotFoundError, _super);
        function CurrentIframeNotFoundError() {
            return _super.call(this, TEST_RUN_ERRORS.currentIframeNotFoundError) || this;
        }
        return CurrentIframeNotFoundError;
    }(TestRunErrorBase));
    var CurrentIframeIsInvisibleError = /** @class */ (function (_super) {
        __extends(CurrentIframeIsInvisibleError, _super);
        function CurrentIframeIsInvisibleError() {
            return _super.call(this, TEST_RUN_ERRORS.currentIframeIsInvisibleError) || this;
        }
        return CurrentIframeIsInvisibleError;
    }(TestRunErrorBase));
    // Native dialog errors
    //--------------------------------------------------------------------
    var NativeDialogNotHandledError = /** @class */ (function (_super) {
        __extends(NativeDialogNotHandledError, _super);
        function NativeDialogNotHandledError(dialogType, url) {
            var _this = _super.call(this, TEST_RUN_ERRORS.nativeDialogNotHandledError) || this;
            _this.dialogType = dialogType;
            _this.pageUrl = url;
            return _this;
        }
        return NativeDialogNotHandledError;
    }(TestRunErrorBase));
    var UncaughtErrorInNativeDialogHandler = /** @class */ (function (_super) {
        __extends(UncaughtErrorInNativeDialogHandler, _super);
        function UncaughtErrorInNativeDialogHandler(dialogType, errMsg, url) {
            var _this = _super.call(this, TEST_RUN_ERRORS.uncaughtErrorInNativeDialogHandler) || this;
            _this.dialogType = dialogType;
            _this.errMsg = errMsg;
            _this.pageUrl = url;
            return _this;
        }
        return UncaughtErrorInNativeDialogHandler;
    }(TestRunErrorBase));

    var Errors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        TestRunErrorBase: TestRunErrorBase,
        ClientFunctionExecutionInterruptionError: ClientFunctionExecutionInterruptionError,
        DomNodeClientFunctionResultError: DomNodeClientFunctionResultError,
        SelectorErrorBase: SelectorErrorBase,
        InvalidSelectorResultError: InvalidSelectorResultError,
        CannotObtainInfoForElementSpecifiedBySelectorError: CannotObtainInfoForElementSpecifiedBySelectorError,
        UncaughtErrorOnPage: UncaughtErrorOnPage,
        UncaughtErrorInClientFunctionCode: UncaughtErrorInClientFunctionCode,
        UncaughtErrorInCustomDOMPropertyCode: UncaughtErrorInCustomDOMPropertyCode,
        UncaughtErrorInCustomClientScriptCode: UncaughtErrorInCustomClientScriptCode,
        UncaughtErrorInCustomClientScriptLoadedFromModule: UncaughtErrorInCustomClientScriptLoadedFromModule,
        ActionIntegerOptionError: ActionIntegerOptionError,
        ActionPositiveIntegerOptionError: ActionPositiveIntegerOptionError,
        ActionBooleanOptionError: ActionBooleanOptionError,
        ActionSpeedOptionError: ActionSpeedOptionError,
        ActionStringOptionError: ActionStringOptionError,
        ActionDateOptionError: ActionDateOptionError,
        ActionNumberOptionError: ActionNumberOptionError,
        ActionElementNotFoundError: ActionElementNotFoundError,
        ActionElementIsInvisibleError: ActionElementIsInvisibleError,
        ActionSelectorMatchesWrongNodeTypeError: ActionSelectorMatchesWrongNodeTypeError,
        ActionAdditionalElementNotFoundError: ActionAdditionalElementNotFoundError,
        ActionAdditionalElementIsInvisibleError: ActionAdditionalElementIsInvisibleError,
        ActionAdditionalSelectorMatchesWrongNodeTypeError: ActionAdditionalSelectorMatchesWrongNodeTypeError,
        ActionElementNonEditableError: ActionElementNonEditableError,
        ActionElementNotTextAreaError: ActionElementNotTextAreaError,
        ActionElementNonContentEditableError: ActionElementNonContentEditableError,
        ActionRootContainerNotFoundError: ActionRootContainerNotFoundError,
        ActionIncorrectKeysError: ActionIncorrectKeysError,
        ActionCannotFindFileToUploadError: ActionCannotFindFileToUploadError,
        ActionElementIsNotFileInputError: ActionElementIsNotFileInputError,
        ActionInvalidScrollTargetError: ActionInvalidScrollTargetError,
        InvalidElementScreenshotDimensionsError: InvalidElementScreenshotDimensionsError,
        ActionElementNotIframeError: ActionElementNotIframeError,
        ActionIframeIsNotLoadedError: ActionIframeIsNotLoadedError,
        CurrentIframeIsNotLoadedError: CurrentIframeIsNotLoadedError,
        ChildWindowNotFoundError: ChildWindowNotFoundError,
        ChildWindowIsNotLoadedError: ChildWindowIsNotLoadedError,
        CannotSwitchToWindowError: CannotSwitchToWindowError,
        CloseChildWindowError: CloseChildWindowError,
        CannotCloseWindowWithChildrenError: CannotCloseWindowWithChildrenError,
        CannotCloseWindowWithoutParentError: CannotCloseWindowWithoutParentError,
        SwitchToWindowPredicateError: SwitchToWindowPredicateError,
        WindowNotFoundError: WindowNotFoundError,
        ParentWindowNotFoundError: ParentWindowNotFoundError,
        PreviousWindowNotFoundError: PreviousWindowNotFoundError,
        ChildWindowClosedBeforeSwitchingError: ChildWindowClosedBeforeSwitchingError,
        CannotRestoreChildWindowError: CannotRestoreChildWindowError,
        CurrentIframeNotFoundError: CurrentIframeNotFoundError,
        CurrentIframeIsInvisibleError: CurrentIframeIsInvisibleError,
        NativeDialogNotHandledError: NativeDialogNotHandledError,
        UncaughtErrorInNativeDialogHandler: UncaughtErrorInNativeDialogHandler
    });

    // @ts-ignore
    var adapter = {};
    function initializeAdapter$1(initializer) {
        if (initializer.nativeMethods.objectAssign) {
            initializer.nativeMethods.objectAssign(adapter, initializer);
            return;
        }
        var keys = initializer.nativeMethods.objectKeys(initializer);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            // @ts-ignore
            adapter[key] = initializer[key];
        }
    }

    function visible(el) {
        if (!adapter.isDomElement(el) && !adapter.isTextNode(el))
            return false;
        if (adapter.isOptionElement(el) || adapter.getTagName(el) === 'optgroup')
            return adapter.isOptionElementVisible(el);
        return adapter.isElementVisible(el);
    }
    function isNodeCollection(obj) {
        return obj instanceof adapter.nativeMethods.HTMLCollection || obj instanceof adapter.nativeMethods.NodeList;
    }
    function castToArray(list) {
        var length = list.length;
        var result = [];
        for (var i = 0; i < length; i++)
            result.push(list[i]);
        return result;
    }
    function isArrayOfNodes(obj) {
        if (!adapter.nativeMethods.isArray(obj))
            return false;
        for (var i = 0; i < obj.length; i++) {
            if (!(obj[i] instanceof adapter.nativeMethods.Node))
                return false;
        }
        return true;
    }

    var _a;
    var SELECTOR_FILTER_ERROR = {
        filterVisible: 1,
        filterHidden: 2,
        nth: 3,
    };
    var FILTER_ERROR_TO_API_RE = (_a = {},
        _a[SELECTOR_FILTER_ERROR.filterVisible] = /^\.filterVisible\(\)$/,
        _a[SELECTOR_FILTER_ERROR.filterHidden] = /^\.filterHidden\(\)$/,
        _a[SELECTOR_FILTER_ERROR.nth] = /^\.nth\(\d+\)$/,
        _a);
    var SelectorFilter = /** @class */ (function () {
        function SelectorFilter() {
            this._err = null;
        }
        Object.defineProperty(SelectorFilter.prototype, "error", {
            get: function () {
                return this._err;
            },
            set: function (message) {
                if (this._err === null)
                    this._err = message;
            },
            enumerable: false,
            configurable: true
        });
        SelectorFilter.prototype.filter = function (nodes, options, apiInfo) {
            if (options.filterVisible) {
                nodes = nodes.filter(visible);
                this._assertFilterError(nodes, apiInfo, SELECTOR_FILTER_ERROR.filterVisible);
            }
            if (options.filterHidden) {
                nodes = nodes.filter(function (n) { return !visible(n); });
                this._assertFilterError(nodes, apiInfo, SELECTOR_FILTER_ERROR.filterHidden);
            }
            if (options.counterMode) {
                if (options.index === null)
                    return nodes.length;
                return SelectorFilter._getNodeByIndex(nodes, options.index) ? 1 : 0;
            }
            if (options.collectionMode) {
                if (options.index !== null) {
                    var nodeOnIndex_1 = SelectorFilter._getNodeByIndex(nodes, options.index);
                    nodes = nodeOnIndex_1 ? [nodeOnIndex_1] : [];
                    this._assertFilterError(nodes, apiInfo, SELECTOR_FILTER_ERROR.nth);
                }
                return nodes;
            }
            var nodeOnIndex = SelectorFilter._getNodeByIndex(nodes, options.index || 0);
            if (!nodeOnIndex)
                this.error = SelectorFilter._getErrorItem(apiInfo, SELECTOR_FILTER_ERROR.nth);
            return nodeOnIndex;
        };
        SelectorFilter.prototype.cast = function (searchResult) {
            if (searchResult === null || searchResult === void 0)
                return [];
            else if (searchResult instanceof adapter.nativeMethods.Node)
                return [searchResult];
            else if (isArrayOfNodes(searchResult))
                return searchResult;
            else if (isNodeCollection(searchResult))
                return castToArray(searchResult);
            throw new InvalidSelectorResultError();
        };
        SelectorFilter.prototype._assertFilterError = function (filtered, apiInfo, filterError) {
            if (filtered.length === 0)
                this.error = SelectorFilter._getErrorItem(apiInfo, filterError);
        };
        SelectorFilter._getErrorItem = function (_a, err) {
            var apiFnChain = _a.apiFnChain, apiFnID = _a.apiFnID;
            if (err) {
                for (var i = apiFnID; i < apiFnChain.length; i++) {
                    if (FILTER_ERROR_TO_API_RE[err].test(apiFnChain[i]))
                        return i;
                }
            }
            return null;
        };
        SelectorFilter._getNodeByIndex = function (nodes, index) {
            return index < 0 ? nodes[nodes.length + index] : nodes[index];
        };
        return SelectorFilter;
    }());
    var selectorFilter = new SelectorFilter();

    // NOTE: evalFunction is isolated into a separate module to
    // restrict access to TestCafe intrinsics for the evaluated code.
    // It also accepts `__dependencies$` argument which may be used by evaluated code.
    function evalFunction(fnCode, __dependencies$) {
        var FunctionCtor = adapter.nativeMethods.Function;
        if (adapter.isProxyless) {
            var evaluator_1 = new FunctionCtor('fnCode', '__dependencies$', '"use strict"; return eval(fnCode)');
            return evaluator_1(fnCode, __dependencies$);
        }
        var evaluator = new FunctionCtor('fnCode', '__dependencies$', 'Promise', 
        // NOTE: we should pass the original `RegExp`
        // to make the `instanceof RegExp` check successful in different contexts
        'RegExp', 
        // NOTE: `eval` in strict mode will not override context variables
        '"use strict"; return eval(fnCode)');
        return evaluator(fnCode, __dependencies$, adapter.PromiseCtor, RegExp);
    }

    var FunctionTransform = /** @class */ (function () {
        function FunctionTransform() {
            this.type = 'Function';
        }
        FunctionTransform.prototype.shouldTransform = function (type) {
            return type === 'function';
        };
        FunctionTransform.prototype.toSerializable = function () {
            return '';
        };
        // HACK: UglifyJS + TypeScript + argument destructuring can generate incorrect code.
        // So we have to use plain assignments here.
        FunctionTransform.prototype.fromSerializable = function (opts) {
            var fnCode = opts.fnCode;
            var dependencies = opts.dependencies;
            if ('filterOptions' in dependencies)
                dependencies.selectorFilter = selectorFilter;
            return evalFunction(fnCode, dependencies);
        };
        return FunctionTransform;
    }());

    var ClientFunctionNodeTransform = /** @class */ (function () {
        function ClientFunctionNodeTransform(instantiationCallsiteName) {
            this.type = 'Node';
            this._instantiationCallsiteName = instantiationCallsiteName;
        }
        ClientFunctionNodeTransform.prototype.shouldTransform = function (type, val) {
            if (val instanceof adapter.nativeMethods.Node)
                throw new DomNodeClientFunctionResultError(this._instantiationCallsiteName);
            return false;
        };
        ClientFunctionNodeTransform.prototype.toSerializable = function () {
        };
        ClientFunctionNodeTransform.prototype.fromSerializable = function () {
        };
        return ClientFunctionNodeTransform;
    }());

    var ClientFunctionExecutor = /** @class */ (function () {
        function ClientFunctionExecutor(command) {
            this.command = command;
            this.replicator = this._createReplicator();
            this.dependencies = this.replicator.decode(command.dependencies);
            this.fn = evalFunction(command.fnCode, this.dependencies);
        }
        ClientFunctionExecutor.prototype.getResult = function () {
            var _this = this;
            return adapter.PromiseCtor.resolve()
                .then(function () {
                var args = _this.replicator.decode(_this.command.args);
                return _this._executeFn(args);
            })
                .catch(function (err) {
                if (!err.isTestCafeError && !adapter.isProxyless)
                    err = new UncaughtErrorInClientFunctionCode(_this.command.instantiationCallsiteName, err);
                throw err;
            });
        };
        ClientFunctionExecutor.prototype.encodeResult = function (result) {
            return this.replicator.encode(result);
        };
        ClientFunctionExecutor.prototype._createReplicator = function () {
            return createReplicator([
                new ClientFunctionNodeTransform(this.command.instantiationCallsiteName),
                new FunctionTransform(),
            ]);
        };
        ClientFunctionExecutor.prototype._executeFn = function (args) {
            return this.fn.apply(window, args);
        };
        return ClientFunctionExecutor;
    }());

    // @ts-ignore
    var adapter$1 = {};
    function initializeAdapter$2(initializer) {
        if (initializer.nativeMethods.objectAssign) {
            initializer.nativeMethods.objectAssign(adapter$1, initializer);
            return;
        }
        var keys = initializer.nativeMethods.objectKeys(initializer);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            // @ts-ignore
            adapter$1[key] = initializer[key];
        }
    }

    var NOT_CONTENT_EDITABLE_ELEMENTS_RE = /^(select|option|applet|area|audio|canvas|datalist|keygen|map|meter|object|progress|source|track|video|img)$/;
    var INPUT_ELEMENTS_RE = /^(input|textarea|button)$/;
    // NOTE: save this classes in hammerhead and local native methods
    var HTMLOptionElement = window.HTMLOptionElement;
    var ShadowRoot = window.ShadowRoot;
    var Text = window.Text;
    var HTMLMapElement = window.HTMLMapElement;
    var HTMLAreaElement = window.HTMLAreaElement;
    var HTMLSelectElement = window.HTMLSelectElement;
    var HTMLHtmlElement = window.HTMLHtmlElement;
    var HTMLBodyElement = window.HTMLBodyElement;
    var ProcessingInstruction = window.ProcessingInstruction;
    function isSelectElement(el) {
        return el instanceof HTMLSelectElement;
    }
    function isShadowRoot(root) {
        return root instanceof ShadowRoot;
    }
    function isDomElement(el) {
        return el instanceof nativeMethods.elementClass;
    }
    function isTextNode(node) {
        return node instanceof Text;
    }
    function isOptionElement(el) {
        return el instanceof HTMLOptionElement;
    }
    function isBodyElement(el) {
        return el instanceof HTMLBodyElement;
    }
    function isHtmlElement(el) {
        return el instanceof HTMLHtmlElement;
    }
    function getTagName(el) {
        // NOTE: Check for tagName being a string, because it may be a function in an Angular app (T175340).
        return el && typeof el.tagName === 'string' ? el.tagName.toLowerCase() : '';
    }
    function getParent(el) {
        el = el.assignedSlot || el;
        // @ts-ignore
        return el.parentNode || el.host; // eslint-disable-line no-restricted-properties
    }
    function matches(el, selector) {
        if (!isElementNode(el))
            return false;
        return nativeMethods.matches.call(el, selector);
    }
    function getParents(el, selector) {
        var parents = [];
        var parent = getParent(el);
        while (parent) {
            if (!selector && isElementNode(parent) || selector && matches(parent, selector))
                parents.push(parent);
            parent = getParent(parent);
        }
        return parents;
    }
    function getActiveElement() {
        var _a;
        var activeElement = document.activeElement || document.body; // eslint-disable-line no-restricted-properties
        while ((_a = activeElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.activeElement)
            activeElement = activeElement.shadowRoot.activeElement; // eslint-disable-line no-restricted-properties
        return activeElement;
    }
    function getSelectParent(el) {
        var parent = el.parentNode; // eslint-disable-line no-restricted-properties
        return closest(parent, 'select');
    }
    function isMapElement(el) {
        return el instanceof HTMLMapElement || el instanceof HTMLAreaElement;
    }
    function isSVGElement(instance) {
        return instance instanceof nativeMethods.svgElementClass;
    }
    function isAlwaysNotEditableElement(el) {
        var tagName = getTagName(el);
        return !!tagName && (NOT_CONTENT_EDITABLE_ELEMENTS_RE.test(tagName) || INPUT_ELEMENTS_RE.test(tagName));
    }
    function findDocument(el) {
        if ('documentElement' in el)
            return el;
        if (el.ownerDocument && el.ownerDocument.defaultView)
            return el.ownerDocument;
        var parent = isElementNode(el) && el.parentNode; // eslint-disable-line no-restricted-properties
        return parent ? findDocument(parent) : document;
    }
    function isContentEditableElement(el) {
        var element = isTextNode(el) ? el.parentElement || el.parentNode : el; // eslint-disable-line no-restricted-properties
        if (!element)
            return false;
        // @ts-ignore
        var isContentEditable = element.isContentEditable &&
            !isAlwaysNotEditableElement(element);
        return isRenderedNode(element) && (isContentEditable || findDocument(el).designMode === 'on');
    }
    function closest(el, selector) {
        if (!isElementNode(el))
            return null;
        return nativeMethods.closest.call(el, selector);
    }
    function getMapContainer(el) {
        var closestMap = closest(el, 'map');
        var closestMapName = nativeMethods.getAttribute.call(closestMap, 'name');
        var containerSelector = '[usemap="#' + closestMapName + '"]';
        return nativeMethods.querySelector.call(findDocument(el), containerSelector);
    }
    function getSelectVisibleChildren(select) {
        var collection = nativeMethods.querySelectorAll.call(select, 'optgroup, option');
        return Array.prototype.slice.call(collection);
    }
    function getChildVisibleIndex(select, child) {
        var childrenArray = getSelectVisibleChildren(select);
        return childrenArray.indexOf(child);
    }
    function findParent(node, includeSelf, predicate) {
        var resultNode = includeSelf ? node : node.parentNode; // eslint-disable-line no-restricted-properties
        if (typeof predicate !== 'function')
            return resultNode;
        while (resultNode) {
            if (predicate(resultNode))
                return resultNode;
            resultNode = resultNode.parentNode; // eslint-disable-line no-restricted-properties
        }
        return null;
    }
    function isElementNode(node) {
        return !!node && node.nodeType === nativeMethods.Node.ELEMENT_NODE;
    }
    function isRenderedNode(node) {
        var nodeName = node.nodeName;
        return !(node instanceof ProcessingInstruction) && nodeName !== '#comment' && nodeName !== 'SCRIPT' && nodeName !== 'STYLE';
    }
    var scrollbarSize = NaN;
    function getScrollbarSize() {
        if (!isNaN(scrollbarSize))
            return scrollbarSize;
        var scrollDiv = document.createElement('div');
        scrollDiv.style.height = '100px';
        scrollDiv.style.overflow = 'scroll';
        scrollDiv.style.position = 'absolute';
        scrollDiv.style.top = '-9999px';
        scrollDiv.style.width = '100px';
        document.body.appendChild(scrollDiv);
        scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarSize;
    }
    function isElementInIframe(el, currentDocument) {
        var doc = currentDocument || findDocument(el);
        return window.document !== doc;
    }
    function isWindow(el) {
        return 'pageYOffset' in el;
    }
    function isDocument(el) {
        return 'defaultView' in el;
    }
    function getFrameElement(win) {
        try {
            return win.frameElement;
        }
        catch (e) {
            return null;
        }
    }
    function getIframeByElement(el) {
        var doc = isDocument(el) ? el : el.ownerDocument;
        var win = doc.defaultView;
        return win && getFrameElement(win);
    }
    function isSVGElementOrChild(el) {
        return !!closest(el, 'svg');
    }

    var dom = /*#__PURE__*/Object.freeze({
        __proto__: null,
        isSelectElement: isSelectElement,
        isShadowRoot: isShadowRoot,
        isDomElement: isDomElement,
        isTextNode: isTextNode,
        isOptionElement: isOptionElement,
        isBodyElement: isBodyElement,
        isHtmlElement: isHtmlElement,
        getTagName: getTagName,
        matches: matches,
        getParents: getParents,
        getActiveElement: getActiveElement,
        getSelectParent: getSelectParent,
        isMapElement: isMapElement,
        isSVGElement: isSVGElement,
        findDocument: findDocument,
        isContentEditableElement: isContentEditableElement,
        closest: closest,
        getMapContainer: getMapContainer,
        getSelectVisibleChildren: getSelectVisibleChildren,
        getChildVisibleIndex: getChildVisibleIndex,
        findParent: findParent,
        isElementNode: isElementNode,
        isRenderedNode: isRenderedNode,
        getScrollbarSize: getScrollbarSize,
        isElementInIframe: isElementInIframe,
        isWindow: isWindow,
        isDocument: isDocument,
        getIframeByElement: getIframeByElement,
        isSVGElementOrChild: isSVGElementOrChild
    });

    // NOTE: For Chrome.
    var MIN_SELECT_SIZE_VALUE = 4;
    function get(el, property) {
        el = 'documentElement' in el ? el.documentElement : el;
        var computedStyle = getComputedStyle(el);
        return computedStyle && computedStyle[property];
    }
    function getBordersWidth(el) {
        return {
            bottom: getIntValue(get(el, 'borderBottomWidth')),
            left: getIntValue(get(el, 'borderLeftWidth')),
            right: getIntValue(get(el, 'borderRightWidth')),
            top: getIntValue(get(el, 'borderTopWidth')),
        };
    }
    function isOptionElementVisible(el) {
        var parentSelect = getSelectParent(el);
        if (!parentSelect)
            return true;
        var selectSizeValue = getSelectElementSize(parentSelect);
        return selectSizeValue > 1;
    }
    function isSelectVisibleChild(el) {
        var select = getSelectParent(el);
        var tagName = getTagName(el);
        return isSelectElement(select) && getSelectElementSize(select) > 1 &&
            (tagName === 'option' || tagName === 'optgroup');
    }
    function getScrollLeft(el) {
        var _a;
        if (!el)
            return 0;
        if (isWindow(el))
            return el.pageXOffset;
        if (isDocument(el))
            return ((_a = el.defaultView) === null || _a === void 0 ? void 0 : _a.pageXOffset) || 0;
        return el.scrollLeft;
    }
    function getScrollTop(el) {
        var _a;
        if (!el)
            return 0;
        if (isWindow(el))
            return el.pageYOffset;
        if (isDocument(el))
            return ((_a = el.defaultView) === null || _a === void 0 ? void 0 : _a.pageYOffset) || 0;
        return el.scrollTop;
    }
    function getElementScroll(el) {
        var targetEl = el;
        if (isHtmlElement(el)) {
            targetEl = window;
            if (isElementInIframe(el)) {
                var currentIframe = getIframeByElement(el);
                if (currentIframe)
                    targetEl = nativeMethods.contentWindowGetter.call(currentIframe) || window;
            }
        }
        return {
            left: getScrollLeft(targetEl),
            top: getScrollTop(targetEl),
        };
    }
    function getIntValue(value) {
        value = value || '';
        var parsedValue = parseInt(value.replace('px', ''), 10);
        return isNaN(parsedValue) ? 0 : parsedValue;
    }
    function getElementPadding(el) {
        return {
            bottom: getIntValue(get(el, 'paddingBottom')),
            left: getIntValue(get(el, 'paddingLeft')),
            right: getIntValue(get(el, 'paddingRight')),
            top: getIntValue(get(el, 'paddingTop')),
        };
    }
    function getHeight(el) {
        if (!el)
            return 0;
        if (isWindow(el))
            return el.document.documentElement.clientHeight;
        if (isDocument(el)) {
            var doc = el.documentElement;
            var clientProp = 'clientHeight';
            var scrollProp = 'scrollHeight';
            var offsetProp = 'offsetHeight';
            if (doc[clientProp] >= doc[scrollProp])
                return doc[clientProp];
            return Math.max(el.body[scrollProp], doc[scrollProp], el.body[offsetProp], doc[offsetProp]);
        }
        var value = el.offsetHeight;
        value -= getIntValue(get(el, 'paddingTop'));
        value -= getIntValue(get(el, 'paddingBottom'));
        value -= getIntValue(get(el, 'borderTopWidth'));
        value -= getIntValue(get(el, 'borderBottomWidth'));
        return value;
    }
    function getOptionHeight(select) {
        var realSizeValue = getSelectElementSize(select);
        var selectPadding = getElementPadding(select);
        var selectScrollHeight = select.scrollHeight - (selectPadding.top + selectPadding.bottom);
        var childrenCount = getSelectVisibleChildren(select).length;
        if (realSizeValue === 1)
            return getHeight(select);
        return Math.round(selectScrollHeight / Math.max(childrenCount, realSizeValue));
    }
    function getSelectElementSize(select) {
        var sizeAttr = nativeMethods.getAttribute.call(select, 'size');
        var multipleAttr = nativeMethods.getAttribute.call(select, 'multiple');
        var size = !sizeAttr ? 1 : parseInt(sizeAttr, 10);
        if (multipleAttr && (!sizeAttr || size < 1))
            size = MIN_SELECT_SIZE_VALUE;
        return size;
    }
    function getInnerWidth(el) {
        if (!el)
            return 0;
        if (isWindow(el))
            return el.document.documentElement.clientWidth;
        if (isDocument(el))
            return el.documentElement.clientWidth;
        var value = el.offsetWidth;
        value -= getIntValue(get(el, 'borderLeftWidth'));
        value -= getIntValue(get(el, 'borderRightWidth'));
        return value;
    }
    function getInnerHeight(el) {
        if (!el)
            return 0;
        if (isWindow(el))
            return el.document.documentElement.clientHeight;
        if (isDocument(el))
            return el.documentElement.clientHeight;
        var value = el.offsetHeight;
        value -= getIntValue(get(el, 'borderTopWidth'));
        value -= getIntValue(get(el, 'borderBottomWidth'));
        return value;
    }
    function getOffset(el) {
        if (!el || isWindow(el) || isDocument(el))
            return null;
        var clientRect = el.getBoundingClientRect();
        // NOTE: A detached node or documentElement.
        var doc = el.ownerDocument;
        var docElement = doc.documentElement;
        if (!docElement.contains(el) || el === docElement) {
            return {
                top: clientRect.top,
                left: clientRect.left,
            };
        }
        var win = doc.defaultView;
        var clientTop = docElement.clientTop || doc.body.clientTop || 0;
        var clientLeft = docElement.clientLeft || doc.body.clientLeft || 0;
        var scrollTop = win.pageYOffset || docElement.scrollTop || doc.body.scrollTop;
        var scrollLeft = win.pageXOffset || docElement.scrollLeft || doc.body.scrollLeft;
        clientRect = el.getBoundingClientRect();
        return {
            top: clientRect.top + scrollTop - clientTop,
            left: clientRect.left + scrollLeft - clientLeft,
        };
    }
    function setScrollLeft(el, value) {
        if (!el)
            return;
        if (isDocument(el))
            el = el.defaultView;
        if (isWindow(el)) {
            var scrollTop = getScrollTop(el);
            nativeMethods.scrollTo.call(el, value, scrollTop);
        }
        else
            el.scrollLeft = value;
    }
    function setScrollTop(el, value) {
        if (!el)
            return;
        if (isDocument(el))
            el = el.defaultView;
        if (isWindow(el)) {
            var scrollLeft = getScrollLeft(el);
            nativeMethods.scrollTo.call(el, scrollLeft, value);
        }
        else
            el.scrollTop = value;
    }

    var style = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get: get,
        getBordersWidth: getBordersWidth,
        isOptionElementVisible: isOptionElementVisible,
        isSelectVisibleChild: isSelectVisibleChild,
        getScrollLeft: getScrollLeft,
        getScrollTop: getScrollTop,
        getElementScroll: getElementScroll,
        getElementPadding: getElementPadding,
        getOptionHeight: getOptionHeight,
        getSelectElementSize: getSelectElementSize,
        getInnerWidth: getInnerWidth,
        getInnerHeight: getInnerHeight,
        getOffset: getOffset,
        setScrollLeft: setScrollLeft,
        setScrollTop: setScrollTop
    });

    var isVisibilityHiddenNode = function (node) {
        return !!adapter$1.dom.findParent(node, true, function (ancestor) {
            return adapter$1.dom.isElementNode(ancestor) && adapter$1.style.get(ancestor, 'visibility') === 'hidden';
        });
    };
    var isHiddenNode = function (node) {
        return !!adapter$1.dom.findParent(node, true, function (ancestor) {
            return adapter$1.dom.isElementNode(ancestor) && adapter$1.style.get(ancestor, 'display') === 'none';
        });
    };
    function isNotVisibleNode(node) {
        return !adapter$1.dom.isRenderedNode(node) || isHiddenNode(node) || isVisibilityHiddenNode(node);
    }
    function hasDimensions(el) {
        //NOTE: it's like jquery ':visible' selector (http://blog.jquery.com/2009/02/20/jquery-1-3-2-released/)
        return el && !(el.offsetHeight <= 0 && el.offsetWidth <= 0);
    }
    function isFixedElement(node) {
        return adapter$1.dom.isElementNode(node) && adapter$1.style.get(node, 'position') === 'fixed';
    }

    function isElementVisible(el) {
        if (adapter$1.dom.isTextNode(el))
            return !isNotVisibleNode(el);
        if (!adapter$1.dom.isContentEditableElement(el)) {
            var elementRectangle = adapter$1.position.getElementRectangle(el);
            if (elementRectangle.width === 0 || elementRectangle.height === 0)
                return false;
        }
        if (adapter$1.dom.isMapElement(el)) {
            var mapContainer = adapter$1.dom.getMapContainer(adapter$1.dom.closest(el, 'map'));
            return mapContainer ? isElementVisible(mapContainer) : false;
        }
        if (adapter$1.style.isSelectVisibleChild(el)) {
            var select = adapter$1.dom.getSelectParent(el);
            var childRealIndex = adapter$1.dom.getChildVisibleIndex(select, el);
            var realSelectSizeValue = adapter$1.style.getSelectElementSize(select);
            var topVisibleIndex = Math.max(adapter$1.style.getScrollTop(select) / adapter$1.style.getOptionHeight(select), 0);
            var bottomVisibleIndex = topVisibleIndex + realSelectSizeValue - 1;
            var optionVisibleIndex = Math.max(childRealIndex - topVisibleIndex, 0);
            return optionVisibleIndex >= topVisibleIndex && optionVisibleIndex <= bottomVisibleIndex;
        }
        if (adapter$1.dom.isSVGElement(el)) {
            if (adapter$1.style.get(el, 'visibility') === 'hidden' || adapter$1.style.get(el, 'display') === 'none')
                return false;
            var parent_1 = adapter$1.dom.findParent(el);
            return parent_1 ? isElementVisible(parent_1) : true;
        }
        return hasDimensions(el) && adapter$1.style.get(el, 'visibility') !== 'hidden';
    }

    var initializer = {
        isProxyless: true,
        nativeMethods: nativeMethods,
        PromiseCtor: nativeMethods.Promise,
        // eslint-disable-next-line hammerhead/use-native-methods
        delay: function (ms) { return new nativeMethods.Promise(function (resolve) { return nativeMethods.setTimeout.call(window, resolve, ms); }); },
        isShadowRoot: isShadowRoot,
        isDomElement: isDomElement,
        isTextNode: isTextNode,
        isOptionElement: isOptionElement,
        getTagName: getTagName,
        getActiveElement: getActiveElement,
        isOptionElementVisible: isOptionElementVisible,
        isElementVisible: isElementVisible,
    };

    var AxisValues = /** @class */ (function () {
        function AxisValues(x, y) {
            this.x = x;
            this.y = y;
        }
        AxisValues.create = function (a) {
            if ('left' in a)
                return new AxisValues(a.left, a.top);
            else if ('right' in a)
                return new AxisValues(a.right, a.bottom);
            return new AxisValues(a.x, a.y);
        };
        AxisValues.prototype.add = function (p) {
            this.x += p.x;
            this.y += p.y;
            return this;
        };
        AxisValues.prototype.sub = function (p) {
            this.x -= p.x;
            this.y -= p.y;
            return this;
        };
        AxisValues.prototype.round = function (fn) {
            if (fn === void 0) { fn = Math.round; }
            this.x = fn(this.x);
            this.y = fn(this.y);
            return this;
        };
        AxisValues.prototype.eql = function (p) {
            return this.x === p.x && this.y === p.y;
        };
        AxisValues.prototype.mul = function (n) {
            this.x *= n;
            this.y *= n;
            return this;
        };
        AxisValues.prototype.distance = function (p) {
            return Math.sqrt(Math.pow(this.x - p.x, 2) + Math.pow(this.y - p.y, 2));
        };
        return AxisValues;
    }());

    function calcOffsetPosition(el, borders, offsetPosition) {
        if (isSVGElementOrChild(el)) {
            var relativeRectangle = getSvgElementRelativeRectangle(el);
            return {
                left: relativeRectangle.left + borders.left,
                top: relativeRectangle.top + borders.top,
            };
        }
        return {
            left: offsetPosition.left + borders.left,
            top: offsetPosition.top + borders.top,
        };
    }
    function offsetToClientCoords(coords, currentDocument) {
        var doc = currentDocument || document;
        var docScrollLeft = getScrollLeft(doc);
        var docScrollTop = getScrollTop(doc);
        var bodyScrollLeft = getScrollLeft(doc.body);
        var bodyScrollTop = getScrollTop(doc.body);
        var scroll = {
            x: docScrollLeft === 0 && bodyScrollLeft !== 0 ? bodyScrollLeft : docScrollLeft,
            y: docScrollTop === 0 && bodyScrollTop !== 0 ? bodyScrollTop : docScrollTop,
        };
        return AxisValues.create(coords).sub(scroll);
    }
    function getOffsetParent(el) {
        if (!el)
            return null;
        var offsetParent = el.offsetParent || document.body;
        while (offsetParent && (!/^(?:body|html)$/i.test(offsetParent.nodeName) &&
            get(offsetParent, 'position') === 'static'))
            offsetParent = offsetParent.offsetParent;
        return offsetParent;
    }
    function getSvgElementRelativeRectangle(el) {
        var tagName = getTagName(el);
        var isSvgTextElement = tagName === 'tspan' || tagName === 'tref' || tagName === 'textpath';
        var boundingClientRect = el.getBoundingClientRect();
        var elementRect = {
            left: boundingClientRect.left + (document.body.scrollLeft || document.documentElement.scrollLeft),
            top: boundingClientRect.top + (document.body.scrollTop || document.documentElement.scrollTop),
            width: boundingClientRect.width,
            height: boundingClientRect.height,
        };
        if (isSvgTextElement) {
            // @ts-ignore
            var htmlEl = el;
            var offsetParent = getOffsetParent(el);
            var elOffset = getOffset(el);
            var offsetParentOffset = getOffset(offsetParent);
            var offsetParentIsBody = getTagName(offsetParent) === 'body';
            return {
                height: elementRect.height,
                left: offsetParentIsBody ? htmlEl.offsetLeft || elOffset.left : offsetParentOffset.left + htmlEl.offsetLeft,
                top: offsetParentIsBody ? htmlEl.offsetTop || elOffset.top : offsetParentOffset.top + htmlEl.offsetTop,
                width: elementRect.width,
            };
        }
        var strokeWidthValue = nativeMethods.getAttribute.call(el, 'stroke-width');
        // NOTE: We assume that the 'stroke-width' attribute can only be set in pixels.
        var strokeWidth = strokeWidthValue ? +strokeWidthValue.replace(/px|em|ex|pt|pc|cm|mm|in/, '') : 1;
        if (strokeWidth && +strokeWidth % 2 !== 0)
            strokeWidth = +strokeWidth + 1;
        if ((tagName === 'line' || tagName === 'polyline' || tagName === 'polygon' || tagName === 'path') &&
            (!elementRect.width || !elementRect.height)) {
            if (!elementRect.width && elementRect.height) {
                elementRect.left -= strokeWidth / 2;
                elementRect.width = strokeWidth;
            }
            else if (elementRect.width && !elementRect.height) {
                elementRect.height = strokeWidth;
                elementRect.top -= strokeWidth / 2;
            }
        }
        else {
            if (tagName === 'polygon') {
                elementRect.height += 2 * strokeWidth;
                elementRect.left -= strokeWidth;
                elementRect.top -= strokeWidth;
                elementRect.width += 2 * strokeWidth;
            }
            elementRect.height += strokeWidth;
            elementRect.left -= strokeWidth / 2;
            elementRect.top -= strokeWidth / 2;
            elementRect.width += strokeWidth;
        }
        return elementRect;
    }
    function calcOffsetPositionInIframe(el, borders, offsetPosition, doc, currentIframe) {
        var iframeBorders = getBordersWidth(currentIframe);
        borders.left += iframeBorders.left;
        borders.top += iframeBorders.top;
        var iframeOffset = getOffsetPosition(currentIframe);
        var iframePadding = getElementPadding(currentIframe);
        var clientPosition;
        if (isSVGElementOrChild(el)) {
            var relativeRectangle = getSvgElementRelativeRectangle(el);
            clientPosition = {
                x: relativeRectangle.left - (document.body.scrollLeft || document.documentElement.scrollLeft) + borders.left,
                y: relativeRectangle.top - (document.body.scrollTop || document.documentElement.scrollTop) + borders.top,
            };
        }
        else {
            clientPosition = offsetToClientCoords({
                x: offsetPosition.left + borders.left,
                y: offsetPosition.top + borders.top,
            }, doc);
        }
        return {
            left: iframeOffset.left + clientPosition.x + iframePadding.left,
            top: iframeOffset.top + clientPosition.y + iframePadding.top,
        };
    }
    function getSelectChildRectangle(el) {
        var select = getSelectParent(el);
        if (select) {
            var selectRectangle = getElementRectangle(select);
            var selectBorders = getBordersWidth(select);
            var selectRightScrollbar = getInnerWidth(select) === select.clientWidth ? 0 : getScrollbarSize();
            var optionHeight = getOptionHeight(select);
            var optionRealIndex = getChildVisibleIndex(select, el);
            var optionVisibleIndex = Math.max(optionRealIndex - getScrollTop(select) / optionHeight, 0);
            return {
                height: optionHeight,
                left: selectRectangle.left + selectBorders.left,
                top: selectRectangle.top + selectBorders.top + getElementPadding(select).top +
                    optionVisibleIndex * optionHeight,
                width: selectRectangle.width - (selectBorders.left + selectBorders.right) - selectRightScrollbar,
            };
        }
        return getElementRectangle(el);
    }
    function getOffsetPosition(el, roundFn) {
        var _a, _b;
        if (roundFn === void 0) { roundFn = Math.round; }
        if (isMapElement(el)) {
            var rectangle = getMapElementRectangle(el);
            return {
                left: rectangle.left,
                top: rectangle.top,
            };
        }
        var doc = findDocument(el);
        var isInIframe = isElementInIframe(el, doc);
        var currentIframe = isInIframe ? getIframeByElement(doc) : null;
        var offsetPosition = doc === el ? getOffset(doc.documentElement) : getOffset(el);
        var borders = getBordersWidth(doc.body);
        var left;
        var top;
        if (!isInIframe || !currentIframe)
            (_a = calcOffsetPosition(el, borders, offsetPosition), left = _a.left, top = _a.top);
        else
            (_b = calcOffsetPositionInIframe(el, borders, offsetPosition, doc, currentIframe), left = _b.left, top = _b.top);
        if (typeof roundFn === 'function') {
            left = roundFn(left);
            top = roundFn(top);
        }
        return { left: left, top: top };
    }
    function getAreaElementRectangle(el, mapContainer) {
        var shapeAttr = nativeMethods.getAttribute.call(el, 'shape');
        var coordsAttr = nativeMethods.getAttribute.call(el, 'coords');
        if (shapeAttr === 'default')
            return getElementRectangle(mapContainer);
        if (!shapeAttr || !coordsAttr)
            return null;
        var coordsStrings = coordsAttr.split(',');
        var coords = [];
        if (!coords.length)
            return null;
        for (var i = 0; i < coords.length; i++) {
            coords[i] = parseInt(coordsStrings[i], 10);
            if (isNaN(coords[i]))
                return null;
        }
        var rectangle = null;
        switch (shapeAttr) {
            case 'rect':
                if (coords.length === 4) {
                    rectangle = {
                        height: coords[3] - coords[1],
                        left: coords[0],
                        top: coords[1],
                        width: coords[2] - coords[0],
                    };
                }
                break;
            case 'circle':
                if (coords.length === 3) {
                    rectangle = {
                        height: coords[2] * 2,
                        left: coords[0] - coords[2],
                        top: coords[1] - coords[2],
                        width: coords[2] * 2,
                    };
                }
                break;
            case 'poly':
                if (coords.length >= 6 && coords.length % 2 === 0) {
                    var left = coords[0];
                    var right = coords[0];
                    var top_1 = coords[1];
                    var bottom = coords[1];
                    for (var i = 2; i < coords.length; i += 2) {
                        left = coords[i] < left ? coords[i] : left;
                        right = coords[i] > right ? coords[i] : right;
                    }
                    for (var i = 3; i < coords.length; i += 2) {
                        top_1 = coords[i] < top_1 ? coords[i] : top_1;
                        bottom = coords[i] > bottom ? coords[i] : bottom;
                    }
                    rectangle = {
                        left: left, top: top_1,
                        height: bottom - top_1,
                        width: right - left,
                    };
                }
                break;
        }
        if (rectangle) {
            var containerOffset = getOffsetPosition(mapContainer);
            rectangle.left += containerOffset.left;
            rectangle.top += containerOffset.top;
        }
        return rectangle;
    }
    function getMapElementRectangle(el) {
        var mapContainer = getMapContainer(el);
        if (mapContainer) {
            var tagName = getTagName(el);
            if (tagName === 'map')
                return getElementRectangle(mapContainer);
            else if (tagName === 'area') {
                var areaElementRectangle = getAreaElementRectangle(el, mapContainer);
                if (areaElementRectangle)
                    return areaElementRectangle;
            }
        }
        return {
            height: 0,
            left: 0,
            top: 0,
            width: 0,
        };
    }
    function getElementRectangle(el) {
        var rectangle;
        if (isMapElement(el))
            rectangle = getMapElementRectangle(el);
        else if (isSelectVisibleChild(el))
            rectangle = getSelectChildRectangle(el);
        else {
            var element = el;
            var elementOffset = getOffsetPosition(element);
            var relativeRectangle = isSVGElementOrChild(element)
                ? getSvgElementRelativeRectangle(el)
                : element.getBoundingClientRect();
            rectangle = {
                height: relativeRectangle.height,
                left: elementOffset.left,
                top: elementOffset.top,
                width: relativeRectangle.width,
            };
        }
        rectangle.height = Math.round(rectangle.height);
        rectangle.left = Math.round(rectangle.left);
        rectangle.top = Math.round(rectangle.top);
        rectangle.width = Math.round(rectangle.width);
        return rectangle;
    }

    var position = /*#__PURE__*/Object.freeze({
        __proto__: null,
        offsetToClientCoords: offsetToClientCoords,
        getOffsetPosition: getOffsetPosition,
        getElementRectangle: getElementRectangle
    });

    var initializer$1 = { nativeMethods: nativeMethods, position: position, dom: dom, style: style, browser: { isChrome: true }, sendRequestToFrame: null };

    // -------------------------------------------------------------
    // WARNING: this file is used by both the client and the server.
    // Do not use any browser or node-specific API!
    // -------------------------------------------------------------
    var NODE_SNAPSHOT_PROPERTIES = [
        'nodeType',
        'textContent',
        'childNodeCount',
        'hasChildNodes',
        'childElementCount',
        'hasChildElements',
    ];
    var ELEMENT_ACTION_SNAPSHOT_PROPERTIES = [
        'tagName',
        'attributes',
    ];
    var ELEMENT_SNAPSHOT_PROPERTIES = [
        'tagName',
        'visible',
        'focused',
        'attributes',
        'boundingClientRect',
        'classNames',
        'style',
        'innerText',
        'namespaceURI',
        'id',
        'value',
        'checked',
        'selected',
        'selectedIndex',
        'scrollWidth',
        'scrollHeight',
        'scrollLeft',
        'scrollTop',
        'offsetWidth',
        'offsetHeight',
        'offsetLeft',
        'offsetTop',
        'clientWidth',
        'clientHeight',
        'clientLeft',
        'clientTop',
    ];

    var nodeSnapshotPropertyInitializers = {
        // eslint-disable-next-line no-restricted-properties
        childNodeCount: function (node) { return node.childNodes.length; },
        hasChildNodes: function (node) { return !!nodeSnapshotPropertyInitializers.childNodeCount(node); },
        childElementCount: function (node) {
            var children = node.children;
            if (children)
                // eslint-disable-next-line no-restricted-properties
                return children.length;
            // NOTE: IE doesn't have `children` for non-element nodes =/
            var childElementCount = 0;
            // eslint-disable-next-line no-restricted-properties
            var childNodeCount = node.childNodes.length;
            for (var i = 0; i < childNodeCount; i++) {
                // eslint-disable-next-line no-restricted-properties
                if (node.childNodes[i].nodeType === 1)
                    childElementCount++;
            }
            return childElementCount;
        },
        // eslint-disable-next-line no-restricted-properties
        hasChildElements: function (node) { return !!nodeSnapshotPropertyInitializers.childElementCount(node); },
    };
    var BaseSnapshot = /** @class */ (function () {
        function BaseSnapshot() {
        }
        BaseSnapshot.prototype._initializeProperties = function (node, properties, initializers) {
            for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
                var property = properties_1[_i];
                var initializer = initializers[property];
                this[property] = initializer ? initializer(node) : node[property];
            }
        };
        return BaseSnapshot;
    }());
    var NodeSnapshot = /** @class */ (function (_super) {
        __extends(NodeSnapshot, _super);
        function NodeSnapshot(node) {
            var _this = _super.call(this) || this;
            _this._initializeProperties(node, NODE_SNAPSHOT_PROPERTIES, nodeSnapshotPropertyInitializers);
            return _this;
        }
        return NodeSnapshot;
    }(BaseSnapshot));
    // Element
    var elementSnapshotPropertyInitializers = {
        tagName: function (element) { return element.tagName.toLowerCase(); },
        visible: function (element) { return adapter.isElementVisible(element); },
        focused: function (element) { return adapter.getActiveElement() === element; },
        attributes: function (element) {
            // eslint-disable-next-line no-restricted-properties
            var attrs = element.attributes;
            var result = {};
            for (var i = attrs.length - 1; i >= 0; i--)
                // eslint-disable-next-line no-restricted-properties
                result[attrs[i].name] = attrs[i].value;
            return result;
        },
        boundingClientRect: function (element) {
            var rect = element.getBoundingClientRect();
            return {
                left: rect.left,
                right: rect.right,
                top: rect.top,
                bottom: rect.bottom,
                width: rect.width,
                height: rect.height,
            };
        },
        classNames: function (element) {
            var className = element.className;
            if (typeof className.animVal === 'string')
                className = className.animVal;
            return className
                .replace(/^\s+|\s+$/g, '')
                .split(/\s+/g);
        },
        style: function (element) {
            var result = {};
            var computed = window.getComputedStyle(element);
            for (var i = 0; i < computed.length; i++) {
                var prop = computed[i];
                result[prop] = computed[prop];
            }
            return result;
        },
        // eslint-disable-next-line no-restricted-properties
        innerText: function (element) { return element.innerText; },
    };
    var ElementActionSnapshot = /** @class */ (function (_super) {
        __extends(ElementActionSnapshot, _super);
        function ElementActionSnapshot(element) {
            var _this = _super.call(this) || this;
            _this._initializeProperties(element, ELEMENT_ACTION_SNAPSHOT_PROPERTIES, elementSnapshotPropertyInitializers);
            return _this;
        }
        return ElementActionSnapshot;
    }(BaseSnapshot));
    var ElementSnapshot = /** @class */ (function (_super) {
        __extends(ElementSnapshot, _super);
        function ElementSnapshot(element) {
            var _this = _super.call(this, element) || this;
            _this._initializeProperties(element, ELEMENT_SNAPSHOT_PROPERTIES, elementSnapshotPropertyInitializers);
            return _this;
        }
        return ElementSnapshot;
    }(NodeSnapshot));

    var SelectorNodeTransform = /** @class */ (function () {
        function SelectorNodeTransform(customDOMProperties, instantiationCallsiteName) {
            if (customDOMProperties === void 0) { customDOMProperties = {}; }
            this.type = 'Node';
            this._customDOMProperties = customDOMProperties;
            this._instantiationCallsiteName = instantiationCallsiteName;
        }
        SelectorNodeTransform.prototype._extend = function (snapshot, node) {
            var props = adapter.nativeMethods.objectKeys(this._customDOMProperties);
            for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
                var prop = props_1[_i];
                try {
                    snapshot[prop] = this._customDOMProperties[prop](node);
                }
                catch (err) {
                    throw new UncaughtErrorInCustomDOMPropertyCode(this._instantiationCallsiteName, err, prop);
                }
            }
        };
        SelectorNodeTransform.prototype.shouldTransform = function (type, val) {
            return val instanceof adapter.nativeMethods.Node;
        };
        SelectorNodeTransform.prototype.toSerializable = function (node) {
            var snapshot = node.nodeType === 1 ? new ElementSnapshot(node) : new NodeSnapshot(node);
            this._extend(snapshot, node);
            return snapshot;
        };
        SelectorNodeTransform.prototype.fromSerializable = function () {
        };
        return SelectorNodeTransform;
    }());

    var CHECK_ELEMENT_DELAY = 200;

    var SelectorExecutor = /** @class */ (function (_super) {
        __extends(SelectorExecutor, _super);
        function SelectorExecutor(command, globalTimeout, startTime, createNotFoundError, createIsInvisibleError) {
            var _this = _super.call(this, command) || this;
            _this.createNotFoundError = createNotFoundError;
            _this.createIsInvisibleError = createIsInvisibleError;
            _this.timeout = typeof command.timeout === 'number' ? command.timeout : globalTimeout;
            _this.counterMode = _this.dependencies.filterOptions.counterMode;
            _this.getVisibleValueMode = _this.dependencies.filterOptions.getVisibleValueMode;
            _this.dependencies.selectorFilter = selectorFilter;
            if (startTime) {
                var elapsed = adapter.nativeMethods.dateNow() - startTime;
                _this.timeout = Math.max(_this.timeout - elapsed, 0);
            }
            var customDOMProperties = _this.dependencies.customDOMProperties;
            _this.replicator.addTransforms([
                new SelectorNodeTransform(customDOMProperties, command.instantiationCallsiteName),
            ]);
            return _this;
        }
        SelectorExecutor.prototype._createReplicator = function () {
            return createReplicator([
                new FunctionTransform(),
            ]);
        };
        SelectorExecutor.prototype._getTimeoutErrorParams = function () {
            var apiFnIndex = selectorFilter.error;
            var apiFnChain = this.command.apiFnChain;
            return { apiFnIndex: apiFnIndex, apiFnChain: apiFnChain };
        };
        SelectorExecutor.prototype._getTimeoutError = function (elementExists) {
            return elementExists ? this.createIsInvisibleError : this.createNotFoundError;
        };
        SelectorExecutor.prototype._validateElement = function (args, startTime) {
            var _this = this;
            return adapter.PromiseCtor.resolve()
                .then(function () { return _super.prototype._executeFn.call(_this, args); })
                .then(function (el) {
                var element = el;
                var isElementExists = !!element;
                var isElementVisible = !_this.command.visibilityCheck || element && visible(element);
                var isTimeout = adapter.nativeMethods.dateNow() - startTime >= _this.timeout;
                if (isElementExists && (isElementVisible || adapter.isShadowRoot(element)))
                    return element;
                if (!isTimeout)
                    return adapter.delay(CHECK_ELEMENT_DELAY).then(function () { return _this._validateElement(args, startTime); });
                var createTimeoutError = _this.getVisibleValueMode ? null : _this._getTimeoutError(isElementExists);
                if (createTimeoutError)
                    throw createTimeoutError(_this._getTimeoutErrorParams());
                return null;
            });
        };
        SelectorExecutor.prototype._executeFn = function (args) {
            if (this.counterMode)
                return _super.prototype._executeFn.call(this, args);
            return this._validateElement(args, adapter.nativeMethods.dateNow());
        };
        return SelectorExecutor;
    }(ClientFunctionExecutor));

    function createErrorCtorCallback(errCtor) {
        // @ts-ignore
        var Error = typeof errCtor === 'string' ? Errors[errCtor] : Errors[errCtor.name];
        var firstArg = typeof errCtor === 'string' ? null : errCtor.firstArg;
        return function (fn) { return new Error(firstArg, fn); };
    }

    var SCROLLABLE_OVERFLOW_STYLE_RE = /auto|scroll|hidden/i;
    var DEFAULT_IE_SCROLLABLE_OVERFLOW_STYLE_VALUE = 'visible';
    function getScrollable(el) {
        var overflowX = adapter$1.style.get(el, 'overflowX');
        var overflowY = adapter$1.style.get(el, 'overflowY');
        var scrollableHorizontally = SCROLLABLE_OVERFLOW_STYLE_RE.test(overflowX);
        var scrollableVertically = SCROLLABLE_OVERFLOW_STYLE_RE.test(overflowY);
        // IE11 and MS Edge bug: There are two properties: overflow-x and overflow-y.
        // If one property is set so that the browser may show scrollbars (`auto` or `scroll`) and the second one is set to 'visible',
        // then the second one will work as if it had the 'auto' value.
        if (adapter$1.browser.isIE) {
            scrollableHorizontally = scrollableHorizontally || scrollableVertically && overflowX === DEFAULT_IE_SCROLLABLE_OVERFLOW_STYLE_VALUE;
            scrollableVertically = scrollableVertically || scrollableHorizontally && overflowY === DEFAULT_IE_SCROLLABLE_OVERFLOW_STYLE_VALUE;
        }
        return new AxisValues(scrollableHorizontally, scrollableVertically);
    }
    function hasBodyScroll(el) {
        var overflowX = adapter$1.style.get(el, 'overflowX');
        var overflowY = adapter$1.style.get(el, 'overflowY');
        var scrollableHorizontally = SCROLLABLE_OVERFLOW_STYLE_RE.test(overflowX);
        var scrollableVertically = SCROLLABLE_OVERFLOW_STYLE_RE.test(overflowY);
        var documentElement = adapter$1.dom.findDocument(el).documentElement;
        var bodyScrollHeight = el.scrollHeight;
        if (adapter$1.browser.isChrome || adapter$1.browser.isFirefox || adapter$1.browser.isSafari) {
            var bodyTop = el.getBoundingClientRect().top;
            var documentTop = documentElement.getBoundingClientRect().top;
            bodyScrollHeight = bodyScrollHeight - documentTop + bodyTop;
        }
        return (scrollableHorizontally || scrollableVertically) &&
            bodyScrollHeight > documentElement.scrollHeight;
    }
    function hasHTMLElementScroll(el) {
        var overflowX = adapter$1.style.get(el, 'overflowX');
        var overflowY = adapter$1.style.get(el, 'overflowY');
        //T303226
        if (overflowX === 'hidden' && overflowY === 'hidden')
            return false;
        var hasHorizontalScroll = el.scrollHeight > el.clientHeight;
        var hasVerticalScroll = el.scrollWidth > el.clientWidth;
        if (hasHorizontalScroll || hasVerticalScroll)
            return true;
        //T174562 - wrong scrolling in iframes without src and others iframes
        var body = el.getElementsByTagName('body')[0];
        if (!body)
            return false;
        if (hasBodyScroll(body))
            return false;
        var clientWidth = Math.min(el.clientWidth, body.clientWidth);
        var clientHeight = Math.min(el.clientHeight, body.clientHeight);
        return body.scrollHeight > clientHeight || body.scrollWidth > clientWidth;
    }
    function hasScroll(el) {
        if (adapter$1.dom.isBodyElement(el))
            return hasBodyScroll(el);
        if (adapter$1.dom.isHtmlElement(el))
            return hasHTMLElementScroll(el);
        var scrollable = getScrollable(el);
        if (!scrollable.x && !scrollable.y)
            return false;
        var hasVerticalScroll = scrollable.y && el.scrollHeight > el.clientHeight;
        var hasHorizontalScroll = scrollable.x && el.scrollWidth > el.clientWidth;
        return hasHorizontalScroll || hasVerticalScroll;
    }
    function getScrollableParents(element) {
        var parentsArray = adapter$1.dom.getParents(element);
        if (adapter$1.dom.isElementInIframe(element)) {
            var iframe = adapter$1.dom.getIframeByElement(element);
            if (iframe) {
                var iFrameParents = adapter$1.dom.getParents(iframe);
                parentsArray.concat(iFrameParents);
            }
        }
        return adapter$1.nativeMethods.arrayFilter.call(parentsArray, hasScroll);
    }

    var BoundaryValues = /** @class */ (function () {
        function BoundaryValues(top, right, bottom, left) {
            if (top === void 0) { top = 0; }
            if (right === void 0) { right = 0; }
            if (bottom === void 0) { bottom = 0; }
            if (left === void 0) { left = 0; }
            this.top = top;
            this.right = right;
            this.bottom = bottom;
            this.left = left;
        }
        BoundaryValues.create = function (v) {
            return new BoundaryValues(v.top, v.right, v.bottom, v.left);
        };
        BoundaryValues.prototype.add = function (d) {
            this.top += d.top;
            this.right += d.right;
            this.bottom += d.bottom;
            this.left += d.left;
            return this;
        };
        BoundaryValues.prototype.sub = function (d) {
            if ('top' in d) {
                this.top -= d.top;
                this.left -= d.left;
            }
            this.bottom -= d.bottom;
            this.right -= d.right;
            return this;
        };
        BoundaryValues.prototype.round = function (leftTopRound, rightBottomRound) {
            if (leftTopRound === void 0) { leftTopRound = Math.round; }
            if (rightBottomRound === void 0) { rightBottomRound = leftTopRound; }
            this.top = leftTopRound(this.top);
            this.right = rightBottomRound(this.right);
            this.bottom = rightBottomRound(this.bottom);
            this.left = leftTopRound(this.left);
            return this;
        };
        BoundaryValues.prototype.contains = function (point) {
            return point.x >= this.left && point.x <= this.right && point.y >= this.top && point.y <= this.bottom;
        };
        return BoundaryValues;
    }());

    var Dimensions = /** @class */ (function () {
        function Dimensions(width, height, position, borders, elScroll, scrollbar) {
            this.width = width;
            this.height = height;
            this.left = position.x;
            this.top = position.y;
            this.right = position.x + width;
            this.bottom = position.y + height;
            this.border = borders;
            this.scrollbar = scrollbar;
            this.scroll = elScroll;
        }
        return Dimensions;
    }());

    function getClientDimensions(target) {
        var isHtmlElement = adapter$1.dom.isHtmlElement(target);
        var body = isHtmlElement ? target.getElementsByTagName('body')[0] : null;
        var elementRect = target.getBoundingClientRect();
        var elBorders = BoundaryValues.create(adapter$1.style.getBordersWidth(target));
        var elScroll = adapter$1.style.getElementScroll(target);
        var isElementInIframe = adapter$1.dom.isElementInIframe(target);
        var isCompatMode = target.ownerDocument.compatMode === 'BackCompat';
        var elPosition = isHtmlElement ? new AxisValues(0, 0) : AxisValues.create(elementRect);
        var elHeight = elementRect.height;
        var elWidth = elementRect.width;
        if (isHtmlElement) {
            if (body && isCompatMode) {
                elHeight = body.clientHeight;
                elWidth = body.clientWidth;
            }
            else {
                elHeight = target.clientHeight;
                elWidth = target.clientWidth;
            }
        }
        if (isElementInIframe) {
            var iframeElement = adapter$1.dom.getIframeByElement(target);
            if (iframeElement) {
                var iframeOffset = adapter$1.position.getOffsetPosition(iframeElement);
                var clientOffset = adapter$1.position.offsetToClientCoords(AxisValues.create(iframeOffset));
                var iframeBorders = adapter$1.style.getBordersWidth(iframeElement);
                elPosition.add(clientOffset).add(AxisValues.create(iframeBorders));
                if (isHtmlElement)
                    elBorders.add(iframeBorders);
            }
        }
        var hasRightScrollbar = !isHtmlElement && adapter$1.style.getInnerWidth(target) !== target.clientWidth;
        var hasBottomScrollbar = !isHtmlElement && adapter$1.style.getInnerHeight(target) !== target.clientHeight;
        var scrollbar = {
            right: hasRightScrollbar ? adapter$1.dom.getScrollbarSize() : 0,
            bottom: hasBottomScrollbar ? adapter$1.dom.getScrollbarSize() : 0,
        };
        return new Dimensions(elWidth, elHeight, elPosition, elBorders, elScroll, scrollbar);
    }
    function getElementFromPoint(_a) {
        var x = _a.x, y = _a.y;
        // @ts-ignore
        var ieFn = document.getElementFromPoint;
        var func = ieFn || document.elementFromPoint;
        var el = null;
        try {
            // Permission denied to access property 'getElementFromPoint' error in iframe
            el = func.call(document, x, y);
        }
        catch (_b) {
            return null;
        }
        //NOTE: elementFromPoint returns null when is's a border of an iframe
        if (el === null)
            el = func.call(document, x - 1, y - 1);
        while (el && el.shadowRoot && el.shadowRoot.elementFromPoint) {
            var shadowEl = el.shadowRoot.elementFromPoint(x, y);
            if (!shadowEl || el === shadowEl)
                break;
            el = shadowEl;
        }
        return el;
    }
    function calcRelativePosition(dimensions, toDimensions) {
        var pos = BoundaryValues.create({
            top: dimensions.top - toDimensions.top,
            left: dimensions.left - toDimensions.left,
            right: toDimensions.right - dimensions.right,
            bottom: toDimensions.bottom - dimensions.bottom,
        });
        return pos.sub(toDimensions.border).sub(toDimensions.scrollbar).round(Math.ceil, Math.floor);
    }

    function times(n, iterator) {
        return __awaiter(this, void 0, void 0, function () {
            var i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < n)) return [3 /*break*/, 4];
                        return [4 /*yield*/, iterator(i)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    }

    function isIframeWindow(window) {
        return window.top !== window;
    }

    var DEFAULT_MAX_SCROLL_MARGIN = 50;
    var SCROLL_MARGIN_INCREASE_STEP = 20;
    var ScrollAutomation = /** @class */ (function () {
        function ScrollAutomation(element, scrollOptions, maxScrollMargin) {
            this._element = element;
            this._offsets = new AxisValues(scrollOptions.offsetX, scrollOptions.offsetY);
            this._scrollToCenter = !!scrollOptions.scrollToCenter;
            this._skipParentFrames = !!scrollOptions.skipParentFrames;
            this._maxScrollMargin = maxScrollMargin || { left: DEFAULT_MAX_SCROLL_MARGIN, top: DEFAULT_MAX_SCROLL_MARGIN };
            this._scrollWasPerformed = false;
        }
        ScrollAutomation._isScrollValuesChanged = function (scrollElement, originalScroll) {
            return adapter$1.style.getScrollLeft(scrollElement) !== originalScroll.left ||
                adapter$1.style.getScrollTop(scrollElement) !== originalScroll.top;
        };
        ScrollAutomation.prototype._setScroll = function (element, _a) {
            var _this = this;
            var left = _a.left, top = _a.top;
            var scrollElement = adapter$1.dom.isHtmlElement(element) ? adapter$1.dom.findDocument(element) : element;
            var originalScroll = {
                left: adapter$1.style.getScrollLeft(scrollElement),
                top: adapter$1.style.getScrollTop(scrollElement),
            };
            left = Math.max(left, 0);
            top = Math.max(top, 0);
            var scrollPromise = emptyAdapter.controller.waitForScroll(scrollElement);
            adapter$1.style.setScrollLeft(scrollElement, left);
            adapter$1.style.setScrollTop(scrollElement, top);
            if (!ScrollAutomation._isScrollValuesChanged(scrollElement, originalScroll)) {
                // @ts-ignore
                scrollPromise.cancel();
                return emptyAdapter.PromiseCtor.resolve();
            }
            scrollPromise = scrollPromise.then(function () {
                if (!_this._scrollWasPerformed)
                    _this._scrollWasPerformed = ScrollAutomation._isScrollValuesChanged(scrollElement, originalScroll);
            });
            return scrollPromise;
        };
        ScrollAutomation.prototype._getScrollToPoint = function (dimensions, point, maxScrollMargin) {
            var horizontalCenter = Math.floor(dimensions.width / 2);
            var verticalCenter = Math.floor(dimensions.height / 2);
            var leftScrollMargin = this._scrollToCenter ? horizontalCenter : Math.min(maxScrollMargin.left, horizontalCenter);
            var topScrollMargin = this._scrollToCenter ? verticalCenter : Math.min(maxScrollMargin.top, verticalCenter);
            var _a = dimensions.scroll, left = _a.left, top = _a.top;
            var needForwardScrollLeft = point.x >= left + dimensions.width - leftScrollMargin;
            var needBackwardScrollLeft = point.x <= left + leftScrollMargin;
            var needForwardScrollTop = point.y >= top + dimensions.height - topScrollMargin;
            var needBackwardScrollTop = point.y <= top + topScrollMargin;
            if (needForwardScrollLeft)
                left = point.x - dimensions.width + leftScrollMargin;
            else if (needBackwardScrollLeft)
                left = point.x - leftScrollMargin;
            if (needForwardScrollTop)
                top = point.y - dimensions.height + topScrollMargin;
            else if (needBackwardScrollTop)
                top = point.y - topScrollMargin;
            return { left: left, top: top };
        };
        ScrollAutomation.prototype._getScrollToFullChildView = function (parentDimensions, childDimensions, maxScrollMargin) {
            var fullViewScroll = { left: null, top: null };
            var canShowFullElementWidth = parentDimensions.width >= childDimensions.width;
            var canShowFullElementHeight = parentDimensions.height >= childDimensions.height;
            var relativePosition = calcRelativePosition(childDimensions, parentDimensions);
            if (canShowFullElementWidth) {
                var availableLeftScrollMargin = parentDimensions.width - childDimensions.width;
                var leftScrollMargin = Math.min(maxScrollMargin.left, availableLeftScrollMargin);
                if (this._scrollToCenter)
                    leftScrollMargin = availableLeftScrollMargin / 2;
                if (relativePosition.left < leftScrollMargin)
                    fullViewScroll.left = Math.round(parentDimensions.scroll.left + relativePosition.left - leftScrollMargin);
                else if (relativePosition.right < leftScrollMargin) {
                    fullViewScroll.left = Math.round(parentDimensions.scroll.left +
                        Math.min(relativePosition.left, -relativePosition.right) +
                        leftScrollMargin);
                }
            }
            if (canShowFullElementHeight) {
                var availableTopScrollMargin = parentDimensions.height - childDimensions.height;
                var topScrollMargin = Math.min(maxScrollMargin.top, availableTopScrollMargin);
                if (this._scrollToCenter)
                    topScrollMargin = availableTopScrollMargin / 2;
                if (relativePosition.top < topScrollMargin)
                    fullViewScroll.top = Math.round(parentDimensions.scroll.top + relativePosition.top - topScrollMargin);
                else if (relativePosition.bottom < topScrollMargin) {
                    fullViewScroll.top = Math.round(parentDimensions.scroll.top +
                        Math.min(relativePosition.top, -relativePosition.bottom) +
                        topScrollMargin);
                }
            }
            return fullViewScroll;
        };
        ScrollAutomation._getChildPoint = function (parentDimensions, childDimensions, offsets) {
            return AxisValues.create(childDimensions)
                .sub(AxisValues.create(parentDimensions))
                .add(AxisValues.create(parentDimensions.scroll))
                .add(AxisValues.create(childDimensions.border))
                .add(offsets);
        };
        ScrollAutomation.prototype._getScrollPosition = function (parentDimensions, childDimensions, offsets, maxScrollMargin) {
            var childPoint = ScrollAutomation._getChildPoint(parentDimensions, childDimensions, offsets);
            var scrollToPoint = this._getScrollToPoint(parentDimensions, childPoint, maxScrollMargin);
            var scrollToFullView = this._getScrollToFullChildView(parentDimensions, childDimensions, maxScrollMargin);
            return {
                left: Math.max(scrollToFullView.left === null ? scrollToPoint.left : scrollToFullView.left, 0),
                top: Math.max(scrollToFullView.top === null ? scrollToPoint.top : scrollToFullView.top, 0),
            };
        };
        ScrollAutomation._getChildPointAfterScroll = function (parentDimensions, childDimensions, currentScroll, offsets) {
            return AxisValues.create(childDimensions)
                .add(AxisValues.create(parentDimensions.scroll))
                .sub(AxisValues.create(currentScroll))
                .add(offsets);
        };
        ScrollAutomation.prototype._isChildFullyVisible = function (parentDimensions, childDimensions, offsets) {
            var childPoint = ScrollAutomation._getChildPointAfterScroll(parentDimensions, childDimensions, parentDimensions.scroll, offsets);
            var zeroMargin = { left: 0, top: 0 };
            var _a = this._getScrollPosition(parentDimensions, childDimensions, offsets, zeroMargin), left = _a.left, top = _a.top;
            return !this._isTargetElementObscuredInPoint(childPoint) &&
                left === parentDimensions.scroll.left && top === parentDimensions.scroll.top;
        };
        ScrollAutomation.prototype._scrollToChild = function (parent, child, offsets) {
            var parentDimensions = getClientDimensions(parent);
            var childDimensions = getClientDimensions(child);
            var windowWidth = adapter$1.style.getInnerWidth(window);
            var windowHeight = adapter$1.style.getInnerHeight(window);
            var scrollPos = parentDimensions.scroll;
            var needScroll = !this._isChildFullyVisible(parentDimensions, childDimensions, offsets);
            while (needScroll) {
                scrollPos = this._getScrollPosition(parentDimensions, childDimensions, offsets, this._maxScrollMargin);
                var childPoint = ScrollAutomation._getChildPointAfterScroll(parentDimensions, childDimensions, scrollPos, offsets);
                var isTargetObscured = this._isTargetElementObscuredInPoint(childPoint);
                this._maxScrollMargin.left += SCROLL_MARGIN_INCREASE_STEP;
                if (this._maxScrollMargin.left >= windowWidth) {
                    this._maxScrollMargin.left = DEFAULT_MAX_SCROLL_MARGIN;
                    this._maxScrollMargin.top += SCROLL_MARGIN_INCREASE_STEP;
                }
                needScroll = isTargetObscured && this._maxScrollMargin.top < windowHeight;
            }
            this._maxScrollMargin = { left: DEFAULT_MAX_SCROLL_MARGIN, top: DEFAULT_MAX_SCROLL_MARGIN };
            return this._setScroll(parent, scrollPos);
        };
        ScrollAutomation.prototype._scrollElement = function () {
            if (!hasScroll(this._element))
                return emptyAdapter.PromiseCtor.resolve();
            var elementDimensions = getClientDimensions(this._element);
            var scroll = this._getScrollToPoint(elementDimensions, this._offsets, this._maxScrollMargin);
            return this._setScroll(this._element, scroll);
        };
        ScrollAutomation.prototype._scrollParents = function () {
            var _this = this;
            var parents = getScrollableParents(this._element);
            var currentChild = this._element;
            var scrollLeft = adapter$1.style.getScrollLeft(currentChild);
            var scrollTop = adapter$1.style.getScrollTop(currentChild);
            var currentOffset = AxisValues.create(this._offsets).sub(new AxisValues(scrollLeft, scrollTop).round());
            var childDimensions = null;
            var parentDimensions = null;
            var scrollParentsPromise = times(parents.length, function (i) {
                return _this._scrollToChild(parents[i], currentChild, currentOffset)
                    .then(function () {
                    childDimensions = getClientDimensions(currentChild);
                    parentDimensions = getClientDimensions(parents[i]);
                    currentOffset.add(AxisValues.create(childDimensions))
                        .sub(AxisValues.create(parentDimensions))
                        .add(AxisValues.create(parentDimensions.border));
                    currentChild = parents[i];
                });
            });
            var state = {
                scrollWasPerformed: this._scrollWasPerformed,
                offsetX: currentOffset.x,
                offsetY: currentOffset.y,
                maxScrollMargin: this._maxScrollMargin,
            };
            if (!adapter$1.sendRequestToFrame)
                return scrollParentsPromise.then(function () { return state; });
            return scrollParentsPromise
                .then(function () {
                if (_this._skipParentFrames || !isIframeWindow(window))
                    return;
                state.cmd = ScrollAutomation.SCROLL_REQUEST_CMD;
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, consistent-return
                return adapter$1.sendRequestToFrame(state, ScrollAutomation.SCROLL_RESPONSE_CMD, window.parent);
            })
                .then(function () { return _this._scrollWasPerformed; });
        };
        ScrollAutomation._getFixedAncestorOrSelf = function (element) {
            return adapter$1.dom.findParent(element, true, isFixedElement);
        };
        ScrollAutomation.prototype._isTargetElementObscuredInPoint = function (point) {
            var elementInPoint = getElementFromPoint(point);
            if (!elementInPoint)
                return false;
            var fixedElement = ScrollAutomation._getFixedAncestorOrSelf(elementInPoint);
            return !!fixedElement && !fixedElement.contains(this._element);
        };
        ScrollAutomation.prototype.run = function () {
            var _this = this;
            return this._scrollElement()
                .then(function () { return _this._scrollParents(); });
        };
        ScrollAutomation.SCROLL_REQUEST_CMD = 'automation|scroll|request';
        ScrollAutomation.SCROLL_RESPONSE_CMD = 'automation|scroll|response';
        return ScrollAutomation;
    }());

    /* eslint-disable no-restricted-globals */
    initializeAdapter$1(initializer);
    initializeAdapter$2(initializer$1);
    Object.defineProperty(window, '%proxyless%', {
        value: {
            executeClientFunctionCommand: function (command) {
                var executor = new ClientFunctionExecutor(command);
                return executor.getResult()
                    .then(function (result) { return JSON.stringify(executor.encodeResult(result)); });
            },
            executeSelectorCommand: function (command, selectorTimeout, startTime, returnNode, errCtors) {
                var createNotFoundError = command.needError ? createErrorCtorCallback(errCtors.notFound) : null;
                var createIsInvisibleError = command.needError ? createErrorCtorCallback(errCtors.invisible) : null;
                var selectorExecutor = new SelectorExecutor(command, selectorTimeout, startTime, createNotFoundError, createIsInvisibleError);
                return selectorExecutor.getResult()
                    .then(function (result) { return returnNode ? result : JSON.stringify(selectorExecutor.encodeResult(result)); });
            },
            scroll: function (el, opts, margin) {
                var scrollAutomation = new ScrollAutomation(el, opts, margin);
                return scrollAutomation.run();
            },
            nativeMethods: nativeMethods,
        },
        configurable: true,
    });

}());
