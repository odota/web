"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const testcafe_hammerhead_1 = require("testcafe-hammerhead");
const EVENT_CONSTRUCTORS = [
    testcafe_hammerhead_1.RequestEvent,
    testcafe_hammerhead_1.ConfigureResponseEvent,
    testcafe_hammerhead_1.ResponseEvent,
];
const EVENT_CONSTRUCTORS_MAP = new Map(EVENT_CONSTRUCTORS.map(eventConstructor => {
    return [eventConstructor.name, eventConstructor];
}));
class RequestHookEventDataTransform {
    constructor() {
        this.type = 'RequestHookEventData';
    }
    shouldTransform(_, val) {
        return EVENT_CONSTRUCTORS.some(EventConstructor => val instanceof EventConstructor);
    }
    toSerializable(value) {
        // TODO: Remove eventData._requestContext into 'testcafe-hammerhead' module
        // after switching to the compiler service mode.
        // NOTE: Access to the deprecated property inside of the unserializable 'eventData._requestContext' property
        // causes the node's deprecation warning.
        const clonedEventData = Object.assign({}, value);
        // @ts-ignore
        delete clonedEventData._requestContext;
        return {
            constructorName: value.constructor.name,
            data: clonedEventData,
        };
    }
    fromSerializable(value) {
        const EventConstructor = EVENT_CONSTRUCTORS_MAP.get(value.constructorName);
        if (!EventConstructor)
            throw new Error(`An appropriate command constructor for "${value.constructorName}" type was not found.`);
        return EventConstructor.from(value.data);
    }
}
exports.default = RequestHookEventDataTransform;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVxdWVzdC1ob29rLWV2ZW50LWRhdGEtdHJhbnNmb3JtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL3NlcnZpY2VzL3NlcmlhbGl6YXRpb24vcmVwbGljYXRvci90cmFuc2Zvcm1zL3JlcXVlc3QtaG9vay1ldmVudC1kYXRhLXRyYW5zZm9ybS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDZEQUk2QjtBQUc3QixNQUFNLGtCQUFrQixHQUFHO0lBQ3ZCLGtDQUFZO0lBQ1osNENBQXNCO0lBQ3RCLG1DQUFhO0NBQ2hCLENBQUM7QUFJRixNQUFNLHNCQUFzQixHQUFHLElBQUksR0FBRyxDQUEyQixrQkFBa0IsQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtJQUN2RyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLGdCQUFnQixDQUFDLENBQUM7QUFDckQsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQU9KLE1BQXFCLDZCQUE2QjtJQUc5QztRQUNJLElBQUksQ0FBQyxJQUFJLEdBQUcsc0JBQXNCLENBQUM7SUFDdkMsQ0FBQztJQUVNLGVBQWUsQ0FBRSxDQUFVLEVBQUUsR0FBWTtRQUM1QyxPQUFPLGtCQUFrQixDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLGdCQUFnQixDQUFDLENBQUM7SUFDeEYsQ0FBQztJQUVNLGNBQWMsQ0FBRSxLQUE0RDtRQUMvRSwyRUFBMkU7UUFDM0UsZ0RBQWdEO1FBRWhELDRHQUE0RztRQUM1Ryx5Q0FBeUM7UUFDekMsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFakQsYUFBYTtRQUNiLE9BQU8sZUFBZSxDQUFDLGVBQWUsQ0FBQztRQUV2QyxPQUFPO1lBQ0gsZUFBZSxFQUFFLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSTtZQUN2QyxJQUFJLEVBQWEsZUFBZTtTQUNuQyxDQUFDO0lBQ04sQ0FBQztJQUVNLGdCQUFnQixDQUFFLEtBQWlDO1FBQ3RELE1BQU0sZ0JBQWdCLEdBQUcsc0JBQXNCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUUzRSxJQUFJLENBQUMsZ0JBQWdCO1lBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLEtBQUssQ0FBQyxlQUFlLHVCQUF1QixDQUFDLENBQUM7UUFFN0csT0FBTyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzdDLENBQUM7Q0FDSjtBQXBDRCxnREFvQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbmZpZ3VyZVJlc3BvbnNlRXZlbnQsXG4gICAgUmVxdWVzdEV2ZW50LFxuICAgIFJlc3BvbnNlRXZlbnQsXG59IGZyb20gJ3Rlc3RjYWZlLWhhbW1lcmhlYWQnO1xuXG5cbmNvbnN0IEVWRU5UX0NPTlNUUlVDVE9SUyA9IFtcbiAgICBSZXF1ZXN0RXZlbnQsXG4gICAgQ29uZmlndXJlUmVzcG9uc2VFdmVudCxcbiAgICBSZXNwb25zZUV2ZW50LFxuXTtcblxudHlwZSBFdmVudENvbnN0cnVjdG9yID0gdHlwZW9mIFJlcXVlc3RFdmVudCB8IHR5cGVvZiBDb25maWd1cmVSZXNwb25zZUV2ZW50IHwgdHlwZW9mIFJlc3BvbnNlRXZlbnQ7XG5cbmNvbnN0IEVWRU5UX0NPTlNUUlVDVE9SU19NQVAgPSBuZXcgTWFwPHN0cmluZywgRXZlbnRDb25zdHJ1Y3Rvcj4oRVZFTlRfQ09OU1RSVUNUT1JTLm1hcChldmVudENvbnN0cnVjdG9yID0+IHtcbiAgICByZXR1cm4gW2V2ZW50Q29uc3RydWN0b3IubmFtZSwgZXZlbnRDb25zdHJ1Y3Rvcl07XG59KSk7XG5cbmludGVyZmFjZSBTZXJpYWxpemVkUmVxdWVzdEhvb2tFdmVudCB7XG4gICAgY29uc3RydWN0b3JOYW1lOiBzdHJpbmc7XG4gICAgZGF0YTogdW5rbm93bjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVxdWVzdEhvb2tFdmVudERhdGFUcmFuc2Zvcm0ge1xuICAgIHB1YmxpYyByZWFkb25seSB0eXBlOiBzdHJpbmc7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IgKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnUmVxdWVzdEhvb2tFdmVudERhdGEnO1xuICAgIH1cblxuICAgIHB1YmxpYyBzaG91bGRUcmFuc2Zvcm0gKF86IHVua25vd24sIHZhbDogdW5rbm93bik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gRVZFTlRfQ09OU1RSVUNUT1JTLnNvbWUoRXZlbnRDb25zdHJ1Y3RvciA9PiB2YWwgaW5zdGFuY2VvZiBFdmVudENvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdG9TZXJpYWxpemFibGUgKHZhbHVlOiBSZXF1ZXN0RXZlbnQgfCBDb25maWd1cmVSZXNwb25zZUV2ZW50IHwgUmVzcG9uc2VFdmVudCk6IFNlcmlhbGl6ZWRSZXF1ZXN0SG9va0V2ZW50IHtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIGV2ZW50RGF0YS5fcmVxdWVzdENvbnRleHQgaW50byAndGVzdGNhZmUtaGFtbWVyaGVhZCcgbW9kdWxlXG4gICAgICAgIC8vIGFmdGVyIHN3aXRjaGluZyB0byB0aGUgY29tcGlsZXIgc2VydmljZSBtb2RlLlxuXG4gICAgICAgIC8vIE5PVEU6IEFjY2VzcyB0byB0aGUgZGVwcmVjYXRlZCBwcm9wZXJ0eSBpbnNpZGUgb2YgdGhlIHVuc2VyaWFsaXphYmxlICdldmVudERhdGEuX3JlcXVlc3RDb250ZXh0JyBwcm9wZXJ0eVxuICAgICAgICAvLyBjYXVzZXMgdGhlIG5vZGUncyBkZXByZWNhdGlvbiB3YXJuaW5nLlxuICAgICAgICBjb25zdCBjbG9uZWRFdmVudERhdGEgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSk7XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBkZWxldGUgY2xvbmVkRXZlbnREYXRhLl9yZXF1ZXN0Q29udGV4dDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29uc3RydWN0b3JOYW1lOiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgZGF0YTogICAgICAgICAgICBjbG9uZWRFdmVudERhdGEsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHVibGljIGZyb21TZXJpYWxpemFibGUgKHZhbHVlOiBTZXJpYWxpemVkUmVxdWVzdEhvb2tFdmVudCk6IHVua25vd24ge1xuICAgICAgICBjb25zdCBFdmVudENvbnN0cnVjdG9yID0gRVZFTlRfQ09OU1RSVUNUT1JTX01BUC5nZXQodmFsdWUuY29uc3RydWN0b3JOYW1lKTtcblxuICAgICAgICBpZiAoIUV2ZW50Q29uc3RydWN0b3IpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIGFwcHJvcHJpYXRlIGNvbW1hbmQgY29uc3RydWN0b3IgZm9yIFwiJHt2YWx1ZS5jb25zdHJ1Y3Rvck5hbWV9XCIgdHlwZSB3YXMgbm90IGZvdW5kLmApO1xuXG4gICAgICAgIHJldHVybiBFdmVudENvbnN0cnVjdG9yLmZyb20odmFsdWUuZGF0YSk7XG4gICAgfVxufVxuIl19