"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const hook_1 = __importDefault(require("./hook"));
const testcafe_hammerhead_1 = require("testcafe-hammerhead");
const runtime_1 = require("../../errors/runtime");
const types_1 = require("../../errors/types");
const warning_message_1 = __importDefault(require("../../notifications/warning-message"));
class RequestMock extends hook_1.default {
    constructor() {
        super([]);
        this.pendingRequestFilterRuleInit = null;
        this.mocks = new Map();
    }
    async onRequest(event) {
        const mock = this.mocks.get(event._requestFilterRule);
        event.setMock(mock);
    }
    async onResponse(event) {
        if (event.statusCode === testcafe_hammerhead_1.SAME_ORIGIN_CHECK_FAILED_STATUS_CODE)
            this.warningLog.addWarning(warning_message_1.default.requestMockCORSValidationFailed, RequestMock.name, event._requestFilterRule);
    }
    // API
    onRequestTo(requestFilterRuleInit) {
        if (this.pendingRequestFilterRuleInit)
            throw new runtime_1.APIError('onRequestTo', types_1.RUNTIME_ERRORS.requestHookConfigureAPIError, RequestMock.name, "The 'respond' method was not called after 'onRequestTo'. You must call the 'respond' method to provide the mocked response.");
        this.pendingRequestFilterRuleInit = requestFilterRuleInit;
        return this;
    }
    respond(body, statusCode, headers) {
        if (!this.pendingRequestFilterRuleInit)
            throw new runtime_1.APIError('respond', types_1.RUNTIME_ERRORS.requestHookConfigureAPIError, RequestMock.name, "The 'onRequestTo' method was not called before 'respond'. You must call the 'onRequestTo' method to provide the URL requests to which are mocked.");
        const mock = new testcafe_hammerhead_1.ResponseMock(body, statusCode, headers);
        const rule = new testcafe_hammerhead_1.RequestFilterRule(this.pendingRequestFilterRuleInit);
        this.requestFilterRules.push(rule);
        this.mocks.set(rule, mock);
        this.pendingRequestFilterRuleInit = null;
        return this;
    }
}
function createRequestMock() {
    return new RequestMock();
}
exports.default = createRequestMock;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVxdWVzdC1tb2NrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2FwaS9yZXF1ZXN0LWhvb2tzL3JlcXVlc3QtbW9jay5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGtEQUFpQztBQUNqQyw2REFJNkI7QUFFN0Isa0RBQWdEO0FBQ2hELDhDQUFvRDtBQUNwRCwwRkFBa0U7QUFFbEUsTUFBTSxXQUFZLFNBQVEsY0FBVztJQUNqQztRQUNJLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVWLElBQUksQ0FBQyw0QkFBNEIsR0FBRyxJQUFJLENBQUM7UUFDekMsSUFBSSxDQUFDLEtBQUssR0FBMEIsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNsRCxDQUFDO0lBRUQsS0FBSyxDQUFDLFNBQVMsQ0FBRSxLQUFLO1FBQ2xCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBRXRELEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVELEtBQUssQ0FBQyxVQUFVLENBQUUsS0FBSztRQUNuQixJQUFJLEtBQUssQ0FBQyxVQUFVLEtBQUssMERBQW9DO1lBQ3pELElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLHlCQUFlLENBQUMsK0JBQStCLEVBQUUsV0FBVyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUNoSSxDQUFDO0lBRUQsTUFBTTtJQUNOLFdBQVcsQ0FBRSxxQkFBcUI7UUFDOUIsSUFBSSxJQUFJLENBQUMsNEJBQTRCO1lBQ2pDLE1BQU0sSUFBSSxrQkFBUSxDQUFDLGFBQWEsRUFBRSxzQkFBYyxDQUFDLDRCQUE0QixFQUFFLFdBQVcsQ0FBQyxJQUFJLEVBQUUsNkhBQTZILENBQUMsQ0FBQztRQUVwTyxJQUFJLENBQUMsNEJBQTRCLEdBQUcscUJBQXFCLENBQUM7UUFFMUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELE9BQU8sQ0FBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE9BQU87UUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyw0QkFBNEI7WUFDbEMsTUFBTSxJQUFJLGtCQUFRLENBQUMsU0FBUyxFQUFFLHNCQUFjLENBQUMsNEJBQTRCLEVBQUUsV0FBVyxDQUFDLElBQUksRUFBRSxtSkFBbUosQ0FBQyxDQUFDO1FBRXRQLE1BQU0sSUFBSSxHQUFHLElBQUksa0NBQVksQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3pELE1BQU0sSUFBSSxHQUFHLElBQUksdUNBQWlCLENBQUMsSUFBSSxDQUFDLDRCQUE0QixDQUFDLENBQUM7UUFFdEUsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLDRCQUE0QixHQUFHLElBQUksQ0FBQztRQUV6QyxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0NBQ0o7QUFFRCxTQUF3QixpQkFBaUI7SUFDckMsT0FBTyxJQUFJLFdBQVcsRUFBRSxDQUFDO0FBQzdCLENBQUM7QUFGRCxvQ0FFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZXF1ZXN0SG9vayBmcm9tICcuL2hvb2snO1xuaW1wb3J0IHtcbiAgICBSZXNwb25zZU1vY2ssXG4gICAgUmVxdWVzdEZpbHRlclJ1bGUsXG4gICAgU0FNRV9PUklHSU5fQ0hFQ0tfRkFJTEVEX1NUQVRVU19DT0RFLFxufSBmcm9tICd0ZXN0Y2FmZS1oYW1tZXJoZWFkJztcblxuaW1wb3J0IHsgQVBJRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMvcnVudGltZSc7XG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uLy4uL2Vycm9ycy90eXBlcyc7XG5pbXBvcnQgV0FSTklOR19NRVNTQUdFIGZyb20gJy4uLy4uL25vdGlmaWNhdGlvbnMvd2FybmluZy1tZXNzYWdlJztcblxuY2xhc3MgUmVxdWVzdE1vY2sgZXh0ZW5kcyBSZXF1ZXN0SG9vayB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICBzdXBlcihbXSk7XG5cbiAgICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdEZpbHRlclJ1bGVJbml0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb2NrcyAgICAgICAgICAgICAgICAgICAgICAgID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIGFzeW5jIG9uUmVxdWVzdCAoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbW9jayA9IHRoaXMubW9ja3MuZ2V0KGV2ZW50Ll9yZXF1ZXN0RmlsdGVyUnVsZSk7XG5cbiAgICAgICAgZXZlbnQuc2V0TW9jayhtb2NrKTtcbiAgICB9XG5cbiAgICBhc3luYyBvblJlc3BvbnNlIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuc3RhdHVzQ29kZSA9PT0gU0FNRV9PUklHSU5fQ0hFQ0tfRkFJTEVEX1NUQVRVU19DT0RFKVxuICAgICAgICAgICAgdGhpcy53YXJuaW5nTG9nLmFkZFdhcm5pbmcoV0FSTklOR19NRVNTQUdFLnJlcXVlc3RNb2NrQ09SU1ZhbGlkYXRpb25GYWlsZWQsIFJlcXVlc3RNb2NrLm5hbWUsIGV2ZW50Ll9yZXF1ZXN0RmlsdGVyUnVsZSk7XG4gICAgfVxuXG4gICAgLy8gQVBJXG4gICAgb25SZXF1ZXN0VG8gKHJlcXVlc3RGaWx0ZXJSdWxlSW5pdCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nUmVxdWVzdEZpbHRlclJ1bGVJbml0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKCdvblJlcXVlc3RUbycsIFJVTlRJTUVfRVJST1JTLnJlcXVlc3RIb29rQ29uZmlndXJlQVBJRXJyb3IsIFJlcXVlc3RNb2NrLm5hbWUsIFwiVGhlICdyZXNwb25kJyBtZXRob2Qgd2FzIG5vdCBjYWxsZWQgYWZ0ZXIgJ29uUmVxdWVzdFRvJy4gWW91IG11c3QgY2FsbCB0aGUgJ3Jlc3BvbmQnIG1ldGhvZCB0byBwcm92aWRlIHRoZSBtb2NrZWQgcmVzcG9uc2UuXCIpO1xuXG4gICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RGaWx0ZXJSdWxlSW5pdCA9IHJlcXVlc3RGaWx0ZXJSdWxlSW5pdDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXNwb25kIChib2R5LCBzdGF0dXNDb2RlLCBoZWFkZXJzKSB7XG4gICAgICAgIGlmICghdGhpcy5wZW5kaW5nUmVxdWVzdEZpbHRlclJ1bGVJbml0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKCdyZXNwb25kJywgUlVOVElNRV9FUlJPUlMucmVxdWVzdEhvb2tDb25maWd1cmVBUElFcnJvciwgUmVxdWVzdE1vY2submFtZSwgXCJUaGUgJ29uUmVxdWVzdFRvJyBtZXRob2Qgd2FzIG5vdCBjYWxsZWQgYmVmb3JlICdyZXNwb25kJy4gWW91IG11c3QgY2FsbCB0aGUgJ29uUmVxdWVzdFRvJyBtZXRob2QgdG8gcHJvdmlkZSB0aGUgVVJMIHJlcXVlc3RzIHRvIHdoaWNoIGFyZSBtb2NrZWQuXCIpO1xuXG4gICAgICAgIGNvbnN0IG1vY2sgPSBuZXcgUmVzcG9uc2VNb2NrKGJvZHksIHN0YXR1c0NvZGUsIGhlYWRlcnMpO1xuICAgICAgICBjb25zdCBydWxlID0gbmV3IFJlcXVlc3RGaWx0ZXJSdWxlKHRoaXMucGVuZGluZ1JlcXVlc3RGaWx0ZXJSdWxlSW5pdCk7XG5cbiAgICAgICAgdGhpcy5yZXF1ZXN0RmlsdGVyUnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgdGhpcy5tb2Nrcy5zZXQocnVsZSwgbW9jayk7XG4gICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RGaWx0ZXJSdWxlSW5pdCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0TW9jayAoKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0TW9jaygpO1xufVxuIl19